// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   arm/isa/main.isa

#undef DECODERFAULT
#define DECODERFAULT	machInst.decoderFault
#undef ILLEGALEXEC
#define ILLEGALEXEC	machInst.illegalExecution
#undef DEBUGSTEP
#define DEBUGSTEP	machInst.debugStep
#undef ENCODING
#define ENCODING	machInst.encoding
#undef OPCODE
#define OPCODE	machInst.opcode
#undef MEDIA_OPCODE
#define MEDIA_OPCODE	machInst.mediaOpcode
#undef MEDIA_OPCODE2
#define MEDIA_OPCODE2	machInst.mediaOpcode2
#undef USEIMM
#define USEIMM	machInst.useImm
#undef OPCODE_24
#define OPCODE_24	machInst.opcode24
#undef OPCODE_24_23
#define OPCODE_24_23	machInst.opcode24_23
#undef OPCODE_23_20
#define OPCODE_23_20	machInst.opcode23_20
#undef OPCODE_23_21
#define OPCODE_23_21	machInst.opcode23_21
#undef OPCODE_22
#define OPCODE_22	machInst.opcode22
#undef OPCODE_20
#define OPCODE_20	machInst.opcode20
#undef OPCODE_19_16
#define OPCODE_19_16	machInst.opcode19_16
#undef OPCODE_19
#define OPCODE_19	machInst.opcode19
#undef OPCODE_18
#define OPCODE_18	machInst.opcode18
#undef OPCODE_15_12
#define OPCODE_15_12	machInst.opcode15_12
#undef OPCODE_15
#define OPCODE_15	machInst.opcode15
#undef MISC_OPCODE
#define MISC_OPCODE	machInst.miscOpcode
#undef OPC2
#define OPC2	machInst.opc2
#undef OPCODE_7
#define OPCODE_7	machInst.opcode7
#undef OPCODE_6
#define OPCODE_6	machInst.opcode6
#undef OPCODE_4
#define OPCODE_4	machInst.opcode4
#undef IS_MISC
#define IS_MISC	machInst.isMisc
#undef SEVEN_AND_FOUR
#define SEVEN_AND_FOUR	machInst.sevenAndFour
#undef THUMB
#define THUMB	machInst.thumb
#undef BIGTHUMB
#define BIGTHUMB	machInst.bigThumb
#undef AARCH64
#define AARCH64	machInst.aarch64
#undef COND_CODE
#define COND_CODE	machInst.condCode
#undef S_FIELD
#define S_FIELD	machInst.sField
#undef RN
#define RN	machInst.rn
#undef RD
#define RD	machInst.rd
#undef RT
#define RT	machInst.rt
#undef SHIFT_SIZE
#define SHIFT_SIZE	machInst.shiftSize
#undef SHIFT
#define SHIFT	machInst.shift
#undef RM
#define RM	machInst.rm
#undef RS
#define RS	machInst.rs
#undef PUSWL
#define PUSWL	machInst.puswl
#undef PREPOST
#define PREPOST	machInst.puswl.prepost
#undef UP
#define UP	machInst.puswl.up
#undef PSRUSER
#define PSRUSER	machInst.puswl.psruser
#undef WRITEBACK
#define WRITEBACK	machInst.puswl.writeback
#undef LOADOP
#define LOADOP	machInst.puswl.loadOp
#undef PUBWL
#define PUBWL	machInst.pubwl
#undef IMM
#define IMM	machInst.imm
#undef IMMED_11_0
#define IMMED_11_0	machInst.immed11_0
#undef IMMED_7_0
#define IMMED_7_0	machInst.immed7_0
#undef IMMED_HI_11_8
#define IMMED_HI_11_8	machInst.immedHi11_8
#undef IMMED_LO_3_0
#define IMMED_LO_3_0	machInst.immedLo3_0
#undef IMMED_23_0
#define IMMED_23_0	machInst.immed23_0
#undef CPNUM
#define CPNUM	machInst.cpNum
#undef FN
#define FN	machInst.fn
#undef FD
#define FD	machInst.fd
#undef FPREGIMM
#define FPREGIMM	machInst.fpRegImm
#undef FM
#define FM	machInst.fm
#undef FPIMM
#define FPIMM	machInst.fpImm
#undef PUNWL
#define PUNWL	machInst.punwl
#undef M5FUNC
#define M5FUNC	machInst.m5Func
#undef TOPCODE_15_13
#define TOPCODE_15_13	machInst.topcode15_13
#undef TOPCODE_13_11
#define TOPCODE_13_11	machInst.topcode13_11
#undef TOPCODE_12_11
#define TOPCODE_12_11	machInst.topcode12_11
#undef TOPCODE_12_10
#define TOPCODE_12_10	machInst.topcode12_10
#undef TOPCODE_11_9
#define TOPCODE_11_9	machInst.topcode11_9
#undef TOPCODE_11_8
#define TOPCODE_11_8	machInst.topcode11_8
#undef TOPCODE_10_9
#define TOPCODE_10_9	machInst.topcode10_9
#undef TOPCODE_10_8
#define TOPCODE_10_8	machInst.topcode10_8
#undef TOPCODE_9_6
#define TOPCODE_9_6	machInst.topcode9_6
#undef TOPCODE_7
#define TOPCODE_7	machInst.topcode7
#undef TOPCODE_7_6
#define TOPCODE_7_6	machInst.topcode7_6
#undef TOPCODE_7_5
#define TOPCODE_7_5	machInst.topcode7_5
#undef TOPCODE_7_4
#define TOPCODE_7_4	machInst.topcode7_4
#undef TOPCODE_3_0
#define TOPCODE_3_0	machInst.topcode3_0
#undef HTOPCODE_12_11
#define HTOPCODE_12_11	machInst.htopcode12_11
#undef HTOPCODE_10_9
#define HTOPCODE_10_9	machInst.htopcode10_9
#undef HTOPCODE_9
#define HTOPCODE_9	machInst.htopcode9
#undef HTOPCODE_9_8
#define HTOPCODE_9_8	machInst.htopcode9_8
#undef HTOPCODE_9_5
#define HTOPCODE_9_5	machInst.htopcode9_5
#undef HTOPCODE_9_4
#define HTOPCODE_9_4	machInst.htopcode9_4
#undef HTOPCODE_8
#define HTOPCODE_8	machInst.htopcode8
#undef HTOPCODE_8_7
#define HTOPCODE_8_7	machInst.htopcode8_7
#undef HTOPCODE_8_6
#define HTOPCODE_8_6	machInst.htopcode8_6
#undef HTOPCODE_8_5
#define HTOPCODE_8_5	machInst.htopcode8_5
#undef HTOPCODE_7
#define HTOPCODE_7	machInst.htopcode7
#undef HTOPCODE_7_5
#define HTOPCODE_7_5	machInst.htopcode7_5
#undef HTOPCODE_6
#define HTOPCODE_6	machInst.htopcode6
#undef HTOPCODE_6_5
#define HTOPCODE_6_5	machInst.htopcode6_5
#undef HTOPCODE_5_4
#define HTOPCODE_5_4	machInst.htopcode5_4
#undef HTOPCODE_4
#define HTOPCODE_4	machInst.htopcode4
#undef HTRN
#define HTRN	machInst.htrn
#undef HTS
#define HTS	machInst.hts
#undef LTOPCODE_15
#define LTOPCODE_15	machInst.ltopcode15
#undef LTOPCODE_11_8
#define LTOPCODE_11_8	machInst.ltopcode11_8
#undef LTOPCODE_7_6
#define LTOPCODE_7_6	machInst.ltopcode7_6
#undef LTOPCODE_7_4
#define LTOPCODE_7_4	machInst.ltopcode7_4
#undef LTOPCODE_4
#define LTOPCODE_4	machInst.ltopcode4
#undef LTRD
#define LTRD	machInst.ltrd
#undef LTCOPROC
#define LTCOPROC	machInst.ltcoproc

    template <class T>
    // Implement a less-than-zero function: ltz()
    // this function exists because some versions of GCC complain when a
    // comparison is done between a unsigned variable and 0 and for GCC 4.2
    // there is no way to disable this warning
    inline bool ltz(T t);

    template <>
    inline bool ltz(uint8_t) { return false; }
    template <>
    inline bool ltz(uint16_t) { return false; }
    template <>
    inline bool ltz(uint32_t) { return false; }
    template <>
    inline bool ltz(uint64_t) { return false; }
    template <>
    inline bool ltz(int8_t v) { return v < 0; }
    template <>
    inline bool ltz(int16_t v) { return v < 0; }
    template <>
    inline bool ltz(int32_t v) { return v < 0; }
    template <>
    inline bool ltz(int64_t v) { return v < 0; }

        template <typename T>
        struct bigger_type_t;

        template<> struct bigger_type_t<uint8_t> { typedef uint16_t type; };
        template<> struct bigger_type_t<uint16_t> { typedef uint32_t type; };
        template<> struct bigger_type_t<uint32_t> { typedef uint64_t type; };

        template<> struct bigger_type_t<int8_t> { typedef int16_t type; };
        template<> struct bigger_type_t<int16_t> { typedef int32_t type; };
        template<> struct bigger_type_t<int32_t> { typedef int64_t type; };

class Movz : public RegImmImmOp
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Movz(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Movk : public RegImmImmOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Movk(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Movn : public RegImmImmOp
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Movn(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    class CAS64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CAS64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class CASA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASAL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASAL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class CASAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASALB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASALB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class CASAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASALH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASALH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CAS32 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CAS32(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class CASA32 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASA32(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASAL32 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASAL32(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASL32 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        CASL32(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASP64 : public ArmISA::MemoryAtomicPair64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        /// Constructor.
        CASP64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 4);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class CASPA64 : public ArmISA::MemoryAtomicPair64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        /// Constructor.
        CASPA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 4);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASPAL64 : public ArmISA::MemoryAtomicPair64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        /// Constructor.
        CASPAL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 4);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASPL64 : public ArmISA::MemoryAtomicPair64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        /// Constructor.
        CASPL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 4);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASP32 : public ArmISA::MemoryAtomicPair64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        /// Constructor.
        CASP32(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class CASPA32 : public ArmISA::MemoryAtomicPair64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        /// Constructor.
        CASPA32(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASPAL32 : public ArmISA::MemoryAtomicPair64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        /// Constructor.
        CASPAL32(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class CASPL32 : public ArmISA::MemoryAtomicPair64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        /// Constructor.
        CASPL32(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDADDLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDADDLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADD : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADD(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDADDL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADD64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADD64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDADDL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDADDLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDADDLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDCLRLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDCLRLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLR : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLR(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDCLRL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLR64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLR64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDCLRL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDCLRLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDCLRLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDEORLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDEORLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEOR : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEOR(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDEORL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEOR64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEOR64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDEORL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDEORLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDEORLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSETLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSETLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSET : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSET(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSETL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSET64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSET64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSETL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSETLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSETLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSMAXLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSMAXLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAX : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAX(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSMAXL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAX64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSMAXL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMAXLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMAXLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSMINLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSMINLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMIN : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMIN(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSMINL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMIN64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMIN64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDSMINL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDSMINLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDSMINLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDUMAXLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDUMAXLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAX : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAX(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDUMAXL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAX64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDUMAXL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMAXLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMAXLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDUMINLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDUMINLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMIN : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMIN(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDUMINL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMIN64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMIN64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class LDUMINL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class LDUMINLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        LDUMINLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STADDB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STADDB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STADDLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STADDLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STADDH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STADDH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STADDLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STADDLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STADD : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STADD(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STADDL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STADDL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STADD64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STADD64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STADDL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STADDL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STCLRB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STCLRB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STCLRLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STCLRLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STCLRH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STCLRH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STCLRLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STCLRLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STCLR : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STCLR(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STCLRL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STCLRL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STCLR64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STCLR64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STCLRL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STCLRL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STEORB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STEORB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STEORLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STEORLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STEORH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STEORH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STEORLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STEORLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STEOR : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STEOR(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STEORL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STEORL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STEOR64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STEOR64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STEORL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STEORL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSETB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSETB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSETLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSETLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSETAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSETAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSETLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSETLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSETH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSETH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSETLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSETLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSET : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSET(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSETL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSETL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSET64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSET64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSETL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSETL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSMAXB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMAXB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSMAXLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMAXLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSMAXH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMAXH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSMAXLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMAXLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSMAX : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMAX(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSMAXL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMAXL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSMAX64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMAX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSMAXL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMAXL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSMINB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMINB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSMINLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMINLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSMINH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMINH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSMINLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMINLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSMIN : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMIN(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSMINL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMINL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STSMIN64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMIN64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STSMINL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STSMINL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, true);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STUMAXB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMAXB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STUMAXLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMAXLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STUMAXH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMAXH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STUMAXLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMAXLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STUMAX : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMAX(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STUMAXL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMAXL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STUMAX64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMAX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STUMAXL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMAXL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STUMINB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMINB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STUMINLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMINLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STUMINH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMINH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STUMINLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMINLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STUMIN : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMIN(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STUMINL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMINL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class STUMIN64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMIN64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class STUMINL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        STUMINL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class SWPLB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPLB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPLAB : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPLAB(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 0);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class SWPLH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPLH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPLAH : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPLAH(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 1);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWP : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWP(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class SWPL : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPL(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPLA : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPLA(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 2);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, false);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWP64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWP64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, false);
               
        }
    };

    class SWPL64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPL64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    class SWPLA64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        bool isXZR ;
        /// Constructor.
        SWPLA64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
               fault->annotate(ArmISA::ArmFault::SAS, 3);
               fault->annotate(ArmISA::ArmFault::SSE, false);
               fault->annotate(ArmISA::ArmFault::SRT, dest);
               fault->annotate(ArmISA::ArmFault::SF, true);
               fault->annotate(ArmISA::ArmFault::AR, true);
               
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PY_AY_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PY_AY_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PY_AY_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PY_AN_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PY_AN_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PY_AN_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PN_AY_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PN_AY_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PN_AY_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PN_AN_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PN_AN_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PN_AN_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PY_AY_WY_SN_UY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PY_AY_WY_SN_UY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PY_AY_WY_SN_UY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PY_AN_WY_SN_UY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PY_AN_WY_SN_UY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PY_AN_WY_SN_UY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PN_AY_WY_SN_UY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PN_AY_WY_SN_UY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PN_AY_WY_SN_UY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PN_AN_WY_SN_UY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PN_AN_WY_SN_UY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PN_AN_WY_SN_UY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PN_AY_WN_SN_UY_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PN_AY_WN_SN_UY_SZ4 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_PN_AN_WN_SN_UY_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_PN_AN_WN_SN_UY_SZ4 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PY_AY_WY_SN_UN_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PY_AY_WY_SN_UN_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PY_AY_WY_SN_UN_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PY_AN_WY_SN_UN_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PY_AN_WY_SN_UN_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PY_AN_WY_SN_UN_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PN_AY_WY_SN_UN_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PN_AY_WY_SN_UN_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PN_AY_WY_SN_UN_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PN_AN_WY_SN_UN_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PN_AN_WY_SN_UN_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PN_AN_WY_SN_UN_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PY_AY_WY_SN_UY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PY_AY_WY_SN_UY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PY_AY_WY_SN_UY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PY_AN_WY_SN_UY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PY_AN_WY_SN_UY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PY_AN_WY_SN_UY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PN_AY_WY_SN_UY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PN_AY_WY_SN_UY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PN_AY_WY_SN_UY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PN_AN_WY_SN_UY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PN_AN_WY_SN_UY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PN_AN_WY_SN_UY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PN_AY_WN_SN_UY_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PN_AY_WN_SN_UY_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_PN_AN_WN_SN_UY_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_PN_AN_WN_SN_UY_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PY_AY_WY_SY_UN_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PY_AY_WY_SY_UN_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PY_AY_WY_SY_UN_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PY_AN_WY_SY_UN_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PY_AN_WY_SY_UN_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PY_AN_WY_SY_UN_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PN_AY_WY_SY_UN_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PN_AY_WY_SY_UN_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PN_AY_WY_SY_UN_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PN_AN_WY_SY_UN_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PN_AN_WY_SY_UN_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PN_AN_WY_SY_UN_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PN_AY_WN_SY_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PN_AY_WN_SY_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_PN_AN_WN_SY_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_PN_AN_WN_SY_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SY_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PY_AY_WY_SY_UY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PY_AY_WY_SY_UY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PY_AY_WY_SY_UY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PY_AN_WY_SY_UY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PY_AN_WY_SY_UY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PY_AN_WY_SY_UY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PN_AY_WY_SY_UY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PN_AY_WY_SY_UY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PN_AY_WY_SY_UY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PN_AN_WY_SY_UY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PN_AN_WY_SY_UY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PN_AN_WY_SY_UY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PN_AY_WN_SY_UY_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PN_AY_WN_SY_UY_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_PN_AN_WN_SY_UY_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_PN_AN_WN_SY_UY_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SY_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PY_AY_WY_SN_UN_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PY_AY_WY_SN_UN_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PY_AY_WY_SN_UN_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PY_AN_WY_SN_UN_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PY_AN_WY_SN_UN_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PY_AN_WY_SN_UN_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PN_AY_WY_SN_UN_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PN_AY_WY_SN_UN_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PN_AY_WY_SN_UN_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PN_AN_WY_SN_UN_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PN_AN_WY_SN_UN_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PN_AN_WY_SN_UN_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_PN_AN_WN_SN_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_PN_AN_WN_SN_UN_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PY_AY_WY_SN_UY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PY_AY_WY_SN_UY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PY_AY_WY_SN_UY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PY_AN_WY_SN_UY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PY_AN_WY_SN_UY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PY_AN_WY_SN_UY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PN_AY_WY_SN_UY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PN_AY_WY_SN_UY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PN_AY_WY_SN_UY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PN_AN_WY_SN_UY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PN_AN_WY_SN_UY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PN_AN_WY_SN_UY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PN_AY_WN_SN_UY_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PN_AY_WN_SN_UY_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_PN_AN_WN_SN_UY_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_PN_AN_WN_SN_UY_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PY_AY_WY_SY_UN_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PY_AY_WY_SY_UN_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PY_AY_WY_SY_UN_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PY_AN_WY_SY_UN_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PY_AN_WY_SY_UN_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PY_AN_WY_SY_UN_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PN_AY_WY_SY_UN_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PN_AY_WY_SY_UN_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PN_AY_WY_SY_UN_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PN_AN_WY_SY_UN_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PN_AN_WY_SY_UN_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PN_AN_WY_SY_UN_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PN_AY_WN_SY_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PN_AY_WN_SY_UN_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_PN_AN_WN_SY_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_PN_AN_WN_SY_UN_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SY_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PY_AY_WY_SY_UY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PY_AY_WY_SY_UY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AY_WY_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PY_AY_WY_SY_UY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AY_WY_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PY_AN_WY_SY_UY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PY_AN_WY_SY_UY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PY_AN_WY_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PY_AN_WY_SY_UY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PY_AN_WY_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PN_AY_WY_SY_UY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PN_AY_WY_SY_UY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WY_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PN_AY_WY_SY_UY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WY_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PN_AN_WY_SY_UY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PN_AN_WY_SY_UY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WY_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PN_AN_WY_SY_UY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WY_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PN_AY_WN_SY_UY_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AY_WN_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PN_AY_WN_SY_UY_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AY_WN_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_PN_AN_WN_SY_UY_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_IMM_PN_AN_WN_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_PN_AN_WN_SY_UY_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LOAD_REG_PN_AN_WN_SY_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, true);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PY_AY_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_IMMD_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PY_AY_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMMD_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PY_AY_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_REGD_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PY_AY_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REGD_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PY_AN_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_IMMD_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PY_AN_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMMD_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PY_AN_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_REGD_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PY_AN_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REGD_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PN_AY_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_IMMD_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PN_AY_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMMD_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PN_AY_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_REGD_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PN_AY_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REGD_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PN_AN_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_IMMD_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PN_AN_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_IMMD_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PN_AN_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_REGD_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PN_AN_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LOAD_REGD_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_REGD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_IMMD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LOAD_REGD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8Acc : public RfeOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8 : public RfeOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8Acc : public RfeOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8 : public RfeOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8Acc : public RfeOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8 : public RfeOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8Acc : public RfeOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8 : public RfeOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8Acc : public RfeOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8 : public RfeOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8Acc : public RfeOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8 : public RfeOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8Acc : public RfeOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8 : public RfeOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8Acc : public RfeOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8 : public RfeOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_REG_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLD_LOAD_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_IMM_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLD_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_REG_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLD_LOAD_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLD_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_REG_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLDW_LOAD_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_IMM_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLDW_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_REG_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLDW_LOAD_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLDW_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_REG_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLI_LOAD_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_IMM_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLI_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_REG_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLI_LOAD_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PLI_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrex".
     */
    class LDREX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDREX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrexh".
     */
    class LDREXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDREXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrexb".
     */
    class LDREXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDREXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrexd".
     */
    class LDREXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LDREXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "lda".
     */
    class LDA_LOAD_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDA_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldah".
     */
    class LDAH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldab".
     */
    class LDAB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldaex".
     */
    class LDAEX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAEX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldaexh".
     */
    class LDAEXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAEXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldaexb".
     */
    class LDAEXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAEXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldaexd".
     */
    class LDAEXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LDAEXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        VLDR_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMM_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        VLDR_LOAD_IMM_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        VLDR_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMMD_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        VLDR_LOAD_IMMD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class LDRAA_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LDRAA_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRAA_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRAA_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRAA_REG : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRAA_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRAB_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LDRAB_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRAB_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRAB_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRAB_REG : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRAB_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRB64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRB64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRB64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRB64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRB64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRB64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRB64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRB64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRB64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRB64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRB64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRB64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSBW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSBW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSBW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSBW64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSBW64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSBW64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSBW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSBW64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSBW64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSBW64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSBW64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSBW64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSBX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSBX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSBX64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSBX64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSBX64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSBX64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSBX64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSBX64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSBX64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSBX64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSBX64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSBX64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRH64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRH64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRH64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRH64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRH64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRH64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRH64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRH64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRH64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRH64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRH64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRH64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSHW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSHW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSHW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSHW64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSHW64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSHW64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSHW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSHW64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSHW64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSHW64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSHW64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSHW64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSHX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSHX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSHX64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSHX64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSHX64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSHX64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSHX64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSHX64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSHX64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSHX64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSHX64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSHX64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSW64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSW64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSW64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSW64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSW64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSW64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSW64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSW64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRW64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRW64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRW64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRW64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRW64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRW64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRW64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRW64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRX64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRX64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRX64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRX64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRX64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRX64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRX64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRX64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRX64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRX64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRBFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRBFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRBFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRBFP64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRBFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRBFP64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRBFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRBFP64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRBFP64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRBFP64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRBFP64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRBFP64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRHFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRHFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRHFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRHFP64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRHFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRHFP64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRHFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRHFP64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRHFP64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRHFP64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRHFP64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRHFP64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRSFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRSFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSFP64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSFP64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSFP64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSFP64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRSFP64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRSFP64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSFP64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRDFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRDFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRDFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRDFP64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRDFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRDFP64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRDFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRDFP64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRDFP64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        LDRDFP64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class LDRDFP64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRDFP64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class PRFM64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PRFM64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class PRFM64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PRFM64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class PRFM64_LIT : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PRFM64_LIT(ExtMachInst machInst, RegIndex _dest, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class PRFUM64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        PRFUM64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDURB64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURB64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURSBW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURSBW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURSBX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURSBX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURH64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURH64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURSHW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURSHW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURSHX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURSHX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURSW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURSW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDURBFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURBFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDURHFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURHFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDURSFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURSFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDURDFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDURDFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDTRB64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRB64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDTRSBW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRSBW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDTRSBX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRSBX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDTRH64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRH64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDTRSHW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRSHW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDTRSHX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRSHX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDTRSW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRSW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDTRW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDTRX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDTRX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSWL64_LIT : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSWL64_LIT(ExtMachInst machInst, RegIndex _dest, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, true);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRWL64_LIT : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRWL64_LIT(ExtMachInst machInst, RegIndex _dest, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRXL64_LIT : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRXL64_LIT(ExtMachInst machInst, RegIndex _dest, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class LDRSFP64_LIT : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRSFP64_LIT(ExtMachInst machInst, RegIndex _dest, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRDFP64_LIT : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDRDFP64_LIT(ExtMachInst machInst, RegIndex _dest, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDARX64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDARX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class LDARW64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDARW64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class LDARH64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDARH64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class LDARB64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDARB64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class LDAXRX64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAXRX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXRW64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAXRW64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXRH64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAXRH64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXRB64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAXRB64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXRX64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDXRX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXRW64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDXRW64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXRH64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDXRH64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXRB64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDXRB64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAPRX64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAPRX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class LDAPRW64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAPRW64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class LDAPRH64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAPRH64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class LDAPRB64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        LDAPRB64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class MicroLdPairUop : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        MicroLdPairUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdPairFp8Uop : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        MicroLdPairFp8Uop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdFp16Uop : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdFp16Uop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdFp16RegUop : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdFp16RegUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXPW64 : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LDAXPW64(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXPX64 : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LDAXPX64(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXPW64 : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LDXPW64(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXPX64 : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        LDXPX64(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrXImmUop : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdrXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrXRegUop : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdrXRegUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrXLitUop : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdrXLitUop(ExtMachInst machInst, RegIndex _dest, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrFpXImmUop : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdrFpXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrFpXRegUop : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdrFpXRegUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrFpXLitUop : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdrFpXLitUop(ExtMachInst machInst, RegIndex _dest, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdFp16LitUop : public ArmISA::MemoryLiteral64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        MicroLdFp16LitUop(ExtMachInst machInst, RegIndex _dest, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrDUXImmUop : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        MicroLdrDUXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrDSXImmUop : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        MicroLdrDSXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrDFpXImmUop : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        MicroLdrDFpXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

class Svc : public ImmOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Svc(ExtMachInst machInst, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Hlt : public ImmOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Hlt(ExtMachInst machInst, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "smc".
     */
    class Smc : public PredOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Smc(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class Hvc : public ImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Hvc(ExtMachInst machInst, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "eret".
     */
    class Eret : public PredOp
    {
      private:
        RegId srcRegIdxArr[19]; RegId destRegIdxArr[5];

      public:
        /// Constructor.
        Eret(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class Crc32b : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32b(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32h : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32h(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32w : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32w(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32cb : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32cb(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32ch : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32ch(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32cw : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32cw(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MrsCpsr : public MrsOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MrsCpsr(ExtMachInst machInst, RegIndex _dest);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MrsSpsr : public MrsOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MrsSpsr(ExtMachInst machInst, RegIndex _dest);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MrsBankedReg : public MrsOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

  protected:
    uint8_t byteMask;
    bool r;

  public:
    // Constructor
    MrsBankedReg(ExtMachInst machInst, RegIndex _dest,
                   uint8_t _sysM, bool _r);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MsrBankedReg : public MsrRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

  protected:
    bool r;

  public:
    // Constructor
    MsrBankedReg(ExtMachInst machInst, RegIndex _op1,
                   uint8_t _sysM, bool _r);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MsrCpsrReg : public MsrRegOp
{
  private:
    RegId srcRegIdxArr[14]; RegId destRegIdxArr[5];

  public:
    // Constructor
    MsrCpsrReg(ExtMachInst machInst, RegIndex _op1, uint8_t mask);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MsrSpsrReg : public MsrRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MsrSpsrReg(ExtMachInst machInst, RegIndex _op1, uint8_t mask);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MsrCpsrImm : public MsrImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[5];

  public:
    // Constructor
    MsrCpsrImm(ExtMachInst machInst, uint32_t imm, uint8_t mask);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MsrSpsrImm : public MsrImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MsrSpsrImm(ExtMachInst machInst, uint32_t imm, uint8_t mask);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Rev : public RegRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Rev(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Rev16 : public RegRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Rev16(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Revsh : public RegRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Revsh(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Rbit : public RegRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Rbit(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Clz : public RegRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Clz(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Ssat : public RegImmRegShiftOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Ssat(ExtMachInst machInst, RegIndex _dest, uint64_t _imm,
                   RegIndex _op1, int32_t _shiftAmt,
                   ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Usat : public RegImmRegShiftOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Usat(ExtMachInst machInst, RegIndex _dest, uint64_t _imm,
                   RegIndex _op1, int32_t _shiftAmt,
                   ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Ssat16 : public RegImmRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Ssat16(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Usat16 : public RegImmRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Usat16(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sxtb : public RegImmRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sxtb(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sxtab : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sxtab(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sxtb16 : public RegImmRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sxtb16(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sxtab16 : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sxtab16(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sxth : public RegImmRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sxth(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sxtah : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sxtah(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uxtb : public RegImmRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uxtb(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uxtab : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uxtab(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uxtb16 : public RegImmRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uxtb16(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uxtab16 : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uxtab16(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uxth : public RegImmRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uxth(ExtMachInst machInst, RegIndex _dest,
                   uint64_t _imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uxtah : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uxtah(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sel : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sel(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Usad8 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Usad8(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Usada8 : public RegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Usada8(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _op3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "bkpt".
     */
    class BkptInst : public PredOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        BkptInst(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "nop".
     */
    class NopInst : public ArmStaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        NopInst(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "yield".
     */
    class YieldInst : public PredOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        YieldInst(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "wfe".
     */
    class WfeInst : public PredOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        WfeInst(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "wfi".
     */
    class WfiInst : public PredOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        WfiInst(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "sev".
     */
    class SevInst : public PredOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        SevInst(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "sevl".
     */
    class SevlInst : public PredOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        SevlInst(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "it".
     */
    class ItInst : public PredOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        ItInst(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "unknown".
     */
    class Unknown : public UnknownOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Unknown(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class Ubfx : public RegRegImmImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Ubfx(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sbfx : public RegRegImmImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sbfx(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Bfc : public RegRegImmImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Bfc(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Bfi : public RegRegImmImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Bfi(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mrc14 : public RegMiscRegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mrc14(ExtMachInst machInst, RegIndex _dest, MiscRegIndex _op1,
                   uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mcr14 : public MiscRegRegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mcr14(ExtMachInst machInst, MiscRegIndex _dest, RegIndex _op1,
                   uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mrc15 : public RegMiscRegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mrc15(ExtMachInst machInst, RegIndex _dest, MiscRegIndex _op1,
                   uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mcr15 : public MiscRegRegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mcr15(ExtMachInst machInst, MiscRegIndex _dest, RegIndex _op1,
                   uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Tlbi : public TlbiOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Tlbi(ExtMachInst machInst, MiscRegIndex _dest, RegIndex _op1,
                   uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mrrc15 : public MrrcOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Mrrc15(ExtMachInst machInst, MiscRegIndex _op1,
                   RegIndex _dest, RegIndex _dest2, uint32_t imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mcrr15 : public McrrOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mcrr15(ExtMachInst machInst, RegIndex _op1, RegIndex _op2,
                   MiscRegIndex _dest, uint32_t imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "enterx".
     */
    class Enterx : public PredOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Enterx(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "leavex".
     */
    class Leavex : public PredOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Leavex(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class Setend : public ImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Setend(ExtMachInst machInst, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "clrex".
     */
    class Clrex : public PredOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        Clrex(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class McrDcimvac : public MiscRegRegImmOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        // Constructor
        McrDcimvac(ExtMachInst machInst, MiscRegIndex _dest,
                       RegIndex _op1, uint64_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class McrDccmvac : public MiscRegRegImmOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        // Constructor
        McrDccmvac(ExtMachInst machInst, MiscRegIndex _dest,
                       RegIndex _op1, uint64_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class McrDccmvau : public MiscRegRegImmOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        // Constructor
        McrDccmvau(ExtMachInst machInst, MiscRegIndex _dest,
                       RegIndex _op1, uint64_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class McrDccimvac : public MiscRegRegImmOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        // Constructor
        McrDccimvac(ExtMachInst machInst, MiscRegIndex _dest,
                       RegIndex _op1, uint64_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

class Isb : public ImmOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Isb(ExtMachInst machInst, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Dsb : public ImmOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Dsb(ExtMachInst machInst, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Dmb : public ImmOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Dmb(ExtMachInst machInst, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "dbg".
     */
    class Dbg : public PredOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Dbg(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class Cps : public ImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Cps(ExtMachInst machInst, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Svc64 : public ImmOp64
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Svc64(ExtMachInst machInst,uint64_t _imm);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Hvc64 : public ImmOp64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Hvc64(ExtMachInst machInst,uint64_t _imm);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smc64 : public ImmOp64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Smc64(ExtMachInst machInst,uint64_t _imm);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Bfm64 : public RegRegImmImmOp64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Bfm64(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Ubfm64 : public RegRegImmImmOp64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Ubfm64(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sbfm64 : public RegRegImmImmOp64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sbfm64(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm1, uint64_t _imm2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Extr64 : public RegRegRegImmOp64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Extr64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                   RegIndex _op2, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "unknown".
     */
    class Unknown64 : public UnknownOp64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Unknown64(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "isb".
     */
    class Isb64 : public ArmStaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Isb64(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "dsb".
     */
    class Dsb64Local : public ArmStaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Dsb64Local(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "dsb".
     */
    class Dsb64Shareable : public ArmStaticInst
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];
        const bool dvmEnabled;

      public:
        /// Constructor.
        Dsb64Shareable(ExtMachInst machInst, bool dvm_enabled);
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "dmb".
     */
    class Dmb64 : public ArmStaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Dmb64(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "clrex".
     */
    class Clrex64 : public ArmStaticInst
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        Clrex64(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class Brk64 : public ImmOp64
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Brk64(ExtMachInst machInst,uint64_t _imm);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Hlt64 : public ImmOp64
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Hlt64(ExtMachInst machInst,uint64_t _imm);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    class STRB64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRB64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRB64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRB64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRB64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRB64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRB64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRB64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRB64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRB64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRB64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRB64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRH64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRH64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRH64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRH64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRH64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRH64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRH64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRH64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRH64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRH64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRH64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRH64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRW64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRW64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRW64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRW64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRW64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRW64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRW64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRW64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRX64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRX64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRX64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRX64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRX64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRX64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRX64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRX64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRX64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRX64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STRBFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRBFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRBFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRBFP64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRBFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRBFP64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRBFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRBFP64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRBFP64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRBFP64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRBFP64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRBFP64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRHFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRHFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRHFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRHFP64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRHFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRHFP64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRHFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRHFP64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRHFP64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRHFP64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRHFP64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRHFP64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRSFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRSFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRSFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRSFP64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRSFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRSFP64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRSFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRSFP64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRSFP64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRSFP64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRSFP64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRSFP64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRDFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRDFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRDFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRDFP64_PREAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRDFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRDFP64_PRE(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRDFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRDFP64_POSTAcc(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRDFP64_POST : public ArmISA::MemoryPostIndex64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRDFP64_POST(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class STRDFP64_REG : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STRDFP64_REG(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STURB64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STURB64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STURH64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STURH64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STURW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STURW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STURX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STURX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STURBFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STURBFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STURHFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STURHFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STURSFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STURSFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STURDFP64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STURDFP64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STTRB64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STTRB64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STTRH64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STTRH64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STTRW64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STTRW64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STTRX64_IMM : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STTRX64_IMM(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, false);
                
        }
    };

    class STLRX64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STLRX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 3);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, true);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class STLRW64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STLRW64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 2);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class STLRH64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STLRH64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 1);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class STLRB64 : public ArmISA::MemoryRaw64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STLRB64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    fault->annotate(ArmISA::ArmFault::SAS, 0);
                    fault->annotate(ArmISA::ArmFault::SSE, false);
                    fault->annotate(ArmISA::ArmFault::SRT, dest);
                    fault->annotate(ArmISA::ArmFault::SF, false);
                    fault->annotate(ArmISA::ArmFault::AR, true);
                
        }
    };

    class STLXRX64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLXRX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STLXRW64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLXRW64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STLXRH64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLXRH64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STLXRB64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLXRB64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STXRX64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STXRX64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STXRW64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STXRW64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STXRH64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STXRH64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class STXRB64 : public ArmISA::MemoryEx64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STXRB64(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _base, RegIndex _result);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "stlxp".
     */
    class STLXPW64 : public ArmISA::MemoryDImmEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLXPW64(ExtMachInst machInst,
                RegIndex _result, RegIndex _dest, RegIndex _dest2,
                RegIndex _base, int64_t _imm = 0);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "stlxp".
     */
    class STLXPX64 : public ArmISA::MemoryDImmEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLXPX64(ExtMachInst machInst,
                RegIndex _result, RegIndex _dest, RegIndex _dest2,
                RegIndex _base, int64_t _imm = 0);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "stxp".
     */
    class STXPW64 : public ArmISA::MemoryDImmEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STXPW64(ExtMachInst machInst,
                RegIndex _result, RegIndex _dest, RegIndex _dest2,
                RegIndex _base, int64_t _imm = 0);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "stxp".
     */
    class STXPX64 : public ArmISA::MemoryDImmEx64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STXPX64(ExtMachInst machInst,
                RegIndex _result, RegIndex _dest, RegIndex _dest2,
                RegIndex _base, int64_t _imm = 0);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroStrXImmUop : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrXRegUop : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrXRegUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrFpXImmUop : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrFpXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrFpXRegUop : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrFpXRegUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrQBFpXImmUop : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrQBFpXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrQBFpXRegUop : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrQBFpXRegUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrQTFpXImmUop : public ArmISA::MemoryImm64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrQTFpXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrQTFpXRegUop : public ArmISA::MemoryReg64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrQTFpXRegUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, RegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrDXImmUop : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrDXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrDFpXImmUop : public ArmISA::MemoryDImm64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        MicroStrDFpXImmUop(ExtMachInst machInst,
                RegIndex _dest, RegIndex _dest2, RegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PY_AY_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PY_AY_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PY_AY_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PY_AY_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PY_AN_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PY_AN_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PY_AN_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PY_AN_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PN_AY_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PN_AY_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PN_AY_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PN_AY_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PN_AN_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PN_AN_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PN_AN_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PN_AN_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PY_AY_WY_SN_UY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PY_AY_WY_SN_UY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PY_AY_WY_SN_UY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PY_AY_WY_SN_UY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PY_AN_WY_SN_UY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PY_AN_WY_SN_UY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PY_AN_WY_SN_UY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PY_AN_WY_SN_UY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PN_AY_WY_SN_UY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PN_AY_WY_SN_UY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PN_AY_WY_SN_UY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PN_AY_WY_SN_UY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PN_AN_WY_SN_UY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PN_AN_WY_SN_UY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PN_AN_WY_SN_UY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PN_AN_WY_SN_UY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PN_AY_WN_SN_UY_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WN_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PN_AY_WN_SN_UY_SZ4 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WN_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_PN_AN_WN_SN_UY_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WN_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_PN_AN_WN_SN_UY_SZ4 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WN_SN_UY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PY_AY_WY_SN_UN_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PY_AY_WY_SN_UN_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PY_AY_WY_SN_UN_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PY_AY_WY_SN_UN_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PY_AN_WY_SN_UN_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PY_AN_WY_SN_UN_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PY_AN_WY_SN_UN_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PY_AN_WY_SN_UN_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PN_AY_WY_SN_UN_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PN_AY_WY_SN_UN_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PN_AY_WY_SN_UN_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PN_AY_WY_SN_UN_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PN_AN_WY_SN_UN_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PN_AN_WY_SN_UN_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PN_AN_WY_SN_UN_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PN_AN_WY_SN_UN_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_PN_AN_WN_SN_UN_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PY_AY_WY_SN_UY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PY_AY_WY_SN_UY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PY_AY_WY_SN_UY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PY_AY_WY_SN_UY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PY_AN_WY_SN_UY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PY_AN_WY_SN_UY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PY_AN_WY_SN_UY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PY_AN_WY_SN_UY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PN_AY_WY_SN_UY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PN_AY_WY_SN_UY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PN_AY_WY_SN_UY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PN_AY_WY_SN_UY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PN_AN_WY_SN_UY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PN_AN_WY_SN_UY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PN_AN_WY_SN_UY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PN_AN_WY_SN_UY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PN_AY_WN_SN_UY_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WN_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PN_AY_WN_SN_UY_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WN_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_PN_AN_WN_SN_UY_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WN_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_PN_AN_WN_SN_UY_SZ1 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WN_SN_UY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PY_AY_WY_SN_UN_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PY_AY_WY_SN_UN_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PY_AY_WY_SN_UN_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PY_AY_WY_SN_UN_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PY_AN_WY_SN_UN_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PY_AN_WY_SN_UN_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PY_AN_WY_SN_UN_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PY_AN_WY_SN_UN_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PN_AY_WY_SN_UN_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PN_AY_WY_SN_UN_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PN_AY_WY_SN_UN_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PN_AY_WY_SN_UN_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PN_AN_WY_SN_UN_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PN_AN_WY_SN_UN_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PN_AN_WY_SN_UN_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PN_AN_WY_SN_UN_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_PN_AN_WN_SN_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_PN_AN_WN_SN_UN_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PY_AY_WY_SN_UY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PY_AY_WY_SN_UY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PY_AY_WY_SN_UY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PY_AY_WY_SN_UY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PY_AN_WY_SN_UY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PY_AN_WY_SN_UY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PY_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PY_AN_WY_SN_UY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PY_AN_WY_SN_UY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PY_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PN_AY_WY_SN_UY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PN_AY_WY_SN_UY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PN_AY_WY_SN_UY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PN_AY_WY_SN_UY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PN_AN_WY_SN_UY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PN_AN_WY_SN_UY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PN_AN_WY_SN_UY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PN_AN_WY_SN_UY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PN_AY_WN_SN_UY_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AY_WN_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PN_AY_WN_SN_UY_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AY_WN_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_PN_AN_WN_SN_UY_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMM_PN_AN_WN_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_PN_AN_WN_SN_UY_SZ2 : public MemoryOffset<MemoryReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REG_PN_AN_WN_SN_UY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8Acc : public SrsOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8 : public SrsOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PY_AY_WN_SN_UN_SZ8 : public SrsOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PY_AY_WN_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8Acc : public SrsOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8 : public SrsOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PY_AN_WN_SN_UN_SZ8 : public SrsOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PY_AN_WN_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8Acc : public SrsOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8 : public SrsOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PN_AY_WN_SN_UN_SZ8 : public SrsOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PN_AY_WN_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8Acc : public SrsOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8 : public SrsOp
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_PN_AN_WN_SN_UN_SZ8 : public SrsOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        SRS_STORE_IMM_PN_AN_WN_SN_UN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PY_AY_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PY_AY_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PY_AY_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PY_AY_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PY_AN_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PY_AN_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PY_AN_WY_SN_UN_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PY_AN_WY_SN_UN_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PN_AY_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PN_AY_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PN_AY_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PN_AY_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PN_AN_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PN_AN_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PN_AN_WY_SN_UN_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PN_AN_WY_SN_UN_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_IMMD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STORE_REGD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strex".
     */
    class STREX_STORE_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryExImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STREX_STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strexh".
     */
    class STREXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryExImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STREXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strexb".
     */
    class STREXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryExImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STREXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "strexd".
     */
    class STREXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryExDImm>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STREXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "stl".
     */
    class STL_STORE_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STL_STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "stlh".
     */
    class STLH_STORE_IMM_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STLH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 1);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "stlb".
     */
    class STLB_STORE_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        STLB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 0);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "stlex".
     */
    class STLEX_STORE_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryExImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLEX_STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "stlexh".
     */
    class STLEXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2 : public MemoryOffset<MemoryExImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLEXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "stlexb".
     */
    class STLEXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1 : public MemoryOffset<MemoryExImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLEXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "stlexd".
     */
    class STLEXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryExDImm>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        STLEXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMM_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        VSTR_STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMM_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryImm>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        VSTR_STORE_IMM_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
                    if (dest != int_reg::Pc) {
                        fault->annotate(ArmISA::ArmFault::SAS, 2);
                        fault->annotate(ArmISA::ArmFault::SSE, false);
                        fault->annotate(ArmISA::ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMMD_PN_AY_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        VSTR_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMMD_PN_AN_WN_SN_UN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        VSTR_STORE_IMMD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroLdrUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        MicroLdrUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroLdrRetUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[15]; RegId destRegIdxArr[6];

      public:
        MicroLdrRetUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroLdrFpUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        MicroLdrFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroLdrDBFpUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        MicroLdrDBFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroLdrDTFpUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        MicroLdrDTFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroStrUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      public:
        MicroStrUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroStrFpUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        MicroStrFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroStrDBFpUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        MicroStrDBFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroStrDTFpUop : public MicroMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        MicroStrDTFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroLdr2Uop : public MicroMemPairOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        MicroLdr2Uop(ExtMachInst machInst,
                       RegIndex _dreg1, RegIndex _dreg2, RegIndex _base,
                       bool _up, uint8_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroLdrNeon1Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        MicroLdrNeon1Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("ldrneon1_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroStrNeon1Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        MicroStrNeon1Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("strneon1_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroLdrNeon2Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        MicroLdrNeon2Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("ldrneon2_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroStrNeon2Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        MicroStrNeon2Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("strneon2_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroLdrNeon3Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        MicroLdrNeon3Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("ldrneon3_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroStrNeon3Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        MicroStrNeon3Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("strneon3_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroLdrNeon4Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

      public:
        MicroLdrNeon4Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("ldrneon4_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroStrNeon4Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[0];

      public:
        MicroStrNeon4Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("strneon4_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroLdrNeon6Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[2];

      public:
        MicroLdrNeon6Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("ldrneon6_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroStrNeon6Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[0];

      public:
        MicroStrNeon6Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("strneon6_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroLdrNeon8Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[2];

      public:
        MicroLdrNeon8Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("ldrneon8_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroStrNeon8Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[0];

      public:
        MicroStrNeon8Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("strneon8_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroLdrNeon12Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[3];

      public:
        MicroLdrNeon12Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("ldrneon12_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroStrNeon12Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[0];

      public:
        MicroStrNeon12Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("strneon12_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroLdrNeon16Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[12]; RegId destRegIdxArr[4];

      public:
        MicroLdrNeon16Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("ldrneon16_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroStrNeon16Uop : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[12]; RegId destRegIdxArr[0];

      public:
        MicroStrNeon16Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags) :
            MicroNeonMemOp("strneon16_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroDeintNeon4Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[4];

      public:
        MicroDeintNeon4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon4uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroInterNeon4Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[4];

      public:
        MicroInterNeon4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon4uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroDeintNeon6Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[15]; RegId destRegIdxArr[6];

      public:
        MicroDeintNeon6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon6uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 4) / 4) * NumVecElemPerVecReg) + (op1 + 4) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 5) / 4) * NumVecElemPerVecReg) + (op1 + 5) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroInterNeon6Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[15]; RegId destRegIdxArr[6];

      public:
        MicroInterNeon6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon6uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 4) / 4) * NumVecElemPerVecReg) + (dest + 4) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 5) / 4) * NumVecElemPerVecReg) + (dest + 5) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroDeintNeon8Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[19]; RegId destRegIdxArr[8];

      public:
        MicroDeintNeon8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon8uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 4) / 4) * NumVecElemPerVecReg) + (op1 + 4) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 5) / 4) * NumVecElemPerVecReg) + (op1 + 5) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 6) / 4) * NumVecElemPerVecReg) + (op1 + 6) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 7) / 4) * NumVecElemPerVecReg) + (op1 + 7) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroInterNeon8Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[19]; RegId destRegIdxArr[8];

      public:
        MicroInterNeon8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon8uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 3 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 3 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 4) / 4) * NumVecElemPerVecReg) + (dest + 4) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 5) / 4) * NumVecElemPerVecReg) + (dest + 5) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 6) / 4) * NumVecElemPerVecReg) + (dest + 6) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 7) / 4) * NumVecElemPerVecReg) + (dest + 7) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackNeon2to2Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

      public:
        MicroUnpackNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to2uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackNeon2to4Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[13]; RegId destRegIdxArr[4];

      public:
        MicroUnpackNeon2to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to4uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackNeon2to6Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[17]; RegId destRegIdxArr[6];

      public:
        MicroUnpackNeon2to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to6uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackNeon2to8Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[21]; RegId destRegIdxArr[8];

      public:
        MicroUnpackNeon2to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to8uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackNeon4to4Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

      public:
        MicroUnpackNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to4uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackNeon4to6Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[19]; RegId destRegIdxArr[6];

      public:
        MicroUnpackNeon4to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to6uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackNeon4to8Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[23]; RegId destRegIdxArr[8];

      public:
        MicroUnpackNeon4to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to8uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackAllNeon2to2Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        MicroUnpackAllNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to2uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackAllNeon2to4Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

      public:
        MicroUnpackAllNeon2to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to4uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackAllNeon2to6Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[6];

      public:
        MicroUnpackAllNeon2to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to6uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackAllNeon2to8Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[13]; RegId destRegIdxArr[8];

      public:
        MicroUnpackAllNeon2to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to8uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackAllNeon4to4Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[4];

      public:
        MicroUnpackAllNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to4uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackAllNeon4to6Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[13]; RegId destRegIdxArr[6];

      public:
        MicroUnpackAllNeon4to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to6uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroUnpackAllNeon4to8Uop : public MicroNeonMixOp
    {
      private:
        RegId srcRegIdxArr[15]; RegId destRegIdxArr[8];

      public:
        MicroUnpackAllNeon4to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to8uop", machInst, IntAluOp,
                           _dest, _op1, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 0 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 2 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (dest + step * 3 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroPackNeon2to2Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        MicroPackNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon2to2uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroPackNeon4to2Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

      public:
        MicroPackNeon4to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon4to2uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroPackNeon6to2Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

      public:
        MicroPackNeon6to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon6to2uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroPackNeon8to2Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

      public:
        MicroPackNeon8to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon8to2uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 3 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 3 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroPackNeon4to4Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[4];

      public:
        MicroPackNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon4to4uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroPackNeon6to4Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[13]; RegId destRegIdxArr[4];

      public:
        MicroPackNeon6to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon6to4uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    template <class Element>
    class MicroPackNeon8to4Uop : public MicroNeonMixLaneOp
    {
      private:
        RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

      public:
        MicroPackNeon8to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon8to4uop", machInst, IntAluOp,
                           _dest, _op1, _step, _lane)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 0 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 0 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 2 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 3 + 0) / 4) * NumVecElemPerVecReg) + (op1 + step * 3 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + step * 3 + 1) / 4) * NumVecElemPerVecReg) + (op1 + step * 3 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroAddiUop : public MicroIntImmOp
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        MicroAddiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroAddXiUop : public MicroIntImmXOp
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        MicroAddXiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroAddXiSpAlignUop : public MicroIntImmXOp
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        MicroAddXiSpAlignUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroSubiUop : public MicroIntImmOp
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        MicroSubiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroSubXiUop : public MicroIntImmXOp
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        MicroSubXiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroAddUop : public MicroIntRegOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        MicroAddUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, RegIndex _urc,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroSubUop : public MicroIntRegOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        MicroSubUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, RegIndex _urc,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroAddXERegUop : public MicroIntRegXOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        MicroAddXERegUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, RegIndex _urc,
                       ArmExtendType _type, uint32_t _shiftAmt);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroUopRegMov : public MicroIntMov
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        MicroUopRegMov(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroUopRegMovRet : public MicroIntMov
    {
      private:
        RegId srcRegIdxArr[15]; RegId destRegIdxArr[6];

      public:
        MicroUopRegMovRet(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroUopSetPCCPSR : public MicroSetPCCPSR
    {
      private:
        RegId srcRegIdxArr[14]; RegId destRegIdxArr[5];

      public:
        MicroUopSetPCCPSR(ExtMachInst machInst,
                       RegIndex _ura,
                       RegIndex _urb,
                       RegIndex _urc);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

/**
 * Static instructions class for a store multiple instruction
 */
class LdmStm : public MacroMemOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    LdmStm(ExtMachInst machInst, RegIndex rn, bool index, bool up,
            bool user, bool writeback, bool load, uint32_t reglist);
};

class LdpStp : public PairMemOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    LdpStp(const char *mnemonic, ExtMachInst machInst,
            uint32_t size, bool fp, bool load, bool noAlloc, bool signExt,
            bool exclusive, bool acrel, uint32_t imm,
            AddrMode mode, RegIndex rn, RegIndex rt,
            RegIndex rt2);
};

class BigFpMemImm : public BigFpMemImmOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    BigFpMemImm(const char *mnemonic, ExtMachInst machInst,
                   bool load, RegIndex dest, RegIndex base, int64_t imm);
};

class BigFpMemPre : public BigFpMemPreOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    BigFpMemPre(const char *mnemonic, ExtMachInst machInst,
                   bool load, RegIndex dest, RegIndex base, int64_t imm);
};

class BigFpMemPost : public BigFpMemPostOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    BigFpMemPost(const char *mnemonic, ExtMachInst machInst,
                   bool load, RegIndex dest, RegIndex base, int64_t imm);
};

class BigFpMemReg : public BigFpMemRegOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    BigFpMemReg(const char *mnemonic, ExtMachInst machInst,
                   bool load, RegIndex dest, RegIndex base,
                   RegIndex offset, ArmExtendType type, int64_t imm);
};

class BigFpMemLit : public BigFpMemLitOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    BigFpMemLit(const char *mnemonic, ExtMachInst machInst,
                   RegIndex dest, int64_t imm);
};

class VldMult : public VldMultOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    VldMult(ExtMachInst machInst, unsigned width,
            RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
            uint32_t size, uint32_t align, RegIndex rm);
};

class VldSingle : public VldSingleOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    VldSingle(ExtMachInst machInst, bool all, unsigned width,
            RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
            uint32_t size, uint32_t align, RegIndex rm, unsigned lane=0);
};

class VstMult : public VstMultOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    VstMult(ExtMachInst machInst, unsigned width,
            RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
            uint32_t size, uint32_t align, RegIndex rm);
};

class VstSingle : public VstSingleOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    VstSingle(ExtMachInst machInst, bool all, unsigned width,
            RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
            uint32_t size, uint32_t align, RegIndex rm, unsigned lane=0);
};

/**
 * Static instructions class for a store multiple instruction
 */
class VLdmStm : public MacroVFPMemOp
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    VLdmStm(ExtMachInst machInst, RegIndex rn,
            RegIndex vd, bool single, bool up, bool writeback,
            bool load, uint32_t offset);
};

class AndImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AndImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    AndImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AndReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    AndRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AndRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

  public:
    // Constructor
    AndRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    AndsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    AndsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    EorImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    EorImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    EorReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    EorRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    EorRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

  public:
    // Constructor
    EorRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    EorsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    EorsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SubImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SubImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SubReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SubRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SubRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SubRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    SubsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    SubsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RsbImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    RsbImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RsbImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    // Constructor
    RsbImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RsbReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    RsbReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RsbRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    // Constructor
    RsbRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RsbRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    RsbRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RsbRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[4];

  public:
    // Constructor
    RsbRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RsbsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    RsbsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RsbsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    RsbsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AddImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AddImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AddReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AddRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AddRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AddRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    AddsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    AddsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdrImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AdrImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdrImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

  public:
    // Constructor
    AdrImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AdcImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AdcImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AdcReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AdcRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AdcRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AdcRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    AdcsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    AdcsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SbcImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SbcImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SbcReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SbcRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SbcRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SbcRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    SbcsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    SbcsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RscImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    RscImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RscImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    // Constructor
    RscImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RscReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    RscReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RscRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    // Constructor
    RscRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RscRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    RscRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RscRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[4];

  public:
    // Constructor
    RscRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RscsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    RscsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class RscsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    RscsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TstImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

  public:
    // Constructor
    TstImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TstImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    TstImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TstReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

  public:
    // Constructor
    TstReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TstRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    TstRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TstRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

  public:
    // Constructor
    TstRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TstRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    TstRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TstsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[6];

  public:
    // Constructor
    TstsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TstsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[6];

  public:
    // Constructor
    TstsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TeqImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

  public:
    // Constructor
    TeqImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TeqImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    TeqImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TeqReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

  public:
    // Constructor
    TeqReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TeqRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    TeqRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TeqRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

  public:
    // Constructor
    TeqRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TeqRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    TeqRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TeqsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[6];

  public:
    // Constructor
    TeqsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class TeqsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[6];

  public:
    // Constructor
    TeqsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmpImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

  public:
    // Constructor
    CmpImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmpImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CmpImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmpReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

  public:
    // Constructor
    CmpReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmpRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CmpRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmpRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

  public:
    // Constructor
    CmpRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmpRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CmpRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmpsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[6];

  public:
    // Constructor
    CmpsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmpsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[6];

  public:
    // Constructor
    CmpsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmnImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

  public:
    // Constructor
    CmnImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmnImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CmnImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmnReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

  public:
    // Constructor
    CmnReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmnRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CmnRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmnRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

  public:
    // Constructor
    CmnRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmnRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CmnRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmnsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[6];

  public:
    // Constructor
    CmnsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CmnsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[6];

  public:
    // Constructor
    CmnsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrrImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    OrrImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrrReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    OrrRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrrRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

  public:
    // Constructor
    OrrRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    OrrsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    OrrsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrnImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    OrnImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrnReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    OrnRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrnRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

  public:
    // Constructor
    OrnRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    OrnsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    OrnsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MovImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MovImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MovReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MovRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MovRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MovRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[7];

  public:
    // Constructor
    MovsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    MovsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    BicImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    BicImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    BicReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    BicRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    BicRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

  public:
    // Constructor
    BicRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    BicsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    BicsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MvnImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MvnImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MvnImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MvnImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MvnReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MvnReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MvnRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MvnRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MvnRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MvnRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MvnRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MvnRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MvnsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[7];

  public:
    // Constructor
    MvnsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MvnsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    MvnsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovtImm : public DataImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MovtImm(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovtImmCc : public DataImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MovtImmCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovtReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MovtReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovtRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MovtRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovtRegReg : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MovtRegReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovtRegRegCc : public DataRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MovtRegRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _shift,
            ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovtsImmPclr : public DataImmOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[7];

  public:
    // Constructor
    MovtsImmPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, uint32_t _imm, bool _rotC=true);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MovtsRegPclr : public DataRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[7];

  public:
    // Constructor
    MovtsRegPclr(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class QaddRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    QaddRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Qadd16Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Qadd16Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Qadd8Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Qadd8Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class QdaddRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    QdaddRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class QsubReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    QsubReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class QsubRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    QsubRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Qsub16Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Qsub16Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Qsub8Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Qsub8Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class QdsubRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    QdsubRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class QasxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    QasxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class QsaxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    QsaxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sadd8RegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Sadd8RegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sadd16RegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Sadd16RegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Ssub8RegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Ssub8RegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Ssub16RegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Ssub16RegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SasxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SasxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SasxRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SasxRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SsaxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SsaxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SsaxRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SsaxRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Shadd8Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Shadd8Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Shadd16Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Shadd16Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Shsub8Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Shsub8Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Shsub16Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Shsub16Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class ShasxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    ShasxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class ShasxRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    ShasxRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class ShsaxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    ShsaxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class ShsaxRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    ShsaxRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uqadd16Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uqadd16Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uqadd8Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uqadd8Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uqsub16Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uqsub16Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uqsub8Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uqsub8Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class UqasxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    UqasxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class UqsaxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    UqsaxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uadd16RegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Uadd16RegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uadd8RegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Uadd8RegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Usub16RegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Usub16RegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Usub8RegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Usub8RegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class UasxRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    UasxRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class UsaxRegCc : public DataRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    UsaxRegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uhadd16Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uhadd16Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uhadd8Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uhadd8Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uhsub16Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uhsub16Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Uhsub8Reg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Uhsub8Reg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class UhasxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    UhasxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class UhsaxReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    UhsaxReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class PkhbtReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    PkhbtReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class PkhtbReg : public DataRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    PkhtbReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdrXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AdrXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdrpXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AdrpXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AndXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndXImmCc : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AndXImmCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AndXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndXSRegCc : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AndXSRegCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndXEReg : public DataXERegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AndXEReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            ArmExtendType _extendType, int32_t _shiftAmt);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AndXERegCc : public DataXERegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AndXERegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            ArmExtendType _extendType, int32_t _shiftAmt);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    EorXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    EorXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EorXEReg : public DataXERegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    EorXEReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            ArmExtendType _extendType, int32_t _shiftAmt);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class EonXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    EonXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SubXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubXImmCc : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SubXImmCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SubXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubXSRegCc : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SubXSRegCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubXEReg : public DataXERegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SubXEReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            ArmExtendType _extendType, int32_t _shiftAmt);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SubXERegCc : public DataXERegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SubXERegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            ArmExtendType _extendType, int32_t _shiftAmt);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AddXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddXImmCc : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AddXImmCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AddXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddXSRegCc : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AddXSRegCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddXEReg : public DataXERegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AddXEReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            ArmExtendType _extendType, int32_t _shiftAmt);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddXERegCc : public DataXERegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AddXERegCc(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            ArmExtendType _extendType, int32_t _shiftAmt);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AdcXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AdcXSRegCc : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AdcXSRegCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SbcXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SbcXSRegCc : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SbcXSRegCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrrXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrrXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrrXEReg : public DataXERegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrrXEReg(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2,
            ArmExtendType _extendType, int32_t _shiftAmt);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class OrnXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    OrnXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicXSReg : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    BicXSReg(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BicXSRegCc : public DataXSRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

  public:
    // Constructor
    BicXSRegCc(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   int32_t _shiftAmt, ArmShiftType _shiftType);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Madd64 : public DataX3RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Madd64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _op3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Msub64 : public DataX3RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Msub64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _op3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smaddl64 : public DataX3RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smaddl64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _op3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smsubl64 : public DataX3RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smsubl64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _op3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smulh64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smulh64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Umaddl64 : public DataX3RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Umaddl64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _op3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Umsubl64 : public DataX3RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Umsubl64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _op3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Umulh64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Umulh64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Asrv64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Asrv64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Lslv64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Lslv64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Lsrv64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Lsrv64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Rorv64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Rorv64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32b64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32b64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32h64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32h64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32w64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32w64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32x64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32x64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32cb64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32cb64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32ch64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32ch64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32cw64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32cw64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Crc32cx64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Crc32cx64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sdiv64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sdiv64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Udiv64 : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Udiv64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Cls64 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Cls64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Clz64 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Clz64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Rbit64 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Rbit64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Rev64 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Rev64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Rev1664 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Rev1664(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Rev3264 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Rev3264(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mrs64 : public RegMiscRegImmOp64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mrs64(ExtMachInst machInst, RegIndex _dest,
            MiscRegIndex _op1);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MrsNZCV64 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MrsNZCV64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Msr64 : public MiscRegRegImmOp64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Msr64(ExtMachInst machInst, MiscRegIndex _dest,
            RegIndex _op1);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Tlbi64LocalHub : public TlbiOp64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Tlbi64LocalHub(ExtMachInst machInst, MiscRegIndex _dest,
            RegIndex _op1);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Tlbi64ShareableHub : public TlbiOp64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];
    const bool dvmEnabled;

  public:
    // Constructor
    Tlbi64ShareableHub(ExtMachInst machInst, MiscRegIndex _dest,
            RegIndex _op1, bool dvm_enabled);

    Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
    Fault completeAcc(PacketPtr, ExecContext *,
                      trace::InstRecord *) const override;
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MsrNZCV64 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

  public:
    // Constructor
    MsrNZCV64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    class Dczva : public SysDC64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Dczva(ExtMachInst machInst, RegIndex _base,
                       MiscRegIndex _dest);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            ;
        }
    };

    class Dccvau : public SysDC64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Dccvau(ExtMachInst machInst, RegIndex _base,
                       MiscRegIndex _dest);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        fault->annotate(ArmISA::ArmFault::CM, 1);
        fault->annotate(ArmISA::ArmFault::OFA, faultAddr);
    
        }
    };

    class Dccvac : public SysDC64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Dccvac(ExtMachInst machInst, RegIndex _base,
                       MiscRegIndex _dest);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        fault->annotate(ArmISA::ArmFault::CM, 1);
        fault->annotate(ArmISA::ArmFault::OFA, faultAddr);
    
        }
    };

    class Dccivac : public SysDC64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Dccivac(ExtMachInst machInst, RegIndex _base,
                       MiscRegIndex _dest);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        fault->annotate(ArmISA::ArmFault::CM, 1);
        fault->annotate(ArmISA::ArmFault::OFA, faultAddr);
    
        }
    };

    class Dcivac : public SysDC64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Dcivac(ExtMachInst machInst, RegIndex _base,
                       MiscRegIndex _dest);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        fault->annotate(ArmISA::ArmFault::CM, 1);
        fault->annotate(ArmISA::ArmFault::OFA, faultAddr);
    
        }
    };

class MsrImm64 : public MiscRegImmOp64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MsrImm64(ExtMachInst machInst, MiscRegIndex _dest, uint64_t _imm);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MsrImmDAIFSet64 : public MiscRegImmOp64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MsrImmDAIFSet64(ExtMachInst machInst, MiscRegIndex _dest, uint64_t _imm);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MsrImmDAIFClr64 : public MiscRegImmOp64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    MsrImmDAIFClr64(ExtMachInst machInst, MiscRegIndex _dest, uint64_t _imm);

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CcmnImm64 : public DataXCondCompImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CcmnImm64(ExtMachInst machInst, RegIndex _op1,
                   uint64_t _imm, ConditionCode _condCode, uint8_t _defCc);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CcmpImm64 : public DataXCondCompImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CcmpImm64(ExtMachInst machInst, RegIndex _op1,
                   uint64_t _imm, ConditionCode _condCode, uint8_t _defCc);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CcmnReg64 : public DataXCondCompRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CcmnReg64(ExtMachInst machInst, RegIndex _op1,
                   RegIndex _op2, ConditionCode _condCode, uint8_t _defCc);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class CcmpReg64 : public DataXCondCompRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    CcmpReg64(ExtMachInst machInst, RegIndex _op1,
                   RegIndex _op2, ConditionCode _condCode, uint8_t _defCc);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Csel64 : public DataXCondSelOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Csel64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Csinc64 : public DataXCondSelOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Csinc64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Csinv64 : public DataXCondSelOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Csinv64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Csneg64 : public DataXCondSelOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Csneg64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class B : public BranchImmCond
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

  public:
    // Constructor
    B(ExtMachInst machInst, int32_t _imm,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
    std::unique_ptr<PCStateBase> branchTarget(
            const PCStateBase &branch_pc) const override;

    /// Explicitly import the otherwise hidden branchTarget
    using StaticInst::branchTarget;
};

class Bl : public BranchImmCond
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Bl(ExtMachInst machInst, int32_t _imm,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
    std::unique_ptr<PCStateBase> branchTarget(
            const PCStateBase &branch_pc) const override;

    /// Explicitly import the otherwise hidden branchTarget
    using StaticInst::branchTarget;
};

class BlxImm : public BranchImmCond
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    BlxImm(ExtMachInst machInst, int32_t _imm,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
    std::unique_ptr<PCStateBase> branchTarget(
            const PCStateBase &branch_pc) const override;

    /// Explicitly import the otherwise hidden branchTarget
    using StaticInst::branchTarget;
};

class BlxReg : public BranchRegCond
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    BlxReg(ExtMachInst machInst, RegIndex _op1,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BxReg : public BranchRegCond
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

  public:
    // Constructor
    BxReg(ExtMachInst machInst, RegIndex _op1,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BxjReg : public BranchRegCond
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

  public:
    // Constructor
    BxjReg(ExtMachInst machInst, RegIndex _op1,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Cbz : public BranchImmReg
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Cbz(ExtMachInst machInst, int32_t imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
    std::unique_ptr<PCStateBase> branchTarget(
            const PCStateBase &branch_pc) const override;

    /// Explicitly import the otherwise hidden branchTarget
    using StaticInst::branchTarget;
};

class Cbnz : public BranchImmReg
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Cbnz(ExtMachInst machInst, int32_t imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
    std::unique_ptr<PCStateBase> branchTarget(
            const PCStateBase &branch_pc) const override;

    /// Explicitly import the otherwise hidden branchTarget
    using StaticInst::branchTarget;
};

class Tbb : public BranchRegReg
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Tbb(ExtMachInst machInst, RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
    Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
    Fault completeAcc(PacketPtr, ExecContext *,
                      trace::InstRecord *) const override;
};

class Tbh : public BranchRegReg
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Tbh(ExtMachInst machInst, RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
    Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
    Fault completeAcc(PacketPtr, ExecContext *,
                      trace::InstRecord *) const override;
};

class B64 : public BranchImm64
{
  private:
    RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

  public:
    // Constructor
    B64(ExtMachInst machInst, int64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Bl64 : public BranchImm64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Bl64(ExtMachInst machInst, int64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Br64 : public BranchReg64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Br64(ExtMachInst machInst, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Blr64 : public BranchReg64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Blr64(ExtMachInst machInst, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Braa : public BranchRegReg64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Braa(ExtMachInst machInst, RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Blraa : public BranchRegReg64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Blraa(ExtMachInst machInst, RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Braaz : public BranchReg64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Braaz(ExtMachInst machInst, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Blraaz : public BranchReg64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Blraaz(ExtMachInst machInst, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Brab : public BranchRegReg64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Brab(ExtMachInst machInst, RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Blrab : public BranchRegReg64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Blrab(ExtMachInst machInst, RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Brabz : public BranchReg64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Brabz(ExtMachInst machInst, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Blrabz : public BranchReg64
{
  private:
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Blrabz(ExtMachInst machInst, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class BCond64 : public BranchImmCond64
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

  public:
    // Constructor
    BCond64(ExtMachInst machInst, int64_t _imm,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Ret64 : public BranchRet64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Ret64(ExtMachInst machInst, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "retaa".
     */
    class Retaa : public BranchRetA64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Retaa(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "retab".
     */
    class Retab : public BranchRetA64
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        /// Constructor.
        Retab(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "eret".
     */
    class Eret64 : public BranchEret64
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        /// Constructor.
        Eret64(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "eretaa".
     */
    class Eretaa : public BranchEretA64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        /// Constructor.
        Eretaa(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "eretab".
     */
    class Eretab : public BranchEretA64
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        /// Constructor.
        Eretab(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class Cbz64 : public BranchImmReg64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Cbz64(ExtMachInst machInst, int64_t imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Cbnz64 : public BranchImmReg64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Cbnz64(ExtMachInst machInst, int64_t imm, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Tbz64 : public BranchImmImmReg64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Tbz64(ExtMachInst machInst, int64_t _imm1, int64_t _imm2,
                   RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Tbnz64 : public BranchImmImmReg64
{
  private:
    RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

  public:
    // Constructor
    Tbnz64(ExtMachInst machInst, int64_t _imm1, int64_t _imm2,
                   RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mla : public Mult4
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mla(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MlaCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    MlaCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mls : public Mult4
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mls(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Mul : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Mul(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class MulCc : public Mult3
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    MulCc(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlabbCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmlabbCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlabtCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmlabtCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlatbCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmlatbCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlattCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmlattCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmladCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmladCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmladxCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmladxCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlal : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlal(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlalCc : public Mult4
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[3];

  public:
    // Constructor
    SmlalCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlalbb : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlalbb(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlalbt : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlalbt(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlaltb : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlaltb(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlaltt : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlaltt(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlald : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlald(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlaldx : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlaldx(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlawbCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmlawbCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlawtCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmlawtCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlsdCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmlsdCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmlsdxCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmlsdxCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlsld : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlsld(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smlsldx : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smlsldx(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smmla : public Mult4
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smmla(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smmlar : public Mult4
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smmlar(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smmls : public Mult4
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smmls(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smmlsr : public Mult4
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smmlsr(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smmul : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smmul(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smmulr : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smmulr(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmuadCc : public Mult3
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmuadCc(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmuadxCc : public Mult3
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    SmuadxCc(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smulbb : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smulbb(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smulbt : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smulbt(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smultb : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smultb(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smultt : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smultt(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smull : public Mult4
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Smull(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SmullCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    SmullCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smulwb : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smulwb(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smulwt : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smulwt(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smusd : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smusd(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Smusdx : public Mult3
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Smusdx(ExtMachInst machInst, RegIndex _reg0,
                   RegIndex _reg1, RegIndex _reg2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Umaal : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Umaal(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Umlal : public Mult4
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Umlal(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class UmlalCc : public Mult4
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[3];

  public:
    // Constructor
    UmlalCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Umull : public Mult4
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Umull(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class UmullCc : public Mult4
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    UmullCc(ExtMachInst machInst,
                   RegIndex _reg0, RegIndex _reg1,
                   RegIndex _reg2, RegIndex _reg3);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Sdiv : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Sdiv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Udiv : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Udiv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};


template <class Micro>
class VfpMacroRegRegOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegOp(ExtMachInst _machInst, RegIndex _dest,
                     RegIndex _op1, bool _wide) :
        VfpMacroOp("VfpMacroRegRegOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        assert(numMicroops > 1);
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, mode);
            nextIdxs(_dest, _op1);
        }
    }
};

template <class VfpOp>
StaticInstPtr
decodeVfpRegRegOp(ExtMachInst machInst,
        RegIndex dest, RegIndex op1, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1);
    } else {
        return new VfpMacroRegRegOp<VfpOp>(machInst, dest, op1, wide);
    }
}

template <class Micro>
class VfpMacroRegImmOp : public VfpMacroOp
{
  public:
    VfpMacroRegImmOp(ExtMachInst _machInst, RegIndex _dest, uint64_t _imm,
                     bool _wide) :
        VfpMacroOp("VfpMacroRegImmOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _imm, mode);
            nextIdxs(_dest);
        }
    }
};

template <class VfpOp>
StaticInstPtr
decodeVfpRegImmOp(ExtMachInst machInst,
        RegIndex dest, uint64_t imm, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, imm);
    } else {
        return new VfpMacroRegImmOp<VfpOp>(machInst, dest, imm, wide);
    }
}

template <class Micro>
class VfpMacroRegRegImmOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegImmOp(ExtMachInst _machInst, RegIndex _dest,
                        RegIndex _op1, uint64_t _imm, bool _wide) :
        VfpMacroOp("VfpMacroRegRegImmOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, _imm, mode);
            nextIdxs(_dest, _op1);
        }
    }
};

template <class VfpOp>
StaticInstPtr
decodeVfpRegRegImmOp(ExtMachInst machInst, RegIndex dest,
                     RegIndex op1, uint64_t imm, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1, imm);
    } else {
        return new VfpMacroRegRegImmOp<VfpOp>(machInst, dest, op1, imm, wide);
    }
}

template <class Micro>
class VfpMacroRegRegRegOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegRegOp(ExtMachInst _machInst, RegIndex _dest,
                        RegIndex _op1, RegIndex _op2, bool _wide) :
        VfpMacroOp("VfpMacroRegRegRegOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, _op2, mode);
            nextIdxs(_dest, _op1, _op2);
        }
    }
};

template <class VfpOp>
StaticInstPtr
decodeVfpRegRegRegOp(ExtMachInst machInst, RegIndex dest,
                     RegIndex op1, RegIndex op2, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1, op2);
    } else {
        return new VfpMacroRegRegRegOp<VfpOp>(machInst, dest, op1, op2, wide);
    }
}

class Vmsr : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Vmsr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmsrFpscr : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VmsrFpscr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Vmrs : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Vmrs(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmrsFpscr : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmrsFpscr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    /**
     * Static instruction class for "vmrs".
     */
    class VmrsApsrFpscr : public PredOp
    {
      private:
        RegId srcRegIdxArr[11]; RegId destRegIdxArr[3];

      public:
        /// Constructor.
        VmrsApsrFpscr(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class VmovImmS : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovImmS(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovImmD : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VmovImmD(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovImmQ : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[4];

  public:
    // Constructor
    VmovImmQ(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovRegS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovRegS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovRegD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VmovRegD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovRegQ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  public:
    // Constructor
    VmovRegQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovCoreRegB : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovCoreRegB(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovCoreRegH : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovCoreRegH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovCoreRegW : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovCoreRegW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovRegCoreUB : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovRegCoreUB(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovRegCoreUH : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovRegCoreUH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovRegCoreSB : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovRegCoreSB(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovRegCoreSH : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovRegCoreSH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmovRegCoreW : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VmovRegCoreW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Vmov2Reg2Core : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Vmov2Reg2Core(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Vmov2Core2Reg : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  public:
    // Constructor
    Vmov2Core2Reg(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VfmaS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VfmaS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VfmaD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VfmaD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VfmsS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VfmsS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VfmsD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VfmsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VfnmaS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VfnmaS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VfnmaD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VfnmaD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VfnmsS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VfnmsS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VfnmsD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VfnmsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VaddS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VaddS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VaddD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VaddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VsubS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VsubS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VsubD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VsubD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VdivS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VdivS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VdivD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VdivD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmulS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VmulS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmulD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VmulD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VminnmS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VminnmS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VminnmD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VminnmD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmaxnmS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VmaxnmS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmaxnmD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VmaxnmD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VsqrtS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VsqrtS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VsqrtD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VsqrtD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VnegS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VnegS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VnegD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VnegD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VabsS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VabsS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VabsD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VabsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VRIntPS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VRIntPS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VRIntPD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VRIntPD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VRIntMS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VRIntMS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VRIntMD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VRIntMD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VRIntAS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VRIntAS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VRIntAD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VRIntAD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VRIntNS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VRIntNS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VRIntND : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VRIntND(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmlaS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VmlaS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmlaD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VmlaD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmlsS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VmlsS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VmlsD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VmlsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VnmlaS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VnmlaS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VnmlaD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VnmlaD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VnmlsS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VnmlsS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VnmlsD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VnmlsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VnmulS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VnmulS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VnmulD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VnmulD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtUIntFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtUIntFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtUIntFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtUIntFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtSIntFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtSIntFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtSIntFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtSIntFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VjcvtSFixedFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VjcvtSFixedFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpUIntSR : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpUIntSR(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpUIntDR : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpUIntDR(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSIntSR : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpSIntSR(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSIntDR : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpSIntDR(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpUIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpUIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtaFpUIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtaFpUIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtmFpUIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtmFpUIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtnFpUIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtnFpUIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtpFpUIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtpFpUIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpUIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpUIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtaFpUIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtaFpUIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtmFpUIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtmFpUIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtnFpUIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtnFpUIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtpFpUIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtpFpUIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpSIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtaFpSIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtaFpSIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtmFpSIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtmFpSIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtnFpSIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtnFpSIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtpFpSIntS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtpFpSIntS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpSIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtaFpSIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtaFpSIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtmFpSIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtmFpSIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtnFpSIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtnFpSIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtpFpSIntD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtpFpSIntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtFpSFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpDFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpDFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpHTFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpHTFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpHBFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpHBFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSFpHT : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpSFpHT(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSFpHB : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpSFpHB(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcmpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcmpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcmpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[14]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcmpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcmpZeroS : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcmpZeroS(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcmpZeroD : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcmpZeroD(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcmpeS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcmpeS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcmpeD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[14]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcmpeD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcmpeZeroS : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcmpeZeroS(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcmpeZeroD : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcmpeZeroD(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VselS : public FpRegRegRegCondOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[1];

  public:
    // Constructor
    VselS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                  ConditionCode _cond,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VselD : public FpRegRegRegCondOp
{
  private:
    RegId srcRegIdxArr[16]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VselD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                  ConditionCode _cond,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSFixedS : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpSFixedS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSFixedD : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtFpSFixedD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpUFixedS : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpUFixedS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpUFixedD : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtFpUFixedD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtSFixedFpS : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtSFixedFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtSFixedFpD : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtSFixedFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtUFixedFpS : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtUFixedFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtUFixedFpD : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtUFixedFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSHFixedS : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpSHFixedS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpSHFixedD : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtFpSHFixedD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpUHFixedS : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtFpUHFixedS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtFpUHFixedD : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtFpUHFixedD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtSHFixedFpS : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtSHFixedFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtSHFixedFpD : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtSHFixedFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtUHFixedFpS : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[2];

  public:
    // Constructor
    VcvtUHFixedFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class VcvtUHFixedFpD : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  public:
    // Constructor
    VcvtUHFixedFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovImmS : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovImmS(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovImmD : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovImmD(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovRegS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovRegS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovRegD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovRegD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovCoreRegW : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovCoreRegW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovCoreRegX : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovCoreRegX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovUCoreRegX : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovUCoreRegX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovRegCoreW : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovRegCoreW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovRegCoreX : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovRegCoreX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FmovURegCoreX : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FmovURegCoreX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMAddD : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMAddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMAddS : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMAddS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMAddH : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMAddH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMSubD : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMSubD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMSubS : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMSubS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMSubH : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMSubH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMAddD : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMAddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMAddS : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMAddS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMAddH : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMAddH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMSubD : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMSubD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMSubS : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMSubS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMSubH : public FpRegRegRegRegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMSubH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _op3, VfpMicroMode mode=VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FAddH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FAddH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FAddS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FAddS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FAddD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FAddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FSubH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FSubH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FSubS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FSubS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FSubD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FSubD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FDivH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FDivH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FDivS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FDivS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FDivD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FDivD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMulH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMulH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMulS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMulS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMulD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMulD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMulH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMulH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMulS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMulS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNMulD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNMulD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMinH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMinH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMinS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMinS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMinD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMinD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMaxH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMaxH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMaxS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMaxS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMaxD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMaxD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMinNMH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMinNMH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMinNMS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMinNMS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMinNMD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMinNMD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMaxNMH : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMaxNMH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMaxNMS : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMaxNMS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FMaxNMD : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FMaxNMD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FSqrtH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FSqrtH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FSqrtS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FSqrtS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FSqrtD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FSqrtD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNegH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNegH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNegS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNegS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FNegD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FNegD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FAbsH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FAbsH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FAbsS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FAbsS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FAbsD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FAbsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntNH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntNH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntNS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntNS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntND : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntND(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntPH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntPH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntPS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntPS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntPD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntPD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntMH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntMH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntMS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntMS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntMD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntMD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntZH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntZH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntZS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntZS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntZD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntZD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntAH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntAH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntAS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntAS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntAD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntAD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntIH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntIH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntIS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntIS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntID : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntID(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntXH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntXH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntXS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntXS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FRIntXD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FRIntXD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtWUIntFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtWUIntFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtWSIntFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtWSIntFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtWUIntFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtWUIntFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtWSIntFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtWSIntFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtXUIntFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtXUIntFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtXSIntFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtXSIntFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtXUIntFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtXUIntFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtXSIntFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtXSIntFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXDN : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXDN(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXDP : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXDP(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXDM : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXDM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXDZ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXDZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXDA : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXDA(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWDN : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWDN(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWDP : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWDP(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWDM : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWDM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWDZ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWDZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWDA : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWDA(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXDN : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXDN(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXDP : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXDP(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXDM : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXDM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXDZ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXDZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXDA : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXDA(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWDN : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWDN(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWDP : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWDP(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWDM : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWDM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWDZ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWDZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWDA : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWDA(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXSN : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXSN(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXSP : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXSP(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXSM : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXSM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXSZ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXSZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntXSA : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntXSA(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWSN : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWSN(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWSP : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWSP(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWSM : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWSM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWSZ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWSZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSIntWSA : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSIntWSA(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXSN : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXSN(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXSP : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXSP(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXSM : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXSM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXSZ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXSZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntXSA : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntXSA(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWSN : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWSN(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWSP : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWSP(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWSM : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWSM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWSZ : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWSZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUIntWSA : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUIntWSA(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCvtFpSFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FCvtFpSFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpDFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpDFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpHFpD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpHFpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpHFpS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpHFpS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpDFpH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpDFpH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSFpH : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSFpH(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCmpImmD : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCmpImmD(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCmpRegD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCmpRegD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCmpImmS : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCmpImmS(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCmpRegS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCmpRegS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCmpEImmD : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCmpEImmD(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCmpERegD : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCmpERegD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCmpEImmS : public FpRegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCmpEImmS(ExtMachInst machInst, RegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCmpERegS : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCmpERegS(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCCmpRegD : public FpCondCompRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCCmpRegD(ExtMachInst machInst, RegIndex _op1,
                   RegIndex _op2, ConditionCode _condCode, uint8_t _defCc);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCCmpRegS : public FpCondCompRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCCmpRegS(ExtMachInst machInst, RegIndex _op1,
                   RegIndex _op2, ConditionCode _condCode, uint8_t _defCc);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCCmpERegD : public FpCondCompRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCCmpERegD(ExtMachInst machInst, RegIndex _op1,
                   RegIndex _op2, ConditionCode _condCode, uint8_t _defCc);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCCmpERegS : public FpCondCompRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FCCmpERegS(ExtMachInst machInst, RegIndex _op1,
                   RegIndex _op2, ConditionCode _condCode, uint8_t _defCc);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSFixedDX : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSFixedDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtSFixedFpDX : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtSFixedFpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUFixedDX : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUFixedDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtUFixedFpDX : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtUFixedFpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSFixedSX : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSFixedSX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtSFixedFpSX : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtSFixedFpSX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUFixedSX : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUFixedSX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtUFixedFpSX : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtUFixedFpSX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSFixedDW : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSFixedDW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtSFixedFpDW : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtSFixedFpDW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUFixedDW : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUFixedDW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtUFixedFpDW : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtUFixedFpDW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpSFixedSW : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpSFixedSW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtSFixedFpSW : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtSFixedFpSW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtFpUFixedSW : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtFpUFixedSW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FcvtUFixedFpSW : public FpRegRegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  public:
    // Constructor
    FcvtUFixedFpSW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FJcvtFpSFixedDW : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[5];

  public:
    // Constructor
    FJcvtFpSFixedDW(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCSelD : public FpCondSelOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FCSelD(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class FCSelS : public FpCondSelOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    FCSelS(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2,
                   ConditionCode _condCode);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacda : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacda(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacdza : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacdza(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacdb : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacdb(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacdzb : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacdzb(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacga : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacga(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacia : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacia(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacia1716 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacia1716(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Paciasp : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Paciasp(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Paciaz : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Paciaz(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Paciza : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Paciza(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacib : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacib(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacib1716 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacib1716(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacibsp : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacibsp(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacibz : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacibz(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Pacizb : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Pacizb(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autda : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autda(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autdza : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autdza(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autdb : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autdb(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autdzb : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autdzb(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autia : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autia(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autia1716 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autia1716(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autiasp : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autiasp(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autiaz : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autiaz(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autiza : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autiza(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autib : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autib(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autib1716 : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autib1716(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autibsp : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autibsp(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autibz : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autibz(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Autizb : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Autizb(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Xpacd : public RegOp
{
  private:
    bool data;
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Xpacd(ExtMachInst machInst, RegIndex _dest);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Xpaci : public RegOp
{
  private:
    bool data;
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Xpaci(ExtMachInst machInst, RegIndex _dest);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class Xpaclri : public RegOp
{
  private:
    bool data;
    RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

  public:
    // Constructor
    Xpaclri(ExtMachInst machInst, RegIndex _dest);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeUReg(unsigned size,
                         ExtMachInst machInst, RegIndex dest,
                         RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <class BaseS, class BaseD>
    StaticInstPtr
    decodeNeonSizeSingleDouble(unsigned size,
                         ExtMachInst machInst, RegIndex dest,
                         RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 2:
            return new BaseS(machInst, dest, op1, op2);
          case 3:
            return new BaseD(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeUReg(unsigned size,
                         ExtMachInst machInst, RegIndex dest,
                         RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUSThreeUReg(bool notSigned, unsigned size,
                          ExtMachInst machInst, RegIndex dest,
                          RegIndex op1, RegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeUReg<Base>(size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUReg<Base>(size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeUSReg(unsigned size,
                          ExtMachInst machInst, RegIndex dest,
                          RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeUSReg(unsigned size,
                          ExtMachInst machInst, RegIndex dest,
                          RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeHAndWReg(unsigned size, ExtMachInst machInst,
                             RegIndex dest, RegIndex op1,
                             RegIndex op2)
    {
        switch (size) {
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeImmHAndWReg(unsigned size, ExtMachInst machInst,
                                RegIndex dest, RegIndex op1,
                                RegIndex op2, uint64_t imm)
    {
        switch (size) {
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2, imm);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUSThreeUSReg(bool notSigned, unsigned size,
                           ExtMachInst machInst, RegIndex dest,
                           RegIndex op1, RegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeUSReg<Base>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUSReg<Base>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeSReg(bool q, unsigned size,
                         ExtMachInst machInst, RegIndex dest,
                         RegIndex op1, RegIndex op2)
    {
        if (q) {
            return decodeNeonUThreeUSReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonUThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeSReg(bool q, unsigned size,
                         ExtMachInst machInst, RegIndex dest,
                         RegIndex op1, RegIndex op2)
    {
        if (q) {
            return decodeNeonSThreeUSReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeXReg(bool q, unsigned size,
                         ExtMachInst machInst, RegIndex dest,
                         RegIndex op1, RegIndex op2)
    {
        if (q) {
            return decodeNeonSThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeXReg(bool q, unsigned size,
                         ExtMachInst machInst, RegIndex dest,
                         RegIndex op1, RegIndex op2)
    {
        if (q) {
            return decodeNeonUThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonUThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSThreeSReg(bool q, bool notSigned, unsigned size,
                          ExtMachInst machInst, RegIndex dest,
                          RegIndex op1, RegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeReg(bool q, unsigned size,
                        ExtMachInst machInst, RegIndex dest,
                        RegIndex op1, RegIndex op2)
    {
        if (q) {
            return decodeNeonUThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonUThreeUReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeReg(bool q, unsigned size,
                        ExtMachInst machInst, RegIndex dest,
                        RegIndex op1, RegIndex op2)
    {
        if (q) {
            return decodeNeonSThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSThreeReg(bool q, bool notSigned, unsigned size,
                         ExtMachInst machInst, RegIndex dest,
                         RegIndex op1, RegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeFpReg(bool q, unsigned size, ExtMachInst machInst,
                          RegIndex dest, RegIndex op1, RegIndex op2)
    {
        if (q) {
            if (size)
                return new BaseQ<uint64_t>(machInst, dest, op1, op2);
            else
                return new BaseQ<uint32_t>(machInst, dest, op1, op2);
        } else {
            if (size)
                return new Unknown(machInst);
            else
                return new BaseD<uint32_t>(machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeScFpReg(bool size, ExtMachInst machInst,
                            RegIndex dest, RegIndex op1, RegIndex op2)
    {
        if (size)
            return new Base<uint64_t>(machInst, dest, op1, op2);
        else
            return new Base<uint32_t>(machInst, dest, op1, op2);
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeImmScFpReg(bool size, ExtMachInst machInst,
                               RegIndex dest, RegIndex op1,
                               RegIndex op2, uint64_t imm)
    {
        if (size)
            return new Base<uint64_t>(machInst, dest, op1, op2, imm);
        else
            return new Base<uint32_t>(machInst, dest, op1, op2, imm);
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeImmHAndWReg(bool q, unsigned size, ExtMachInst machInst,
                                RegIndex dest, RegIndex op1,
                                RegIndex op2, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 1:
                return new BaseQ<uint16_t>(machInst, dest, op1, op2, imm);
              case 2:
                return new BaseQ<uint32_t>(machInst, dest, op1, op2, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 1:
                return new BaseD<uint16_t>(machInst, dest, op1, op2, imm);
              case 2:
                return new BaseD<uint32_t>(machInst, dest, op1, op2, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeImmHAndWReg(bool q, unsigned size, ExtMachInst machInst,
                                RegIndex dest, RegIndex op1,
                                RegIndex op2, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 1:
                return new BaseQ<int16_t>(machInst, dest, op1, op2, imm);
              case 2:
                return new BaseQ<int32_t>(machInst, dest, op1, op2, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 1:
                return new BaseD<int16_t>(machInst, dest, op1, op2, imm);
              case 2:
                return new BaseD<int32_t>(machInst, dest, op1, op2, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeImmFpReg(bool q, unsigned size, ExtMachInst machInst,
                             RegIndex dest, RegIndex op1,
                             RegIndex op2, uint64_t imm)
    {
        if (q) {
            if (size)
                return new BaseQ<uint64_t>(machInst, dest, op1, op2, imm);
            else
                return new BaseQ<uint32_t>(machInst, dest, op1, op2, imm);
        } else {
            if (size)
                return new Unknown(machInst);
            else
                return new BaseD<uint32_t>(machInst, dest, op1, op2, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftReg(bool q, unsigned size,
                           ExtMachInst machInst, RegIndex dest,
                           RegIndex op1, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 0:
                return new BaseQ<uint8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseQ<uint16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseQ<uint32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseQ<uint64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0:
                return new BaseD<uint8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseD<uint16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseD<uint32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseD<uint64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoShiftReg(bool q, unsigned size,
                           ExtMachInst machInst, RegIndex dest,
                           RegIndex op1, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 0:
                return new BaseQ<int8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseQ<int16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseQ<int32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseQ<int64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0:
                return new BaseD<int8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseD<int16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseD<int32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseD<int64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }


    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoShiftReg(bool q, bool notSigned, unsigned size,
                            ExtMachInst machInst, RegIndex dest,
                            RegIndex op1, uint64_t imm)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoShiftUSReg(unsigned size,
                             ExtMachInst machInst, RegIndex dest,
                             RegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoShiftUReg(unsigned size,
                            ExtMachInst machInst, RegIndex dest,
                            RegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, imm);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoShiftUReg(unsigned size,
                            ExtMachInst machInst, RegIndex dest,
                            RegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, imm);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftSReg(bool q, unsigned size,
                            ExtMachInst machInst, RegIndex dest,
                            RegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonUTwoShiftUSReg<BaseQ>(
                    size, machInst, dest, op1, imm);
        } else {
            return decodeNeonUTwoShiftUSReg<BaseD>(
                    size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoShiftUSReg(unsigned size,
                             ExtMachInst machInst, RegIndex dest,
                             RegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoShiftSReg(bool q, unsigned size,
                            ExtMachInst machInst, RegIndex dest,
                            RegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonSTwoShiftUSReg<BaseQ>(
                    size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftUSReg<BaseD>(
                    size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoShiftSReg(bool q, bool notSigned, unsigned size,
                             ExtMachInst machInst, RegIndex dest,
                             RegIndex op1, uint64_t imm)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftXReg(bool q, unsigned size, ExtMachInst machInst,
                            RegIndex dest, RegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonUTwoShiftUReg<BaseQ>(
                size, machInst, dest, op1, imm);
        } else {
            return decodeNeonUTwoShiftUSReg<BaseD>(
                size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoShiftXReg(bool q, unsigned size, ExtMachInst machInst,
                            RegIndex dest, RegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonSTwoShiftUReg<BaseQ>(
                size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftUSReg<BaseD>(
                size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoShiftUFpReg(unsigned size, ExtMachInst machInst,
                              RegIndex dest, RegIndex op1, uint64_t imm)
    {
        if (size)
            return new Base<uint64_t>(machInst, dest, op1, imm);
        else
            return new Base<uint32_t>(machInst, dest, op1, imm);
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftFpReg(bool q, unsigned size, ExtMachInst machInst,
                             RegIndex dest, RegIndex op1, uint64_t imm)
    {
        if (q) {
            if (size)
                return new BaseQ<uint64_t>(machInst, dest, op1, imm);
            else
                return new BaseQ<uint32_t>(machInst, dest, op1, imm);
        } else {
            if (size)
                return new Unknown(machInst);
            else
                return new BaseD<uint32_t>(machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoMiscUSReg(unsigned size,
                            ExtMachInst machInst, RegIndex dest,
                            RegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoMiscUSReg(unsigned size,
                            ExtMachInst machInst, RegIndex dest,
                            RegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1);
          case 1:
            return new Base<int16_t>(machInst, dest, op1);
          case 2:
            return new Base<int32_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscSReg(bool q, unsigned size,
                           ExtMachInst machInst, RegIndex dest,
                           RegIndex op1)
    {
        if (q) {
            return decodeNeonUTwoMiscUSReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonUTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoMiscSReg(bool q, unsigned size,
                           ExtMachInst machInst, RegIndex dest,
                           RegIndex op1)
    {
        if (q) {
            return decodeNeonSTwoMiscUSReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoMiscUReg(unsigned size,
                           ExtMachInst machInst, RegIndex dest,
                           RegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoMiscUReg(unsigned size,
                           ExtMachInst machInst, RegIndex dest,
                           RegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1);
          case 1:
            return new Base<int16_t>(machInst, dest, op1);
          case 2:
            return new Base<int32_t>(machInst, dest, op1);
          case 3:
            return new Base<int64_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoMiscReg(bool q, unsigned size,
                          ExtMachInst machInst, RegIndex dest,
                          RegIndex op1)
    {
        if (q) {
            return decodeNeonSTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoMiscUReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscReg(bool q, unsigned size,
                          ExtMachInst machInst, RegIndex dest,
                          RegIndex op1)
    {
        if (q) {
            return decodeNeonUTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonUTwoMiscUReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoMiscSReg(bool q, bool notSigned, unsigned size,
                            ExtMachInst machInst, RegIndex dest,
                            RegIndex op1)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscXReg(bool q, unsigned size, ExtMachInst machInst,
                           RegIndex dest, RegIndex op1)
    {
        if (q) {
            return decodeNeonUTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonUTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoMiscXReg(bool q, unsigned size, ExtMachInst machInst,
                           RegIndex dest, RegIndex op1)
    {
        if (q) {
            return decodeNeonSTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscFpReg(bool q, unsigned size, ExtMachInst machInst,
                            RegIndex dest, RegIndex op1)
    {
        if (q) {
            if (size)
                return new BaseQ<uint64_t>(machInst, dest, op1);
            else
                return new BaseQ<uint32_t>(machInst, dest, op1);
        } else {
            if (size)
                return new Unknown(machInst);
            else
                return new BaseD<uint32_t>(machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscPwiseScFpReg(unsigned size, ExtMachInst machInst,
                                   RegIndex dest, RegIndex op1)
    {
        if (size)
            return new BaseQ<uint64_t>(machInst, dest, op1);
        else
            return new BaseD<uint32_t>(machInst, dest, op1);
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoMiscScFpReg(unsigned size, ExtMachInst machInst,
                              RegIndex dest, RegIndex op1)
    {
        if (size)
            return new Base<uint64_t>(machInst, dest, op1);
        else
            return new Base<uint32_t>(machInst, dest, op1);
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUAcrossLanesReg(bool q, unsigned size, ExtMachInst machInst,
                              RegIndex dest, RegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<uint16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseQ<uint32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<uint16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ,
              template <typename T> class BaseBQ>
    StaticInstPtr
    decodeNeonUAcrossLanesReg(bool q, unsigned size, ExtMachInst machInst,
                              RegIndex dest, RegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<uint16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseBQ<uint32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<uint16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSAcrossLanesReg(bool q, unsigned size, ExtMachInst machInst,
                              RegIndex dest, RegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<int8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<int16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseQ<int32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<int8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<int16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ,
              template <typename T> class BaseBQ>
    StaticInstPtr
    decodeNeonUAcrossLanesLongReg(bool q, unsigned size, ExtMachInst machInst,
                                  RegIndex dest, RegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<uint16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseBQ<uint32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<uint16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ,
              template <typename T> class BaseBQ>
    StaticInstPtr
    decodeNeonSAcrossLanesLongReg(bool q, unsigned size, ExtMachInst machInst,
                                  RegIndex dest, RegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<int8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<int16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseBQ<int32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<int8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<int16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

template <class _Element>
class VhaddD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VhaddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VhaddQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VhaddQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VrhaddD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VrhaddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vrhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VrhaddQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VrhaddQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vrhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VhsubD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VhsubD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vhsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VhsubQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VhsubQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vhsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VandD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VandD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vand", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VandQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VandQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vand", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VbicD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VbicD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vbic", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VbicQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VbicQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vbic", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VorrD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VorrD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vorr", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VorrQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VorrQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vorr", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmovD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmovD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmov", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmovQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmovQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmov", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VornD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VornD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vorn", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VornQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VornQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vorn", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VeorD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VeorD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("veor", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VeorQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VeorQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("veor", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VbifD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VbifD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vbif", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VbifQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VbifQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vbif", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VbitD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VbitD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vbit", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VbitQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VbitQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vbit", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VbslD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VbslD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vbsl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VbslQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VbslQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vbsl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmaxD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmaxD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmax", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmaxQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmaxQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmax", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VminD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VminD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmin", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VminQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VminQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmin", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVaddD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVaddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVaddQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVaddQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVpaddD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVpaddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vpadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vaddl : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vaddl(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vaddl", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vaddw : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vaddw(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vaddw", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vaddhn : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vaddhn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vaddhn", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vraddhn : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vraddhn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vraddhn", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVsubD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVsubD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVsubQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVsubQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vsubl : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vsubl(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vsubl", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vsubw : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vsubw(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vsubw", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqaddUD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqaddUD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqaddUQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqaddUQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vsubhn : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vsubhn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vsubhn", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vrsubhn : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vrsubhn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vrsubhn", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcaddD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcaddD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vcadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcaddQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcaddQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vcadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcmlaElemD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcmlaElemD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcmlaElemQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcmlaElemQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcmlaD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcmlaD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcmlaQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcmlaQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqaddSD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqaddSD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqaddSQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqaddSQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqsubUD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqsubUD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqsubUQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqsubUQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqsubSD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqsubSD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqsubSQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqsubSQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcgtD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcgtD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vcgt", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcgtQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcgtQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vcgt", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcgeD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcgeD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vcge", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcgeQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcgeQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vcge", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VceqD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VceqD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vceq", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VceqQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VceqQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vceq", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VshlD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VshlD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vshl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VshlQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VshlQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vshl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VrshlD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VrshlD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vrshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VrshlQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VrshlQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vrshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqshlUD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqshlUD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqshlUQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqshlUQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqshlSD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqshlSD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqshlSQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqshlSQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrshlUD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrshlUD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrshlUQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrshlUQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrshlSD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrshlSD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrshlSQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrshlSQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VabaD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VabaD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vaba", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VabaQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VabaQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vaba", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vabal : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vabal(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vabal", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VabdD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VabdD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vabd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VabdQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VabdQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vabd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vabdl : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vabdl(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vabdl", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VtstD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VtstD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtst", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VtstQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VtstQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtst", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmulD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmulD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmul", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmulQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmulQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmul", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vmull : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vmull(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmlaD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmlaD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmlaQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmlaQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vmlal : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vmlal(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vqdmlal : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vqdmlal(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqdmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vqdmlsl : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vqdmlsl(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqdmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vqdmull : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vqdmull(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqdmull", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmlsD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmlsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmlsQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmlsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vmlsl : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vmlsl(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmulpD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmulpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmul", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmulpQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmulpQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmul", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vmullp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vmullp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VpmaxD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VpmaxD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vpmax", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VpminD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VpminD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vpmin", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqdmulhD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqdmulhD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqdmulhQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqdmulhQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmlahD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmlahD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmlahQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmlahQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmlshD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmlshD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmlshQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmlshQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmulhD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmulhD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmulhQ : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmulhQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmaxDFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmaxDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmax", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmaxQFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmaxQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmax", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmaxnmDFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmaxnmDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmaxnm", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmaxnmQFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmaxnmQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmaxnm", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VpmaxDFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VpmaxDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vpmax", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VpmaxQFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VpmaxQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vpmax", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VminDFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VminDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmin", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VminQFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VminQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vmin", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VminnmDFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VminnmDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vminnm", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VminnmQFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VminnmQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vminnm", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VpminDFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VpminDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vpmin", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VpminQFp : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VpminQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vpmin", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VaddDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VaddDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VaddQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VaddQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VpaddDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VpaddDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vpadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VpaddQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VpaddQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vpadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VsubDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VsubDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vsub", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VsubQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VsubQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vsub", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmulDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmulDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmulQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmulQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmlaDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmlaDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmlaQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmlaQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVfmaDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVfmaDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vfma", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVfmaQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVfmaQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vfma", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVfmsDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVfmsDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vfms", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVfmsQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVfmsQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vfms", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmlsDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmlsDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmlsQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmlsQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcgtDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcgtDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcgtQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcgtQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcgeDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcgeDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vcge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VcgeQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VcgeQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vcge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VacgtDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VacgtDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vacgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VacgtQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VacgtQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vacgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VacgeDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VacgeDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vacge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VacgeQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VacgeQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vacge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VceqDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VceqDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vceq", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VceqQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VceqQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vceq", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VrecpsDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VrecpsDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vrecps", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VrecpsQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VrecpsQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vrecps", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VrsqrtsDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VrsqrtsDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vrsqrts", machInst, SimdFloatMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VrsqrtsQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VrsqrtsQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vrsqrts", machInst, SimdFloatMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VabdDFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VabdDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vabd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VabdQFp : public FpRegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VabdQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        FpRegRegRegOp("vabd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmlasD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmlasD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmlasQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmlasQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmlasDFp : public FpRegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmlasDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        FpRegRegRegImmOp("vmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmlasQFp : public FpRegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmlasQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        FpRegRegRegImmOp("vmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vmlals : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vmlals(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmlssD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmlssD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmlssQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmlssQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmlssDFp : public FpRegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmlssDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        FpRegRegRegImmOp("vmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmlssQFp : public FpRegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmlssQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        FpRegRegRegImmOp("vmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vmlsls : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vmlsls(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmulsD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmulsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmul", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmulsQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmulsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmul", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmulsDFp : public FpRegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmulsDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        FpRegRegRegImmOp("vmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VmulsQFp : public FpRegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VmulsQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        FpRegRegRegImmOp("vmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vmulls : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vmulls(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vmull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vqdmulls : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vqdmulls(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqdmull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vqdmlals : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vqdmlals(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqdmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Vqdmlsls : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Vqdmlsls(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqdmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqdmulhsD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqdmulhsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqdmulhsQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqdmulhsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmulhsD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmulhsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmulhsQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmulhsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmlahsD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmlahsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmlahsQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmlahsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmlshsD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmlshsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class VqrdmlshsQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[25]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    VqrdmlshsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVshrD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVshrD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVshrQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVshrQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVsraD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVsraD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vsra", machInst, SimdShiftAccOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVsraQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVsraQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vsra", machInst, SimdShiftAccOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrshrD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrshrD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vrshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrshrQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrshrQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vrshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrsraD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrsraD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vrsra", machInst, SimdShiftAccOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrsraQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrsraQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vrsra", machInst, SimdShiftAccOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVsriD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVsriD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vsri", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVsriQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVsriQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vsri", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVshlD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVshlD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vshl", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVshlQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVshlQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vshl", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVsliD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVsliD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vsli", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVsliQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVsliQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vsli", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshlD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshlD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshl", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshlQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshlQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshl", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshluD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshluD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshlu", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshluQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshluQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshlu", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshlusD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshlusD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshlus", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshlusQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshlusQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshlus", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVshrn : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVshrn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrshrn : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrshrn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vrshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshrn : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshrn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshrun : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshrun(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqshruns : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqshruns(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqrshrn : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqrshrn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqrshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqrshrun : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqrshrun(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqrshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqrshruns : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqrshruns(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vqrshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVshll : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVshll(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vshll", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmovl : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmovl(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vmovl", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvt2ufxD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvt2ufxD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvt2ufxQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvt2ufxQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvt2sfxD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvt2sfxD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvt2sfxQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvt2sfxQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvtu2fpD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvtu2fpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvtu2fpQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvtu2fpQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvts2fpD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvts2fpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvts2fpQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvts2fpQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvts2h : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvts2h(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcvth2s : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcvth2s(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcvt", machInst, SimdCvtOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrsqrteD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrsqrteD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrsqrte", machInst, SimdSqrtOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrsqrteQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrsqrteQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrsqrte", machInst, SimdSqrtOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrsqrteDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrsqrteDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vrsqrte", machInst, SimdFloatSqrtOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrsqrteQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrsqrteQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vrsqrte", machInst, SimdFloatSqrtOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrecpeD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrecpeD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrecpe", machInst, SimdMultAccOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrecpeQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrecpeQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrecpe", machInst, SimdMultAccOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrecpeDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrecpeDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vrecpe", machInst, SimdFloatMultAccOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrecpeQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrecpeQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vrecpe", machInst, SimdFloatMultAccOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrev16D : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrev16D(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrev16", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrev16Q : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrev16Q(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrev16", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrev32D : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrev32D(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrev32", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrev32Q : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrev32Q(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrev32", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrev64D : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrev64D(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrev64", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVrev64Q : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVrev64Q(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vrev64", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVpaddlD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVpaddlD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vpaddl", machInst, SimdAddOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVpaddlQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVpaddlQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vpaddl", machInst, SimdAddOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVpadalD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVpadalD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vpadal", machInst, SimdAddAccOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVpadalQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVpadalQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vpadal", machInst, SimdAddAccOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVclsD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVclsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcls", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVclsQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVclsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcls", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVclzD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVclzD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vclz", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVclzQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVclzQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vclz", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcntD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcntD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcnt", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcntQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcntQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcnt", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmvnD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmvnD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vmvn", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmvnQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmvnQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vmvn", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqabsD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqabsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vqabs", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqabsQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqabsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vqabs", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqnegD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqnegD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vqneg", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqnegQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqnegQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vqneg", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVabsD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVabsD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vabs", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVabsQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVabsQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vabs", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVabsDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVabsDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vabs", machInst, SimdFloatAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVabsQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVabsQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vabs", machInst, SimdFloatAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVnegD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVnegD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vneg", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVnegQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVnegQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vneg", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVnegDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVnegDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vneg", machInst, SimdFloatAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVnegQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVnegQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vneg", machInst, SimdFloatAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcgtD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcgtD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcgt", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcgtQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcgtQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcgt", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcgtDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcgtDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcgtQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcgtQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcgeD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcgeD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcge", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcgeQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcgeQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcge", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcgeDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcgeDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vcge", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcgeQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcgeQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vcge", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVceqD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVceqD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vceq", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVceqQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVceqQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vceq", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVceqDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVceqDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vceq", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVceqQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVceqQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vceq", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcleD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcleD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcle", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcleQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcleQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vcle", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcleDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcleDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vcle", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcleQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcleQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vcle", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcltD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcltD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vclt", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcltQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcltQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vclt", machInst, SimdCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcltDFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcltDFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vclt", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVcltQFp : public FpRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[5];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVcltQFp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        FpRegRegOp("vclt", machInst, SimdFloatCmpOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVswpD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVswpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vswp", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVswpQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[8];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVswpQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vswp", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVtrnD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVtrnD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vtrn", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVtrnQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[8];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVtrnQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vtrn", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVuzpD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVuzpD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vuzp", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVuzpQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[8];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVuzpQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vuzp", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVzipD : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVzipD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vzip", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVzipQ : public RegRegOp
{
  private:
    RegId srcRegIdxArr[23]; RegId destRegIdxArr[8];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVzipQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vzip", machInst, SimdAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmovn : public RegRegOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmovn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vmovn", machInst, SimdMiscOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVdupD : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVdupD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vdup", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVdupQ : public RegRegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVdupQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        RegRegImmOp("vdup", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVdupDGpr : public RegRegOp
{
  private:
    RegId srcRegIdxArr[10]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVdupDGpr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vdup", machInst, SimdMiscOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVdupQGpr : public RegRegOp
{
  private:
    RegId srcRegIdxArr[12]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVdupQGpr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vdup", machInst, SimdMiscOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmoviD : public RegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmoviD(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        RegImmOp("vmov", machInst, SimdMiscOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmoviQ : public RegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmoviQ(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        RegImmOp("vmov", machInst, SimdMiscOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVorriD : public RegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVorriD(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        RegImmOp("vorr", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVorriQ : public RegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVorriQ(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        RegImmOp("vorr", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmvniD : public RegImmOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmvniD(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        RegImmOp("vmvn", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVmvniQ : public RegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVmvniQ(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        RegImmOp("vmvn", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVbiciD : public RegImmOp
{
  private:
    RegId srcRegIdxArr[11]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVbiciD(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        RegImmOp("vbic", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVbiciQ : public RegImmOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVbiciQ(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        RegImmOp("vbic", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqmovn : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqmovn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vqmovn", machInst, SimdMiscOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqmovun : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqmovun(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vqmovun", machInst, SimdMiscOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVqmovuns : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[3];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVqmovuns(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("vqmovun", machInst, SimdMiscOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVextD : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[13]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVextD(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vext", machInst, SimdMiscOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NVextQ : public RegRegRegImmOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NVextQ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        RegRegRegImmOp("vext", machInst, SimdMiscOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class NVtbl1 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  public:
    // Constructor
    NVtbl1(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class NVtbl2 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[2];

  public:
    // Constructor
    NVtbl2(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class NVtbl3 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[2];

  public:
    // Constructor
    NVtbl3(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class NVtbl4 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[2];

  public:
    // Constructor
    NVtbl4(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class NVtbx1 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[2];

  public:
    // Constructor
    NVtbx1(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class NVtbx2 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[17]; RegId destRegIdxArr[2];

  public:
    // Constructor
    NVtbx2(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class NVtbx3 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[2];

  public:
    // Constructor
    NVtbx3(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class NVtbx4 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[21]; RegId destRegIdxArr[2];

  public:
    // Constructor
    NVtbx4(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AbsDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AbsDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("abs", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AbsQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AbsQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("abs", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("add", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("add", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AddhnX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AddhnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("addhn", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Addhn2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Addhn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("addhn2", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AddpScQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AddpScQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("addp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AddpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AddpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("addp", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AddpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AddpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("addp", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AddvDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AddvDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("addv", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AddvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AddvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("addv", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AndDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AndDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("and", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class AndQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    AndQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("and", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BicImmDX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BicImmDX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("bic", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BicImmQX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BicImmQX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("bic", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BicDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BicDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("bic", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BicQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BicQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("bic", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BifDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BifDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("bif", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BifQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BifQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("bif", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BitDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BitDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("bit", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BitQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BitQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("bit", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BslDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BslDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("bsl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class BslQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    BslQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("bsl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcaddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcaddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcaddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcaddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmlaElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmlaElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmlaElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmlaElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmlaDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmlaDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmlaQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmlaQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ClsDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ClsDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cls", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ClsQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ClsQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cls", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ClzDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ClzDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("clz", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ClzQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ClzQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("clz", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmeqDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmeqDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmeq", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmeqQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmeqQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmeq", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmeqZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmeqZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmeq", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmeqZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmeqZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmeq", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmgeDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmgeDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmge", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmgeQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmgeQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmge", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmgeZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmgeZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmge", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmgeZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmgeZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmge", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmgtDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmgtDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmgt", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmgtQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmgtQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmgt", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmgtZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmgtZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmgt", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmgtZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmgtZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmgt", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmhiDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmhiDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmhi", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmhiQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmhiQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmhi", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmhsDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmhsDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmhs", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmhsQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmhsQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmhs", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmleZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmleZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmle", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmleZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmleZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmle", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmltZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmltZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmlt", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmltZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmltZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cmlt", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmtstDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmtstDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmtst", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CmtstQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CmtstQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("cmtst", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CntDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CntDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cnt", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class CntQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    CntQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cnt", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class DupElemDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    DupElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("dup", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class DupElemQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    DupElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("dup", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class DupElemScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    DupElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("dup", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class DupGprWDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    DupGprWDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("dup", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class DupGprWQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    DupGprWQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("dup", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class DupGprXQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    DupGprXQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("dup", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class EorDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    EorDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("eor", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class EorQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    EorQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("eor", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ExtDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ExtDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("Ext", machInst, SimdMiscOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ExtQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ExtQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("Ext", machInst, SimdMiscOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FabdDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FabdDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fabd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FabdQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FabdQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fabd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FabdScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FabdScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fabd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FabsDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FabsDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("Abs", machInst, SimdFloatAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FabsQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FabsQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("Abs", machInst, SimdFloatAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FacgeDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FacgeDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("facge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FacgeQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FacgeQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("facge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FacgeScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FacgeScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("facge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FacgtDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FacgtDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("facgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FacgtQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FacgtQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("facgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FacgtScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FacgtScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("facgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FaddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FaddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FaddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FaddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FaddpScDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FaddpScDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("faddp", machInst, SimdFloatAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FaddpScQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FaddpScQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("faddp", machInst, SimdFloatAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FaddpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FaddpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("faddp", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FaddpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FaddpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("faddp", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmeqDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmeqDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmeq", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmeqQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmeqQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmeq", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmeqScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmeqScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmeq", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmeqZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmeqZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmeq", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmeqZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmeqZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmeq", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmeqZeroScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmeqZeroScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmeq", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgeDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgeDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgeQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgeQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgeScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgeScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgeZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgeZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmge", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgeZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgeZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmge", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgeZeroScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgeZeroScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmge", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgtDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgtDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgtQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgtQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgtScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgtScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fcmgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgtZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgtZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmgt", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgtZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgtZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmgt", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmgtZeroScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmgtZeroScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmgt", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmleZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmleZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmle", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmleZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmleZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmle", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmleZeroScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmleZeroScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmle", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmltZeroDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmltZeroDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmlt", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmltZeroQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmltZeroQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmlt", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcmltZeroScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcmltZeroScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcmlt", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtasDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtasDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtas", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtasQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtasQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtas", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtasScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtasScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtas", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtauDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtauDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtau", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtauQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtauQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtau", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtauScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtauScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtau", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtlX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtlX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtl", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Fcvtl2X : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Fcvtl2X(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtl", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtmsDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtmsDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtms", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtmsQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtmsQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtms", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtmsScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtmsScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtms", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtmuDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtmuDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtmu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtmuQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtmuQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtmu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtmuScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtmuScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtmu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtnX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtnX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtn", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Fcvtn2X : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Fcvtn2X(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtn", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtnsDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtnsDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtns", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtnsQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtnsQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtns", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtnsScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtnsScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtns", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtnuDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtnuDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtnu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtnuQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtnuQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtnu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtnuScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtnuScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtnu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtpsDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtpsDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtps", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtpsQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtpsQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtps", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtpsScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtpsScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtps", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtpuDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtpuDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtpu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtpuQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtpuQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtpu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtpuScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtpuScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtpu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtxnX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtxnX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtxn", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Fcvtxn2X : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Fcvtxn2X(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtxn", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtxnScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtxnScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtxn", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzsFixedDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzsFixedDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("fcvtzs", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzsFixedQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzsFixedQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("fcvtzs", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzsFixedScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzsFixedScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("fcvtzs", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzsIntDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzsIntDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtzs", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzsIntQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzsIntQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtzs", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzsIntScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzsIntScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtzs", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzuFixedDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzuFixedDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("fcvtzu", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzuFixedQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzuFixedQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("fcvtzu", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzuFixedScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzuFixedScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("fcvtzu", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzuIntDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzuIntDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtzu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzuIntQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzuIntQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtzu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FcvtzuIntScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FcvtzuIntScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fcvtzu", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FdivDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FdivDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fdiv", machInst, SimdFloatDivOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FdivQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FdivQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fdiv", machInst, SimdFloatDivOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmax", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmax", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxnmDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxnmDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmaxnm", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxnmQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxnmQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmaxnm", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxnmpScDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxnmpScDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fmaxnmp", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxnmpScQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxnmpScQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fmaxnmp", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxnmpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxnmpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmaxnmp", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxnmpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxnmpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmaxnmp", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxnmvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxnmvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fmaxnmv", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxpScDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxpScDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fmaxp", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxpScQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxpScQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fmaxp", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmaxp", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmaxp", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmaxvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmaxvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fmaxv", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmin", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmin", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminnmDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminnmDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fminnm", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminnmQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminnmQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fminnm", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminnmpScDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminnmpScDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fminnmp", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminnmpScQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminnmpScQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fminnmp", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminnmpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminnmpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fminnmp", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminnmpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminnmpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fminnmp", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminnmvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminnmvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fminnmv", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminpScDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminpScDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fminp", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminpScQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminpScQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fminp", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fminp", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fminp", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FminvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FminvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fminv", machInst, SimdFloatCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlaElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlaElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlaElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlaElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlaElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlaElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlaDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlaDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlaQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlaQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlsElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlsElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlsElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlsElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlsElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlsElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlsDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlsDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmlsQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmlsQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmovDX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmovDX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("fmov", machInst, SimdMiscOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmovQX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmovQX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("fmov", machInst, SimdMiscOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulxDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulxDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmulx", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulxQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulxQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmulx", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulxScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulxScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fmulx", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulxElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulxElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmulx", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulxElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulxElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmulx", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FmulxElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FmulxElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("fmulx", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FnegDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FnegDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("Neg", machInst, SimdFloatAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FnegQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FnegQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("Neg", machInst, SimdFloatAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrecpeDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrecpeDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frecpe", machInst, SimdFloatMultAccOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrecpeQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrecpeQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frecpe", machInst, SimdFloatMultAccOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrecpeScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrecpeScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frecpe", machInst, SimdFloatMultAccOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrecpsDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrecpsDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("frecps", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrecpsQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrecpsQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("frecps", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrecpsScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrecpsScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("frecps", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrecpxX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrecpxX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frecpx", machInst, SimdFloatMultAccOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintaDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintaDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frinta", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintaQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintaQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frinta", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintiDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintiDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frinti", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintiQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintiQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frinti", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintmDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintmDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintm", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintmQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintmQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintm", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintnDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintnDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintn", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintnQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintnQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintn", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintpDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintpDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintp", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintpQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintpQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintp", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintxDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintxDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintx", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintxQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintxQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintx", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintzDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintzDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintz", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrintzQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrintzQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frintz", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrsqrteDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrsqrteDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frsqrte", machInst, SimdFloatSqrtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrsqrteQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrsqrteQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frsqrte", machInst, SimdFloatSqrtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrsqrteScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrsqrteScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("frsqrte", machInst, SimdFloatSqrtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrsqrtsDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrsqrtsDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("frsqrts", machInst, SimdFloatMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrsqrtsQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrsqrtsQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("frsqrts", machInst, SimdFloatMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FrsqrtsScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FrsqrtsScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("frsqrts", machInst, SimdFloatMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FsqrtDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FsqrtDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fsqrt", machInst, SimdFloatSqrtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FsqrtQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FsqrtQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("fsqrt", machInst, SimdFloatSqrtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FsubDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FsubDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fsub", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class FsubQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    FsubQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("fsub", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class InsElemX : public DataX1Reg2ImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    InsElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm1,
                   uint64_t _imm2) :
        DataX1Reg2ImmOp("ins", machInst, SimdMiscOp,
                       _dest, _op1, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class InsGprWX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    InsGprWX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ins", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class InsGprXX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    InsGprXX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ins", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MlaElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MlaElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("mla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MlaElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MlaElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("mla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MlaDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MlaDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("mla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MlaQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MlaQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("mla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MlsElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MlsElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("mls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MlsElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MlsElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("mls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MlsDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MlsDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("mls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MlsQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MlsQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("mls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MoviDX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MoviDX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("movi", machInst, SimdMiscOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MoviQX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MoviQX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("movi", machInst, SimdMiscOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MulElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MulElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("mul", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MulElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MulElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("mul", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MulDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MulDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("mul", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MulQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MulQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("mul", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MvnDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MvnDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("mvn", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MvnQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MvnQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("mvn", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MvniDX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MvniDX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("mvni", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class MvniQX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    MvniQX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("mvni", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NegDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NegDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("neg", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class NegQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    NegQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("neg", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class OrnDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    OrnDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("orn", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class OrnQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    OrnQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("orn", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class OrrImmDX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    OrrImmDX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("orr", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class OrrImmQX : public DataXImmOnlyOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    OrrImmQX(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        DataXImmOnlyOp("orr", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class OrrDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    OrrDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("orr", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class OrrQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    OrrQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("orr", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class PmulDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    PmulDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("pmul", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class PmulQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    PmulQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("pmul", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class PmullX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    PmullX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("pmull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Pmull2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Pmull2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("pmull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class RaddhnX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    RaddhnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("raddhn", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Raddhn2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Raddhn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("raddhn2", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class RbitDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    RbitDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rbit", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class RbitQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    RbitQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rbit", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Rev16DX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Rev16DX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev16", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Rev16QX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Rev16QX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev16", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Rev32DX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Rev32DX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev32", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Rev32QX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Rev32QX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev32", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Rev64DX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Rev64DX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev64", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Rev64QX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Rev64QX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev64", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class RshrnX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    RshrnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("rshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Rshrn2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Rshrn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("rshrn2", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class RsubhnX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    RsubhnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("rsubhn", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Rsubhn2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Rsubhn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("rsubhn2", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SabaDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SabaDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("saba", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SabaQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SabaQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("saba", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SabalX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SabalX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sabal", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sabal2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sabal2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sabal2", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SabdDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SabdDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sabd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SabdQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SabdQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sabd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SabdlX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SabdlX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sabdl", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sabdl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sabdl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sabdl2", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SadalpDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SadalpDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sadalp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SadalpQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SadalpQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sadalp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SaddlX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SaddlX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("saddl", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Saddl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Saddl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("saddl2", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SaddlpDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SaddlpDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("saddlp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SaddlpQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SaddlpQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("saddlp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SaddlvDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SaddlvDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("saddlv", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SaddlvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SaddlvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("saddlv", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SaddlvBQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SaddlvBQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("saddlv", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SaddwX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SaddwX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("saddw", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Saddw2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Saddw2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("saddw2", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfFixedDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfFixedDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfFixedSQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfFixedSQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfFixedDQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfFixedDQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfFixedScSX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfFixedScSX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfFixedScDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfFixedScDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfIntDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfIntDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("scvtf", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfIntSQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfIntSQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("scvtf", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfIntDQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfIntDQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("scvtf", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfIntScSX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfIntScSX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("scvtf", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ScvtfIntScDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ScvtfIntScDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("scvtf", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ShaddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ShaddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("shadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ShaddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ShaddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("shadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ShlDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ShlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("shl", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ShlQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ShlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("shl", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ShllX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ShllX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("shll", machInst, SimdShiftOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Shll2X : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Shll2X(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("shll", machInst, SimdShiftOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ShrnX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ShrnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("shrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Shrn2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Shrn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("shrn2", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ShsubDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ShsubDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("shsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class ShsubQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    ShsubQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("shsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SliDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SliDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sli", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SliQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SliQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sli", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmaxDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmaxDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smax", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmaxQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmaxQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smax", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmaxpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmaxpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smaxp", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmaxpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmaxpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smaxp", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmaxvDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmaxvDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("smaxv", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmaxvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmaxvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("smaxv", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SminDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SminDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smin", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SminQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SminQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smin", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SminpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SminpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sminp", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SminpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SminpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sminp", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SminvDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SminvDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sminv", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SminvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SminvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sminv", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmlalElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmlalElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("smlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmlalElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmlalElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("smlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmlalX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmlalX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Smlal2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Smlal2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmlslElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmlslElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("smlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmlslElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmlslElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("smlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmlslX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmlslX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Smlsl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Smlsl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmovWX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmovWX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("smov", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmovXX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmovXX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("smov", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmullElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmullElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("smull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmullElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmullElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("smull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SmullX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SmullX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Smull2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Smull2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqabsDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqabsDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqabs", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqabsQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqabsQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqabs", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqabsScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqabsScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqabs", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqaddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqaddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqaddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqaddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqaddScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqaddScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlalElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlalElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlalElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlalElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlalElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlalElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlalX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlalX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqdmlal2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqdmlal2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlalScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlalScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlslElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlslElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlslElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlslElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlslElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlslElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlslX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlslX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqdmlsl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqdmlsl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmlslScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmlslScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmulhElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmulhElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmulhElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmulhElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmulhElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmulhElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmulhDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmulhDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmulhQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmulhQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmulhScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmulhScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmullElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmullElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmullElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmullElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmullElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmullElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqdmull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmullX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmullX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqdmull2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqdmull2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqdmullScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqdmullScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqdmull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqnegDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqnegDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqneg", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqnegQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqnegQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqneg", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqnegScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqnegScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqneg", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlahElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlahElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlahElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlahElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlahElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlahElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlahDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlahDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlahQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlahQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlahScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlahScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmlah", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlshElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlshElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlshElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlshElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlshElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlshElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlshDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlshDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlshQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlshQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmlshScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmlshScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmlsh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmulhElemDX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmulhElemDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmulhElemQX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmulhElemQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmulhElemScX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmulhElemScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("sqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmulhDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmulhDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmulhQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmulhQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrdmulhScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrdmulhScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrdmulh", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrshlDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrshlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrshlQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrshlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrshlScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrshlScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrshrnX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrshrnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqrshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqrshrn2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqrshrn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqrshrn2", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrshrnScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrshrnScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqrshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrshrunX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrshrunX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqrshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqrshrun2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqrshrun2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqrshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqrshrunScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqrshrunScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqrshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshlImmDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshlImmDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshl", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshlImmQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshlImmQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshl", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshlImmScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshlImmScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshl", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshlDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshlQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshlScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshlScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshluDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshluDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshlu", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshluQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshluQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshlu", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshluScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshluScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshlu", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshrnX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshrnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqshrn2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqshrn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshrn2", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshrnScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshrnScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshrunX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshrunX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqshrun2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqshrun2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqshrunScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqshrunScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sqshrun", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqsubDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqsubDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqsubQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqsubQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqsubScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqsubScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqxtnX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqxtnX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqxtn", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqxtn2X : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqxtn2X(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqxtn", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqxtnScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqxtnScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqxtn", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqxtunX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqxtunX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqxtun", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sqxtun2X : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sqxtun2X(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqxtun", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SqxtunScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SqxtunScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("sqxtun", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SrhaddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SrhaddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("srhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SrhaddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SrhaddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("srhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SriDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SriDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sri", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SriQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SriQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sri", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SrshlDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SrshlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("srshl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SrshlQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SrshlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("srshl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SrshrDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SrshrDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("srshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SrshrQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SrshrQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("srshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SrsraDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SrsraDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("srsra", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SrsraQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SrsraQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("srsra", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SshlDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SshlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sshl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SshlQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SshlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sshl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SshllX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SshllX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sshll", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Sshll2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Sshll2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sshll", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SshrDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SshrDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SshrQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SshrQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("sshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SsraDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SsraDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ssra", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SsraQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SsraQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ssra", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SsublX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SsublX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("ssubl", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Ssubl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Ssubl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("ssubl2", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SsubwX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SsubwX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("ssubw", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Ssubw2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Ssubw2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("ssubw2", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SubDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SubDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SubQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SubQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SubhnX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SubhnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("subhn", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Subhn2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Subhn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("subhn2", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SuqaddDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SuqaddDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("suqadd", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SuqaddQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SuqaddQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("suqadd", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SuqaddScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    SuqaddScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("suqadd", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbl1DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbl1DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbl1QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbl1QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbl2DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbl2DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbl2QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbl2QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbl3DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbl3DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbl3QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbl3QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbl4DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbl4DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 3) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbl4QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbl4QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 3) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbx1DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbx1DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbx1QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbx1QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbx2DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbx2DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbx2QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbx2QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbx3DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbx3DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbx3QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbx3QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbx4DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbx4DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 3) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Tbx4QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Tbx4QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("tbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 3) % 32]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Trn1DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Trn1DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("trn1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Trn1QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Trn1QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("trn1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Trn2DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Trn2DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("trn2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Trn2QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Trn2QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("trn2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UabaDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UabaDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uaba", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UabaQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UabaQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uaba", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UabalX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UabalX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uabal", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uabal2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uabal2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uabal2", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UabdDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UabdDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uabd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UabdQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UabdQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uabd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UabdlX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UabdlX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uabdl", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uabdl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uabdl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uabdl2", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UadalpDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UadalpDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uadalp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UadalpQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UadalpQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uadalp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UaddlX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UaddlX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uaddl", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uaddl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uaddl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uaddl2", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UaddlpDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UaddlpDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uaddlp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UaddlpQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UaddlpQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uaddlp", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UaddlvDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UaddlvDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uaddlv", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UaddlvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UaddlvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uaddlv", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UaddlvBQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UaddlvBQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uaddlv", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UaddwX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UaddwX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uaddw", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uaddw2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uaddw2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uaddw2", machInst, SimdAddAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UcvtfFixedDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UcvtfFixedDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ucvtf", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UcvtfFixedQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UcvtfFixedQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ucvtf", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UcvtfFixedScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UcvtfFixedScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ucvtf", machInst, SimdCvtOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UcvtfIntDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UcvtfIntDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("ucvtf", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UcvtfIntQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UcvtfIntQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("ucvtf", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UcvtfIntScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UcvtfIntScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("ucvtf", machInst, SimdCvtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UhaddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UhaddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UhaddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UhaddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UhsubDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UhsubDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uhsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UhsubQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UhsubQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uhsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmaxDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmaxDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umax", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmaxQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmaxQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umax", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmaxpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmaxpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umaxp", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmaxpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmaxpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umaxp", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmaxvDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmaxvDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("umaxv", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmaxvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmaxvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("umaxv", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UminDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UminDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umin", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UminQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UminQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umin", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UminpDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UminpDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uminp", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UminpQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UminpQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uminp", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UminvDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UminvDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uminv", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UminvQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UminvQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uminv", machInst, SimdCmpOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmlalElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmlalElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("umlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmlalElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmlalElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("umlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmlalX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmlalX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Umlal2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Umlal2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umlal", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmlslElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmlslElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("umlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmlslElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmlslElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("umlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmlslX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmlslX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Umlsl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Umlsl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umlsl", machInst, SimdMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmovWX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmovWX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("umov", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmovXX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmovXX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("umov", machInst, SimdMiscOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmullElemX : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmullElemX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("umull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmullElem2X : public DataX2RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmullElem2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint64_t _imm) :
        DataX2RegImmOp("umull", machInst, SimdMultOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UmullX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UmullX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Umull2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Umull2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umull", machInst, SimdMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqaddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqaddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqaddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqaddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqaddScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqaddScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqrshlDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqrshlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqrshlQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqrshlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqrshlScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqrshlScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqrshl", machInst, SimdCmpOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqrshrnX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqrshrnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqrshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uqrshrn2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uqrshrn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqrshrn2", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqrshrnScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqrshrnScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqrshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqshlImmDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqshlImmDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqshl", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqshlImmQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqshlImmQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqshl", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqshlImmScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqshlImmScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqshl", machInst, SimdAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqshlDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqshlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqshlQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqshlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqshlScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqshlScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqshl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqshrnX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqshrnX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uqshrn2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uqshrn2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqshrn2", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqshrnScX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqshrnScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("uqshrn", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqsubDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqsubDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqsubQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqsubQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqsubScX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqsubScX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("uqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqxtnX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqxtnX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uqxtn", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uqxtn2X : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uqxtn2X(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uqxtn", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UqxtnScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UqxtnScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("uqxtn", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrecpeDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrecpeDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("urecpe", machInst, SimdMultAccOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrecpeQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrecpeQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("urecpe", machInst, SimdMultAccOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrhaddDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrhaddDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("urhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrhaddQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrhaddQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("urhadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrshlDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrshlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("urshl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrshlQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrshlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("urshl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrshrDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrshrDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("urshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrshrQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrshrQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("urshr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrsqrteDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrsqrteDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("ursqrte", machInst, SimdSqrtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrsqrteQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrsqrteQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("ursqrte", machInst, SimdSqrtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrsraDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrsraDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ursra", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UrsraQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UrsraQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ursra", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UshlDX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UshlDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("ushl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UshlQX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UshlQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("ushl", machInst, SimdShiftOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UshllX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UshllX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ushll", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Ushll2X : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Ushll2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ushll", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UshrDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UshrDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ushr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UshrQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UshrQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("ushr", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UsqaddDX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UsqaddDX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("usqadd", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UsqaddQX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UsqaddQX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("usqadd", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UsqaddScX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UsqaddScX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("usqadd", machInst, SimdAddOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_QC]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UsraDX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UsraDX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("usra", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UsraQX : public DataX1RegImmOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UsraQX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm) :
        DataX1RegImmOp("usra", machInst, SimdShiftOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UsublX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UsublX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("usubl", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Usubl2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Usubl2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("usubl2", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class UsubwX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    UsubwX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("usubw", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Usubw2X : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Usubw2X(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("usubw2", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uzp1DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uzp1DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("Uzp1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uzp1QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uzp1QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("Uzp1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uzp2DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uzp2DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("Uzp2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Uzp2QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Uzp2QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("Uzp2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class XtnX : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    XtnX(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("Xtn", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Xtn2X : public DataX1RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Xtn2X(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("Xtn", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Zip1DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Zip1DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("zip1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Zip1QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Zip1QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("zip1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Zip2DX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Zip2DX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("zip2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class Zip2QX : public DataX2RegOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;

  public:
    // Constructor
    Zip2QX(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("zip2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

        class GenericDecoder
        {
          public:
        
        };
    class MicroNeonLoad64 : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      protected:
        // True if the base register is SP (used for SP alignment checking)
        bool baseIsSP;
        // Access size in bytes
        uint8_t accSize;
        // Vector element size (0 -> 8-bit, 1 -> 16-bit, 2 -> 32-bit,
        // 3 -> 64-bit)
        uint8_t eSize;

      public:
        MicroNeonLoad64(ExtMachInst machInst, RegIndex _dest, RegIndex _ura,
                       uint32_t _imm, unsigned extraMemFlags, bool _baseIsSP,
                       uint8_t _accSize, uint8_t _eSize) :
            MicroNeonMemOp("mem_neon_uopld", machInst, MemReadOp, _dest,
                             _ura, _imm),
            baseIsSP(_baseIsSP), accSize(_accSize), eSize(_eSize)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            memAccessFlags |= extraMemFlags;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroNeonStore64 : public MicroNeonMemOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      protected:
        // True if the base register is SP (used for SP alignment checking)
        bool baseIsSP;
        // Access size in bytes
        uint8_t accSize;
        // Vector element size (0 -> 8-bit, 1 -> 16-bit, 2 -> 32-bit,
        // 3 -> 64-bit)
        uint8_t eSize;

      public:
        MicroNeonStore64(ExtMachInst machInst, RegIndex _dest, RegIndex _ura,
                       uint32_t _imm, unsigned extraMemFlags, bool _baseIsSP,
                       uint8_t _accSize, uint8_t _eSize) :
            MicroNeonMemOp("mem_neon_uopst", machInst, MemWriteOp, _dest,
                             _ura, _imm),
            baseIsSP(_baseIsSP), accSize(_accSize), eSize(_eSize)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            memAccessFlags |= extraMemFlags;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class MicroDeintNeon64_1Reg : public MicroNeonMixOp64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[2];

      public:
        MicroDeintNeon64_1Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("deint_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(dest + 1) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroDeintNeon64_2Reg : public MicroNeonMixOp64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

      public:
        MicroDeintNeon64_2Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("deint_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(dest + 1) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroDeintNeon64_3Reg : public MicroNeonMixOp64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

      public:
        MicroDeintNeon64_3Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("deint_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(dest + 1) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroDeintNeon64_4Reg : public MicroNeonMixOp64
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        MicroDeintNeon64_4Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("deint_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(dest + 1) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroIntNeon64_1Reg : public MicroNeonMixOp64
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        MicroIntNeon64_1Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("int_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroIntNeon64_2Reg : public MicroNeonMixOp64
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[2];

      public:
        MicroIntNeon64_2Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("int_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroIntNeon64_3Reg : public MicroNeonMixOp64
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

      public:
        MicroIntNeon64_3Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("int_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroIntNeon64_4Reg : public MicroNeonMixOp64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

      public:
        MicroIntNeon64_4Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("int_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 3) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroUnpackNeon64 : public MicroNeonMixLaneOp64
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

      public:
        MicroUnpackNeon64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _lane, uint8_t _step,
                       bool _replicate = false) :
            MicroNeonMixLaneOp64("unpack_neon_uop", machInst, SimdAddOp,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _lane, _step, _replicate)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1 + 3]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(dest + 0) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(dest + 1) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1) % 32]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroPackNeon64 : public MicroNeonMixLaneOp64
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

      public:
        MicroPackNeon64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _lane, uint8_t _step,
                       bool _replicate = false) :
            MicroNeonMixLaneOp64("pack_neon_uop", machInst, SimdAddOp,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _lane, _step, _replicate)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 3) % 32]);
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 0)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecRegClass[(dest + 1)]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class VldMult64 : public VldMultOp64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor
        VldMult64(ExtMachInst machInst, RegIndex rn, RegIndex vd,
                       RegIndex rm, uint8_t eSize, uint8_t dataSize,
                       uint8_t numStructElems, uint8_t numRegs, bool wb);
    };

    class VstMult64 : public VstMultOp64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor
        VstMult64(ExtMachInst machInst, RegIndex rn, RegIndex vd,
                       RegIndex rm, uint8_t eSize, uint8_t dataSize,
                       uint8_t numStructElems, uint8_t numRegs, bool wb);
    };

    class VldSingle64 : public VldSingleOp64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor
        VldSingle64(ExtMachInst machInst, RegIndex rn, RegIndex vd,
                       RegIndex rm, uint8_t eSize, uint8_t dataSize,
                       uint8_t numStructElems, uint8_t index, bool wb,
                       bool replicate=false);
    };

    class VstSingle64 : public VstSingleOp64
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor
        VstSingle64(ExtMachInst machInst, RegIndex rn, RegIndex vd,
                       RegIndex rm, uint8_t eSize, uint8_t dataSize,
                       uint8_t numStructElems, uint8_t index, bool wb,
                       bool replicate=false);
    };


    // Decodes unary, constructive, predicated (merging) SVE instructions,
    // handling signed and unsigned variants.
    template <template <typename T> class BaseS,
              template <typename T> class BaseU>
    StaticInstPtr
    decodeSveUnaryPred(unsigned size, unsigned u, ExtMachInst machInst,
                       RegIndex dest, RegIndex op1, RegIndex gp)
    {
        switch (size) {
          case 0:
            if (u) {
                return new BaseU<uint8_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int8_t>(machInst, dest, op1, gp);
            }
          case 1:
            if (u) {
                return new BaseU<uint16_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int16_t>(machInst, dest, op1, gp);
            }
          case 2:
            if (u) {
                return new BaseU<uint32_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int32_t>(machInst, dest, op1, gp);
            }
          case 3:
            if (u) {
                return new BaseU<uint64_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int64_t>(machInst, dest, op1, gp);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes SVE widening reductions.
    // handling signed and unsigned variants.
    template <template <typename T1, typename T2> class BaseS,
              template <typename T1, typename T2> class BaseU>
    StaticInstPtr
    decodeSveWideningReduc(unsigned size, unsigned u, ExtMachInst machInst,
                           RegIndex dest, RegIndex op1, RegIndex gp)
    {
        switch (size) {
          case 0:
            if (u) {
                return new BaseU<uint8_t, uint64_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int8_t, int64_t>(machInst, dest, op1, gp);
            }
          case 1:
            if (u) {
                return new BaseU<uint16_t, uint64_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int16_t, int64_t>(machInst, dest, op1, gp);
            }
          case 2:
            if (u) {
                return new BaseU<uint32_t, uint64_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int32_t, int64_t>(machInst, dest, op1, gp);
            }
          case 3:
            assert(u);
            return new BaseU<uint64_t, uint64_t>(machInst, dest, op1, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary, constructive, predicated (merging) SVE instructions,
    // handling signed variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveUnaryPredS(unsigned size, ExtMachInst machInst,
                        RegIndex dest, RegIndex op1, RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, gp);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, gp);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, gp);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary, constructive, predicated (merging) SVE instructions,
    // handling unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveUnaryPredU(unsigned size, ExtMachInst machInst,
                        RegIndex dest, RegIndex op1, RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, gp);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary, constructive, predicated (merging) SVE instructions,
    // handling signed and unsigned variants, for small element sizes (8- to
    // 32-bit).
    template <template <typename T> class BaseS,
              template <typename T> class BaseU>
    StaticInstPtr
    decodeSveUnaryPredSmall(unsigned size, unsigned u, ExtMachInst machInst,
                            RegIndex dest, RegIndex op1, RegIndex gp)
    {
        switch (size) {
          case 0:
            if (u) {
                return new BaseU<uint8_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int8_t>(machInst, dest, op1, gp);
            }
          case 1:
            if (u) {
                return new BaseU<uint16_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int16_t>(machInst, dest, op1, gp);
            }
          case 2:
            if (u) {
                return new BaseU<uint32_t>(machInst, dest, op1, gp);
            } else {
                return new BaseS<int32_t>(machInst, dest, op1, gp);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary, constructive, predicated (merging) SVE instructions,
    // handling floating point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveUnaryPredF(unsigned size, ExtMachInst machInst,
                        RegIndex dest, RegIndex op1, RegIndex gp)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary, constructive, unpredicated SVE instructions, handling
    // unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveUnaryUnpredU(unsigned size, ExtMachInst machInst,
                          RegIndex dest, RegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary, constructive, unpredicated SVE instructions, handling
    // floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveUnaryUnpredF(unsigned size, ExtMachInst machInst,
                          RegIndex dest, RegIndex op1)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, destructive, predicated (merging) SVE instructions,
    // handling signed and unsigned variants.
    template <template <typename T> class BaseS,
              template <typename T> class BaseU>
    StaticInstPtr
    decodeSveBinDestrPred(unsigned size, unsigned u, ExtMachInst machInst,
                          RegIndex dest, RegIndex op2, RegIndex gp)
    {
        switch (size) {
          case 0:
            if (u) {
                return new BaseU<uint8_t>(machInst, dest, op2, gp);
            } else {
                return new BaseS<int8_t>(machInst, dest, op2, gp);
            }
          case 1:
            if (u) {
                return new BaseU<uint16_t>(machInst, dest, op2, gp);
            } else {
                return new BaseS<int16_t>(machInst, dest, op2, gp);
            }
          case 2:
            if (u) {
                return new BaseU<uint32_t>(machInst, dest, op2, gp);
            } else {
                return new BaseS<int32_t>(machInst, dest, op2, gp);
            }
          case 3:
            if (u) {
                return new BaseU<uint64_t>(machInst, dest, op2, gp);
            } else {
                return new BaseS<int64_t>(machInst, dest, op2, gp);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary with immediate operand, constructive, unpredicated
    // SVE instructions, handling signed variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinImmUnpredS(unsigned size, ExtMachInst machInst,
            RegIndex dest, RegIndex op1, unsigned immediate)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, immediate);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, immediate);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, immediate);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, immediate);
          default:
            return new Unknown64(machInst);
        }
    }


    // Decodes binary with immediate operand, constructive, unpredicated
    // SVE instructions, handling unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinImmUnpredU(unsigned size, ExtMachInst machInst,
            RegIndex dest, RegIndex op1, unsigned immediate)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, immediate);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, immediate);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, immediate);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, immediate);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary with immediate operand, destructive, predicated (merging)
    // SVE instructions, handling unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinImmPredU(unsigned size, ExtMachInst machInst, RegIndex dest,
            unsigned immediate, RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, immediate, gp);
          case 1:
            return new Base<uint16_t>(machInst, dest, immediate, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, immediate, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, immediate, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary with immediate operand, destructive, predicated (merging)
    // SVE instructions, handling signed variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinImmPredS(unsigned size, ExtMachInst machInst, RegIndex dest,
            unsigned immediate, RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, immediate, gp);
          case 1:
            return new Base<int16_t>(machInst, dest, immediate, gp);
          case 2:
            return new Base<int32_t>(machInst, dest, immediate, gp);
          case 3:
            return new Base<int64_t>(machInst, dest, immediate, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary with immediate operand, destructive, predicated (merging)
    // SVE instructions, handling floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinImmPredF(unsigned size, ExtMachInst machInst, RegIndex dest,
            uint64_t immediate, RegIndex gp)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, immediate, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, immediate, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, immediate, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary/binary with wide immediate operand, destructive,
    // unpredicated SVE instructions, handling unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveWideImmUnpredU(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint64_t immediate)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, immediate);
          case 1:
            return new Base<uint16_t>(machInst, dest, immediate);
          case 2:
            return new Base<uint32_t>(machInst, dest, immediate);
          case 3:
            return new Base<uint64_t>(machInst, dest, immediate);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary/binary with wide immediate operand, destructive,
    // unpredicated SVE instructions, handling signed variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveWideImmUnpredS(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint64_t immediate)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, immediate);
          case 1:
            return new Base<int16_t>(machInst, dest, immediate);
          case 2:
            return new Base<int32_t>(machInst, dest, immediate);
          case 3:
            return new Base<int64_t>(machInst, dest, immediate);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary/binary with wide immediate operand, destructive,
    // unpredicated SVE instructions, handling floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveWideImmUnpredF(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint64_t immediate)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, immediate);
          case 2:
            return new Base<uint32_t>(machInst, dest, immediate);
          case 3:
            return new Base<uint64_t>(machInst, dest, immediate);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary/binary with wide immediate operand, destructive,
    // predicated SVE instructions, handling unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveWideImmPredU(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint64_t immediate, RegIndex gp,
            bool isMerging = true)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, immediate, gp,
                isMerging);
          case 1:
            return new Base<uint16_t>(machInst, dest, immediate, gp,
                isMerging);
          case 2:
            return new Base<uint32_t>(machInst, dest, immediate, gp,
                isMerging);
          case 3:
            return new Base<uint64_t>(machInst, dest, immediate, gp,
                isMerging);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes unary/binary with wide immediate operand, destructive,
    // predicated SVE instructions, handling floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveWideImmPredF(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint64_t immediate, RegIndex gp)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, immediate, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, immediate, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, immediate, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, destructive, predicated (merging) SVE instructions,
    // handling unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinDestrPredU(unsigned size, ExtMachInst machInst,
                           RegIndex dest, RegIndex op2, RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op2, gp);
          case 1:
            return new Base<uint16_t>(machInst, dest, op2, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op2, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, destructive, predicated (merging) SVE instructions,
    // handling signed variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinDestrPredS(unsigned size, ExtMachInst machInst,
                           RegIndex dest, RegIndex op2, RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op2, gp);
          case 1:
            return new Base<int16_t>(machInst, dest, op2, gp);
          case 2:
            return new Base<int32_t>(machInst, dest, op2, gp);
          case 3:
            return new Base<int64_t>(machInst, dest, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, destructive, predicated (merging) SVE instructions,
    // handling floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinDestrPredF(unsigned size, ExtMachInst machInst,
                           RegIndex dest, RegIndex op2, RegIndex gp)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, op2, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op2, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, constructive, predicated SVE instructions, handling
    // unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinConstrPredU(unsigned size, ExtMachInst machInst,
                            RegIndex dest, RegIndex op1, RegIndex op2,
                            RegIndex gp, SvePredType predType)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2, gp, predType);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2, gp, predType);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2, gp, predType);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2, gp, predType);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, constructive, unpredicated SVE instructions.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinUnpred(unsigned size, unsigned u, ExtMachInst machInst,
                       RegIndex dest, RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 0:
            if (u) {
                return new Base<uint8_t>(machInst, dest, op1, op2);
            } else {
                return new Base<int8_t>(machInst, dest, op1, op2);
            }
          case 1:
            if (u) {
                return new Base<uint16_t>(machInst, dest, op1, op2);
            } else {
                return new Base<int16_t>(machInst, dest, op1, op2);
            }
          case 2:
            if (u) {
                return new Base<uint32_t>(machInst, dest, op1, op2);
            } else {
                return new Base<int32_t>(machInst, dest, op1, op2);
            }
          case 3:
            if (u) {
                return new Base<uint64_t>(machInst, dest, op1, op2);
            } else {
                return new Base<int64_t>(machInst, dest, op1, op2);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, constructive, unpredicated SVE instructions.
    // Unsigned instructions only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinUnpredU(unsigned size, ExtMachInst machInst, RegIndex dest,
            RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, constructive, unpredicated SVE instructions.
    // Signed instructions only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinUnpredS(unsigned size, ExtMachInst machInst, RegIndex dest,
            RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes binary, costructive, unpredicated SVE instructions, handling
    // floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveBinUnpredF(unsigned size, ExtMachInst machInst, RegIndex dest,
            RegIndex op1, RegIndex op2)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes SVE compare instructions - binary, predicated (zeroing),
    // generating a predicate - handling floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveCmpF(unsigned size, ExtMachInst machInst,
                  RegIndex dest, RegIndex op1, RegIndex op2,
                  RegIndex gp)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes SVE compare-with-immediate instructions - binary, predicated
    // (zeroing), generating a predicate - handling floating-point variants
    // only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveCmpImmF(unsigned size, ExtMachInst machInst,
                     RegIndex dest, RegIndex op1, uint64_t imm,
                     RegIndex gp)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, imm, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, imm, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, imm, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes ternary, destructive, predicated (merging) SVE instructions.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerPred(unsigned size, unsigned u, ExtMachInst machInst,
                     RegIndex dest, RegIndex op1, RegIndex op2,
                     RegIndex gp)
    {
        switch (size) {
          case 0:
            if (u) {
                return new Base<uint8_t>(machInst, dest, op1, op2, gp);
            } else {
                return new Base<int8_t>(machInst, dest, op1, op2, gp);
            }
          case 1:
            if (u) {
                return new Base<uint16_t>(machInst, dest, op1, op2, gp);
            } else {
                return new Base<int16_t>(machInst, dest, op1, op2, gp);
            }
          case 2:
            if (u) {
                return new Base<uint32_t>(machInst, dest, op1, op2, gp);
            } else {
                return new Base<int32_t>(machInst, dest, op1, op2, gp);
            }
          case 3:
            if (u) {
                return new Base<uint64_t>(machInst, dest, op1, op2, gp);
            } else {
                return new Base<int64_t>(machInst, dest, op1, op2, gp);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes ternary, destructive, predicated (merging) SVE instructions,
    // handling wide signed variants only. XXX: zeroing for CMP instructions.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerPredWS(unsigned size, ExtMachInst machInst,
                      RegIndex dest, RegIndex op1, RegIndex op2,
                      RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2, gp);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2, gp);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes ternary, destructive, predicated (merging) SVE instructions,
    // handling wide unsigned variants only. XXX: zeroing for CMP instructions.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerPredWU(unsigned size, ExtMachInst machInst,
                      RegIndex dest, RegIndex op1, RegIndex op2,
                      RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2, gp);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes ternary, destructive, predicated (merging) SVE instructions,
    // handling signed variants only. XXX: zeroing for CMP instructions.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerPredS(unsigned size, ExtMachInst machInst,
                      RegIndex dest, RegIndex op1, RegIndex op2,
                      RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2, gp);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2, gp);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2, gp);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes ternary, destructive, predicated (merging) SVE instructions,
    // handling unsigned variants only. XXX: zeroing for CMP instructions.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerPredU(unsigned size, ExtMachInst machInst,
                      RegIndex dest, RegIndex op1, RegIndex op2,
                      RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2, gp);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes SVE signed unary extension instructions (8-bit source element
    // size)
    template <template <typename TS, typename TD> class Base>
    StaticInstPtr
    decodeSveUnaryExtendFromBPredS(unsigned dsize, ExtMachInst machInst,
                                   RegIndex dest, RegIndex op1,
                                   RegIndex gp)
    {
        switch (dsize) {
          case 1:
            return new Base<int8_t, int16_t>(machInst, dest, op1, gp);
          case 2:
            return new Base<int8_t, int32_t>(machInst, dest, op1, gp);
          case 3:
            return new Base<int8_t, int64_t>(machInst, dest, op1, gp);
        }
        return new Unknown64(machInst);
    }

    // Decodes SVE unsigned unary extension instructions (8-bit source element
    // size)
    template <template <typename TS, typename TD> class Base>
    StaticInstPtr
    decodeSveUnaryExtendFromBPredU(unsigned dsize, ExtMachInst machInst,
                                   RegIndex dest, RegIndex op1,
                                   RegIndex gp)
    {
        switch (dsize) {
          case 1:
            return new Base<uint8_t, uint16_t>(machInst, dest, op1, gp);
          case 2:
            return new Base<uint8_t, uint32_t>(machInst, dest, op1, gp);
          case 3:
            return new Base<uint8_t, uint64_t>(machInst, dest, op1, gp);
        }
        return new Unknown64(machInst);
    }

    // Decodes SVE signed unary extension instructions (16-bit source element
    // size)
    template <template <typename TS, typename TD> class Base>
    StaticInstPtr
    decodeSveUnaryExtendFromHPredS(unsigned dsize, ExtMachInst machInst,
                                   RegIndex dest, RegIndex op1,
                                   RegIndex gp)
    {
        switch (dsize) {
          case 2:
            return new Base<int16_t, int32_t>(machInst, dest, op1, gp);
          case 3:
            return new Base<int16_t, int64_t>(machInst, dest, op1, gp);
        }
        return new Unknown64(machInst);
    }

    // Decodes SVE unsigned unary extension instructions (16-bit source element
    // size)
    template <template <typename TS, typename TD> class Base>
    StaticInstPtr
    decodeSveUnaryExtendFromHPredU(unsigned dsize, ExtMachInst machInst,
                                   RegIndex dest, RegIndex op1,
                                   RegIndex gp)
    {
        switch (dsize) {
          case 2:
            return new Base<uint16_t, uint32_t>(machInst, dest, op1, gp);
          case 3:
            return new Base<uint16_t, uint64_t>(machInst, dest, op1, gp);
        }
        return new Unknown64(machInst);
    }

    // Decodes ternary, destructive, predicated (merging) SVE instructions,
    // handling floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerPredF(unsigned size, ExtMachInst machInst,
                      RegIndex dest, RegIndex op1, RegIndex op2,
                      RegIndex gp)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes ternary with immediate operand, destructive, unpredicated SVE
    // instructions handling floating-point variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerImmUnpredF(unsigned size, ExtMachInst machInst,
                           RegIndex dest, RegIndex op2, uint8_t imm)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, op2, imm);
          case 2:
            return new Base<uint32_t>(machInst, dest, op2, imm);
          case 3:
            return new Base<uint64_t>(machInst, dest, op2, imm);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes SVE PTRUE(S) instructions.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSvePtrue(unsigned size, ExtMachInst machInst,
                   RegIndex dest, uint8_t imm)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, imm);
          case 1:
            return new Base<uint16_t>(machInst, dest, imm);
          case 2:
            return new Base<uint32_t>(machInst, dest, imm);
          case 3:
            return new Base<uint64_t>(machInst, dest, imm);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes SVE predicate count instructions, scalar signed variant only
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSvePredCountS(unsigned size, ExtMachInst machInst,
            RegIndex dest, RegIndex op1)
    {
        switch (size) {
            case 0:
                return new Base<int8_t>(machInst, dest, op1);
            case 1:
                return new Base<int16_t>(machInst, dest, op1);
            case 2:
                return new Base<int32_t>(machInst, dest, op1);
            case 3:
                return new Base<int64_t>(machInst, dest, op1);
            default:
                return new Unknown64(machInst);
        }
    }

    // Decodes SVE predicate count instructions, scalar unsigned variant only
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSvePredCountU(unsigned size, ExtMachInst machInst,
            RegIndex dest, RegIndex op1)
    {
        switch (size) {
            case 0:
                return new Base<uint8_t>(machInst, dest, op1);
            case 1:
                return new Base<uint16_t>(machInst, dest, op1);
            case 2:
                return new Base<uint32_t>(machInst, dest, op1);
            case 3:
                return new Base<uint64_t>(machInst, dest, op1);
            default:
                return new Unknown64(machInst);
        }
    }

    // Decodes SVE predicate count instructions, vector signed variant only
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSvePredCountVS(unsigned size, ExtMachInst machInst,
            RegIndex dest, RegIndex op1)
    {
        switch (size) {
            case 1:
                return new Base<int16_t>(machInst, dest, op1);
            case 2:
                return new Base<int32_t>(machInst, dest, op1);
            case 3:
                return new Base<int64_t>(machInst, dest, op1);
            default:
                return new Unknown64(machInst);
        }
    }

    // Decodes SVE predicate count instructions, vector unsigned variant only
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSvePredCountVU(unsigned size, ExtMachInst machInst,
            RegIndex dest, RegIndex op1)
    {
        switch (size) {
            case 1:
                return new Base<uint16_t>(machInst, dest, op1);
            case 2:
                return new Base<uint32_t>(machInst, dest, op1);
            case 3:
                return new Base<uint64_t>(machInst, dest, op1);
            default:
                return new Unknown64(machInst);
        }
    }

    // Decodes ternary with immediate operand, predicated SVE
    // instructions handling unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerImmPredU(unsigned size, ExtMachInst machInst,
            RegIndex dest, RegIndex op1, int64_t imm, RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, imm, gp);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, imm, gp);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, imm, gp);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, imm, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes ternary with immediate operand, predicated SVE
    // instructions handling signed variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveTerImmPredS(unsigned size, ExtMachInst machInst,
            RegIndex dest, RegIndex op1, int64_t imm, RegIndex gp)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, imm, gp);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, imm, gp);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, imm, gp);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, imm, gp);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes integer element count SVE instructions, handling
    // signed variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveElemIntCountS(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint8_t pattern, uint8_t imm4)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, pattern, imm4);
          case 1:
            return new Base<int16_t>(machInst, dest, pattern, imm4);
          case 2:
            return new Base<int32_t>(machInst, dest, pattern, imm4);
          case 3:
            return new Base<int64_t>(machInst, dest, pattern, imm4);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes integer element count SVE instructions, handling
    // unsigned variants only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveElemIntCountU(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint8_t pattern, uint8_t imm4)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, pattern, imm4);
          case 1:
            return new Base<uint16_t>(machInst, dest, pattern, imm4);
          case 2:
            return new Base<uint32_t>(machInst, dest, pattern, imm4);
          case 3:
            return new Base<uint64_t>(machInst, dest, pattern, imm4);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes integer element count SVE instructions, handling
    // signed variants from 16 to 64 bits only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveElemIntCountLS(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint8_t pattern, uint8_t imm4)
    {
        switch (size) {
          case 1:
            return new Base<int16_t>(machInst, dest, pattern, imm4);
          case 2:
            return new Base<int32_t>(machInst, dest, pattern, imm4);
          case 3:
            return new Base<int64_t>(machInst, dest, pattern, imm4);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes integer element count SVE instructions, handling
    // unsigned variants from 16 to 64 bits only.
    template <template <typename T> class Base>
    StaticInstPtr
    decodeSveElemIntCountLU(unsigned size, ExtMachInst machInst,
            RegIndex dest, uint8_t pattern, uint8_t imm4)
    {
        switch (size) {
          case 1:
            return new Base<uint16_t>(machInst, dest, pattern, imm4);
          case 2:
            return new Base<uint32_t>(machInst, dest, pattern, imm4);
          case 3:
            return new Base<uint64_t>(machInst, dest, pattern, imm4);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes SVE unpack instructions. Handling signed variants.
    template <template <typename T1, typename T2> class Base>
    StaticInstPtr
    decodeSveUnpackS(unsigned size, ExtMachInst machInst,
                    RegIndex dest, RegIndex op1)
    {
        switch (size) {
          case 1:
            return new Base<int8_t, int16_t>(machInst, dest, op1);
          case 2:
            return new Base<int16_t, int32_t>(machInst, dest, op1);
          case 3:
            return new Base<int32_t, int64_t>(machInst, dest, op1);
          default:
            return new Unknown64(machInst);
        }
    }

    // Decodes SVE unpack instructions. Handling unsigned variants.
    template <template <typename T1, typename T2> class Base>
    StaticInstPtr
    decodeSveUnpackU(unsigned size, ExtMachInst machInst,
                    RegIndex dest, RegIndex op1)
    {
        switch (size) {
          case 1:
            return new Base<uint8_t, uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint16_t, uint32_t>(machInst, dest, op1);
          case 3:
            return new Base<uint32_t, uint64_t>(machInst, dest, op1);
          default:
            return new Unknown64(machInst);
        }
    }

template <class _Element>
class SveAbs : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAbs(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("abs", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAddImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAddImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("add", machInst, SimdAddOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAddPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAddPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("add", machInst, SimdAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAddUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAddUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("add", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddplXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AddplXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AddvlXImm : public DataXImmOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AddvlXImm(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAdr : public SveAdrOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAdr(ExtMachInst machInst,
        RegIndex _dest, RegIndex _base, RegIndex _offset,
        uint8_t _mult, SveAdrOffsetFormat _offsetFormat) :
        SveAdrOp("adr", machInst, SimdAddOp,
                       _dest, _base, _offset, _mult, _offsetFormat)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAndImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAndImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("and", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAndPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAndPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("and", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAndUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAndUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("and", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredAnd : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredAnd(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("and", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredAnds : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredAnds(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("ands", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAndv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAndv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("andv", machInst, SimdReduceAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAsrImmPred : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAsrImmPred(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("asr", machInst, SimdAluOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAsrImmUnpred : public SveBinImmUnpredConstrOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAsrImmUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm)
        : SveBinImmUnpredConstrOp("asr", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAsrPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAsrPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("asr", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAsrWidePred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAsrWidePred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("asr", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAsrWideUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAsrWideUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("asr", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAsrd : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAsrd(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("asrd", machInst, SimdAluOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveAsrr : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveAsrr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("asrr", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveBicPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveBicPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("bic", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveBicUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveBicUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("bic", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredBic : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredBic(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("bic", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredBics : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredBics(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("bics", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveBrkam : public SvePartBrkOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    SveBrkam(ExtMachInst machInst, RegIndex _dest, RegIndex _gp,
            RegIndex _op1) :
        SvePartBrkOp("brka", machInst, SimdPredAluOp, _dest,
                _gp, _op1, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[dest]);;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveBrkaz : public SvePartBrkOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    SveBrkaz(ExtMachInst machInst, RegIndex _dest, RegIndex _gp,
            RegIndex _op1) :
        SvePartBrkOp("brka", machInst, SimdPredAluOp, _dest,
                _gp, _op1, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveBrkas : public SvePartBrkOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    SveBrkas(ExtMachInst machInst, RegIndex _dest, RegIndex _gp,
            RegIndex _op1) :
        SvePartBrkOp("brkas", machInst, SimdPredAluOp, _dest,
                _gp, _op1, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveBrkbm : public SvePartBrkOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    SveBrkbm(ExtMachInst machInst, RegIndex _dest, RegIndex _gp,
            RegIndex _op1) :
        SvePartBrkOp("brkb", machInst, SimdPredAluOp, _dest,
                _gp, _op1, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[dest]);;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveBrkbz : public SvePartBrkOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    SveBrkbz(ExtMachInst machInst, RegIndex _dest, RegIndex _gp,
            RegIndex _op1) :
        SvePartBrkOp("brkb", machInst, SimdPredAluOp, _dest,
                _gp, _op1, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveBrkbs : public SvePartBrkOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    SveBrkbs(ExtMachInst machInst, RegIndex _dest, RegIndex _gp,
            RegIndex _op1) :
        SvePartBrkOp("brkbs", machInst, SimdPredAluOp, _dest,
                _gp, _op1, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

// XXX: Might be done with SveTerPredOpDeclare and
// instantiating with uint8_t
class SveBrkn : public SvePartBrkPropOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    SveBrkn(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SvePartBrkPropOp("brkn", machInst, SimdPredAluOp, _dest,
                _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[dest]);;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

// XXX: Might be done with SveTerPredOpDeclare and
// instantiating with uint8_t
class SveBrkns : public SvePartBrkPropOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    SveBrkns(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SvePartBrkPropOp("brkns", machInst, SimdPredAluOp, _dest,
                _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

// XXX: Might be done with SveTerPredOpDeclare and
// instantiating with uint8_t
class SveBrkpa : public SvePartBrkPropOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    SveBrkpa(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SvePartBrkPropOp("brkpa", machInst, SimdPredAluOp, _dest,
                _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

// XXX: Might be done with SveTerPredOpDeclare and
// instantiating with uint8_t
class SveBrkpas : public SvePartBrkPropOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    SveBrkpas(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SvePartBrkPropOp("brkpas", machInst, SimdPredAluOp, _dest,
                _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

// XXX: Might be done with SveTerPredOpDeclare and
// instantiating with uint8_t
class SveBrkpb : public SvePartBrkPropOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    SveBrkpb(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SvePartBrkPropOp("brkpb", machInst, SimdPredAluOp, _dest,
                _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

// XXX: Might be done with SveTerPredOpDeclare and
// instantiating with uint8_t
class SveBrkpbs : public SvePartBrkPropOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  public:
    SveBrkpbs(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SvePartBrkPropOp("brkpbs", machInst, SimdPredAluOp, _dest,
                _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveClasta : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveClasta(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("clasta", machInst, SimdAluOp, _dest,
                _op1, _gp, true, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveClastaf : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveClastaf(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("clasta", machInst, SimdAluOp, _dest,
                _op1, _gp, true, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveClastav : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveClastav(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("clasta", machInst, SimdAluOp, _dest,
                _op1, _gp, true, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveClastb : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveClastb(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("clastb", machInst, SimdAluOp, _dest,
                _op1, _gp, true, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveClastbf : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveClastbf(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("clastb", machInst, SimdAluOp, _dest,
                _op1, _gp, true, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveClastbv : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveClastbv(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("clastb", machInst, SimdAluOp, _dest,
                _op1, _gp, true, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCls : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCls(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("cls", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveClz : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveClz(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("clz", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpeqi : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmpeqi(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmpeq", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpeq : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpeq(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpeq", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpeqw : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpeqw(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpeq", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpgei : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmpgei(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmpge", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpge : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpge(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpge", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpgew : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpgew(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpge", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpgti : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmpgti(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmpge", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpgt : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpgt(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpge", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpgtw : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpgtw(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpge", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmphii : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmphii(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmphi", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmphi : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmphi(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmphi", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmphiw : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmphiw(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmphi", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmphsi : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmphsi(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmphs", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmphs : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmphs(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmphs", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmphsw : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmphsw(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmphs", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmplei : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmplei(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmple", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmplew : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmplew(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmple", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmploi : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmploi(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmplo", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmplow : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmplow(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmplo", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmplsi : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmplsi(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmpls", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmplsw : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmplsw(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpls", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmplti : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmplti(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmplt", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpltw : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpltw(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmplt", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpnei : public SveIntCmpImmOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCmpnei(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
            int64_t _op2, RegIndex _gp) :
        SveIntCmpImmOp("cmpeq", machInst, SimdCmpOp, _dest, _op1,
                _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpne : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpne(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpeq", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCmpnew : public SveIntCmpOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCmpnew(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveIntCmpOp("cmpeq", machInst, SimdCmpOp,
                       _dest, _op1, _op2, _gp, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCnot : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCnot(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("cnot", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCnt : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCnt(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("cnt", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCntx : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCntx(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("cnt", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCompact : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCompact(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("compact", machInst, SimdPredAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCpyImmMerge : public SveUnaryWideImmPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCpyImmMerge(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp,
                   bool _isMerging=true) :
        SveUnaryWideImmPredOp("cpy", machInst, SimdAluOp,
                       _dest, _imm, _gp, _isMerging)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCpyImmZero : public SveUnaryWideImmPredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCpyImmZero(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp,
                   bool _isMerging=true) :
        SveUnaryWideImmPredOp("cpy", machInst, SimdAluOp,
                       _dest, _imm, _gp, _isMerging)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCpyScalar : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCpyScalar(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("cpy", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCpySimdFpScalar : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveCpySimdFpScalar(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("cpy", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCntp : public SvePredCountPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCntp(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SvePredCountPredOp("cntp", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};


template <class _Element>
class SveCtermeq : public SveCompTermOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCtermeq(ExtMachInst machInst, RegIndex _op1, RegIndex _op2) :
        SveCompTermOp("ctermeq", machInst, IntAluOp, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveCtermne : public SveCompTermOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveCtermne(ExtMachInst machInst, RegIndex _op1, RegIndex _op2) :
        SveCompTermOp("ctermne", machInst, IntAluOp, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveDec : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveDec(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("dec", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveDecv : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveDecv(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("dec", machInst, SimdAluOp, _dest,
                _pattern, _imm, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveDecp : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveDecp(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("decp", machInst, SimdAluOp,
                       _dest, _op1, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveDecpv : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveDecpv(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("decp", machInst, SimdAluOp,
                       _dest, _op1, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveDupImm : public SveUnaryWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveDupImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveUnaryWideImmUnpredOp("dup", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveDupIdx : public SveBinImmIdxUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveDupIdx(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm)
        : SveBinImmIdxUnpredOp("mov", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveDupScalar : public SveUnaryUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveDupScalar(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnaryUnpredOp("dup", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveDupm : public SveUnaryWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveDupm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveUnaryWideImmUnpredOp("dupm", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveEorImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveEorImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("eor", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveEorPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveEorPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("eor", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveEorUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveEorUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("eor", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredEor : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredEor(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("eor", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredEors : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredEors(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("eors", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveEorv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveEorv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("eorv", machInst, SimdReduceAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveExt : public SveBinImmUnpredDestrOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveExt(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm)
        : SveBinImmUnpredDestrOp("ext", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFabd : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFabd(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fabd", machInst, SimdFloatAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFabs : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFabs(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fabs", machInst, SimdFloatAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFacge : public SveCmpOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFacge(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveCmpOp("facge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFacgt : public SveCmpOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFacgt(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveCmpOp("facgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFaddImm : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFaddImm(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("fadd", machInst, SimdFloatAddOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFaddPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFaddPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fadd", machInst, SimdFloatAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFaddUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFaddUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("fadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFadda : public SveOrdReducOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFadda(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveOrdReducOp("fadda", machInst, SimdFloatReduceAddOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFaddv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFaddv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("faddv", machInst, SimdFloatReduceAddOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcadd : public SveComplexOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcadd(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, uint8_t _rot) :
        SveComplexOp("fcadd", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2, _gp, _rot)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmeq : public SveCmpOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmeq(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveCmpOp("fcmeq", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmeqZero : public SveCmpImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmeqZero(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm, RegIndex _gp) :
        SveCmpImmOp("fcmeq", machInst, SimdFloatCmpOp,
                       _dest, _op1, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmge : public SveCmpOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmge(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveCmpOp("fcmge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmgeZero : public SveCmpImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmgeZero(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm, RegIndex _gp) :
        SveCmpImmOp("fcmge", machInst, SimdFloatCmpOp,
                       _dest, _op1, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmgt : public SveCmpOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmgt(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveCmpOp("fcmgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmgtZero : public SveCmpImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmgtZero(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm, RegIndex _gp) :
        SveCmpImmOp("fcmgt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmleZero : public SveCmpImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmleZero(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm, RegIndex _gp) :
        SveCmpImmOp("fcmle", machInst, SimdFloatCmpOp,
                       _dest, _op1, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmltZero : public SveCmpImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmltZero(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm, RegIndex _gp) :
        SveCmpImmOp("fcmlt", machInst, SimdFloatCmpOp,
                       _dest, _op1, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmne : public SveCmpOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmne(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveCmpOp("fcmne", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmneZero : public SveCmpImmOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmneZero(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm, RegIndex _gp) :
        SveCmpImmOp("fcmne", machInst, SimdFloatCmpOp,
                       _dest, _op1, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmuo : public SveCmpOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmuo(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveCmpOp("fcmuo", machInst, SimdFloatCmpOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmlai : public SveComplexIdxOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmlai(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   uint8_t _rot, uint8_t _imm) :
        SveComplexIdxOp("fcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _rot, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcmlav : public SveComplexOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcmlav(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, uint8_t _rot) :
        SveComplexOp("fcmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp, _rot)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFcpy : public SveUnaryWideImmPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFcpy(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp,
                   bool _isMerging=true) :
        SveUnaryWideImmPredOp("fcpy", machInst, SimdAluOp,
                       _dest, _imm, _gp, _isMerging)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveFcvtNarrow : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveFcvtNarrow(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fcvt", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveFcvtWiden : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveFcvtWiden(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fcvt", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveFcvtzsNarrow : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveFcvtzsNarrow(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fcvtzs", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveFcvtzsWiden : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveFcvtzsWiden(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fcvtzs", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveFcvtzuNarrow : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveFcvtzuNarrow(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fcvtzu", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveFcvtzuWiden : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveFcvtzuWiden(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fcvtzu", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFdiv : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFdiv(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fdiv", machInst, SimdFloatDivOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFdivr : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFdivr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fdivr", machInst, SimdFloatDivOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFdup : public SveUnaryWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFdup(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveUnaryWideImmUnpredOp("fdup", machInst, SimdFloatAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFexpa : public SveUnaryUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFexpa(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnaryUnpredOp("fexpa", machInst, SimdFloatAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmad : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmad(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("fmad", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmaxImm : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmaxImm(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("fmax", machInst, SimdFloatCmpOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmax : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmax(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fmax", machInst, SimdFloatCmpOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmaxnmImm : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmaxnmImm(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("fmaxnm", machInst, SimdFloatCmpOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmaxnm : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmaxnm(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fmaxnm", machInst, SimdFloatCmpOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmaxnmv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmaxnmv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("fmaxnmv", machInst, SimdFloatReduceCmpOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmaxv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmaxv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("fmaxv", machInst, SimdFloatReduceCmpOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFminImm : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFminImm(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("fmin", machInst, SimdFloatCmpOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmin : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmin(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fmin", machInst, SimdFloatCmpOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFminnmImm : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFminnmImm(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("fminnm", machInst, SimdFloatCmpOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFminnm : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFminnm(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fminnm", machInst, SimdFloatCmpOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFminnmv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFminnmv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("fminnmv", machInst, SimdFloatReduceCmpOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFminv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFminv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("fminv", machInst, SimdFloatReduceCmpOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmlaIdx : public SveBinIdxUnpredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmlaIdx(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint8_t _index) :
        SveBinIdxUnpredOp("fmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmla : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmla(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("fmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmlsIdx : public SveBinIdxUnpredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmlsIdx(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint8_t _index) :
        SveBinIdxUnpredOp("fmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmls : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmls(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("fmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmsb : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmsb(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("fmsb", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmulImm : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmulImm(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmulPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmulPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmulUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmulUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmulIdx : public SveBinIdxUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmulIdx(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint8_t _index) :
        SveBinIdxUnpredOp("fmul", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2, _index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFmulx : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFmulx(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fmulx", machInst, SimdFloatMultOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFneg : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFneg(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fneg", machInst, SimdFloatAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFnmad : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFnmad(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("fnmad", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFnmla : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFnmla(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("fnmla", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFnmls : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFnmls(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("fnmls", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFnmsb : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFnmsb(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("fnmsb", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrecpe : public SveUnaryUnpredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrecpe(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnaryUnpredOp("frecpe", machInst, SimdFloatMultAccOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrecps : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrecps(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("frecps", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrecpx : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrecpx(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("frecpx", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrinta : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrinta(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("frinta", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrinti : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrinti(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("frinti", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrintm : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrintm(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("frintm", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrintn : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrintn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("frintn", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrintp : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrintp(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("frintp", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrintx : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrintx(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("frintx", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrintz : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrintz(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("frintz", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrsqrte : public SveUnaryUnpredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrsqrte(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnaryUnpredOp("frsqrte", machInst, SimdFloatSqrtOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFrsqrts : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFrsqrts(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("frsqrts", machInst, SimdFloatMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFscale : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFscale(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fscale", machInst, SimdFloatMiscOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFsqrt : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFsqrt(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("fsqrt", machInst, SimdFloatSqrtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFsubImm : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFsubImm(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("fsub", machInst, SimdFloatAddOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFsubPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFsubPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fsub", machInst, SimdFloatAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFsubUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFsubUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("fsub", machInst, SimdFloatAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFsubrImm : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFsubrImm(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("fsubr", machInst, SimdFloatAddOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFsubr : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFsubr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("fsubr", machInst, SimdFloatAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFtmad : public SveTerImmUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFtmad(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, uint64_t _imm) :
        SveTerImmUnpredOp("ftmad", machInst, SimdFloatMultAccOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFtsmul : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFtsmul(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("ftsmul", machInst, SimdFloatMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveFtssel : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveFtssel(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("ftssel", machInst, SimdFloatMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveInc : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveInc(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("inc", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveIncv : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveIncv(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("inc", machInst, SimdAluOp, _dest,
                _pattern, _imm, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveIncp : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveIncp(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("incp", machInst, SimdAluOp,
                       _dest, _op1, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveIncpv : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveIncpv(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("incp", machInst, SimdAluOp,
                       _dest, _op1, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveIndexIR : public SveIndexIROp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveIndexIR(ExtMachInst machInst, RegIndex _dest,
               int8_t _imm, RegIndex _op) :
        SveIndexIROp("index", machInst, SimdAluOp,
                     _dest, _imm, _op)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveIndexII : public SveIndexIIOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveIndexII(ExtMachInst machInst, RegIndex _dest,
               int8_t _imm1, int8_t _imm2) :
        SveIndexIIOp("index", machInst, SimdAluOp,
                     _dest, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveIndexRI : public SveIndexRIOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveIndexRI(ExtMachInst machInst, RegIndex _dest,
               RegIndex _op, int8_t _imm) :
        SveIndexRIOp("index", machInst, SimdAluOp,
                     _dest, _op, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveIndexRR : public SveIndexRROp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveIndexRR(ExtMachInst machInst, RegIndex _dest,
               RegIndex _op1, RegIndex _op2) :
        SveIndexRROp("index", machInst, SimdAluOp,
                     _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveInsr : public SveUnarySca2VecUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveInsr(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnarySca2VecUnpredOp("insr", machInst, SimdAluOp,
                       _dest, _op1, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveInsrf : public SveUnarySca2VecUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveInsrf(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnarySca2VecUnpredOp("insr", machInst, SimdAluOp,
                       _dest, _op1, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLasta : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveLasta(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("lasta", machInst, SimdAluOp, _dest,
                _op1, _gp, false, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLastaf : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveLastaf(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("lasta", machInst, SimdAluOp, _dest,
                _op1, _gp, false, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLastb : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveLastb(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("lastb", machInst, SimdAluOp, _dest,
                _op1, _gp, false, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLastbf : public SveSelectOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveLastbf(ExtMachInst machInst, RegIndex _dest,
            RegIndex _op1, RegIndex _gp) :
        SveSelectOp("lastb", machInst, SimdAluOp, _dest,
                _op1, _gp, false, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        scalar_width = (sizeof(Element) == 8) ? 64 : 32;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLslImmPred : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLslImmPred(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("lsl", machInst, SimdAluOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLslImmUnpred : public SveBinImmUnpredConstrOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLslImmUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm)
        : SveBinImmUnpredConstrOp("lsl", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLslPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLslPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("lsl", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLslWidePred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLslWidePred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("lsl", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLslWideUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLslWideUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("lsl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLslr : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLslr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("lslr", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLsrImmPred : public SveBinImmPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLsrImmPred(ExtMachInst machInst,
                   RegIndex _dest, uint64_t _imm, RegIndex _gp) :
        SveBinImmPredOp("lsr", machInst, SimdAluOp,
                       _dest, _imm, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLsrImmUnpred : public SveBinImmUnpredConstrOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLsrImmUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, uint64_t _imm)
        : SveBinImmUnpredConstrOp("lsr", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLsrPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLsrPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("lsr", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLsrWidePred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLsrWidePred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("lsr", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLsrWideUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLsrWideUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("lsr", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveLsrr : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveLsrr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("lsrr", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMad : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMad(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("mad", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMla : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMla(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("mla", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMls : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMls(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("mls", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMovprfxPredM : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMovprfxPredM(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("movprfx", machInst, SimdMiscOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMovprfxPredZ : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMovprfxPredZ(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("movprfx", machInst, SimdMiscOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMovprfxUnpred : public SveUnaryUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMovprfxUnpred(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnaryUnpredOp("movprfx", machInst, SimdMiscOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMsb : public SveTerPredOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMsb(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, RegIndex _gp) :
        SveTerPredOp("msb", machInst, SimdMultAccOp,
                       _dest, _op1, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMulImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMulImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("mul", machInst, SimdMultOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveMul : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveMul(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("mul", machInst, SimdMultOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredNand : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredNand(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("nand", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredNands : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredNands(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("nands", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveNeg : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveNeg(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("neg", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredNor : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredNor(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("nor", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredNors : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredNors(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("nors", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveNot : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveNot(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("not", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredOrn : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredOrn(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("orn", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredOrns : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredOrns(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("orns", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveOrrImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveOrrImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("orr", machInst, SimdAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveOrrPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveOrrPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("orr", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveOrrUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveOrrUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("orr", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredOrr : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredOrr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("orr", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredOrrs : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[9]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredOrrs(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("orrs", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveOrv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveOrv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("orv", machInst, SimdReduceAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SvePfalse : public SvePredUnaryWImplicitSrcOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    SvePfalse(ExtMachInst machInst, RegIndex _dest) :
        SvePredUnaryWImplicitSrcOp("pfalse", machInst, SimdPredAluOp, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePfirst : public SveUnaryPredPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePfirst(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredPredOp("pfirst", machInst, SimdPredAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePnext : public SveUnaryPredPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePnext(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredPredOp("pnext", machInst, SimdPredAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SvePtest : public SvePredTestOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[3];

  public:
    SvePtest(ExtMachInst machInst, RegIndex _op1, RegIndex _gp) :
        SvePredTestOp("ptest", machInst, SimdPredAluOp, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePtrue : public SvePtrueOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePtrue(ExtMachInst machInst, RegIndex _dest, uint8_t _imm) :
        SvePtrueOp("ptrue", machInst, SimdPredAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePtrues : public SvePtrueOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePtrues(ExtMachInst machInst, RegIndex _dest, uint8_t _imm) :
        SvePtrueOp("ptrues", machInst, SimdPredAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SvePunpkhi : public SveUnpackOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SvePunpkhi(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnpackOp("punpkhi", machInst, SimdPredAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SvePunpklo : public SveUnpackOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SvePunpklo(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnpackOp("punpklo", machInst, SimdPredAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveRbit : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveRbit(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("rbit", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveRdffrUnpred : public SvePredUnaryWImplicitSrcOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    SveRdffrUnpred(ExtMachInst machInst, RegIndex _dest) :
        SvePredUnaryWImplicitSrcOp("rdffr", machInst, SimdPredAluOp, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[PREDREG_FFR]);;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveRdffrPred : public SvePredUnaryWImplicitSrcPredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  public:
    SveRdffrPred(ExtMachInst machInst, RegIndex _dest, RegIndex _gp) :
        SvePredUnaryWImplicitSrcPredOp("rdffr", machInst, SimdPredAluOp, _dest, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[PREDREG_FFR]);;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveRdffrsPred : public SvePredUnaryWImplicitSrcPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  public:
    SveRdffrsPred(ExtMachInst machInst, RegIndex _dest, RegIndex _gp) :
        SvePredUnaryWImplicitSrcPredOp("rdffrs", machInst, SimdPredAluOp, _dest, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[PREDREG_FFR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveRdvl : public RegImmOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SveRdvl(ExtMachInst machInst, RegIndex _dest, uint64_t _imm);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveRevp : public SveUnaryUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveRevp(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnaryUnpredOp("rev", machInst, SimdPredAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveRevv : public SveUnaryUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveRevv(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnaryUnpredOp("rev", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveRevb : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveRevb(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("revb", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveRevh : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveRevh(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("revh", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveRevw : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveRevw(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("revw", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSabd : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSabd(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("sabd", machInst, SimdAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveSaddv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveSaddv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("saddv", machInst, SimdReduceAddOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveScvtfNarrow : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveScvtfNarrow(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("scvtf", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveScvtfWiden : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveScvtfWiden(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("scvtf", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSdiv : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSdiv(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("sdiv", machInst, SimdDivOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSdivr : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSdivr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("sdivr", machInst, SimdDivOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveSdoti : public SveDotProdIdxOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _DElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SveSdoti(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint64_t _imm) :
        SveDotProdIdxOp("sdot", machInst, SimdAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveSdotv : public SveDotProdOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _DElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SveSdotv(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveDotProdOp("sdot", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SvePredSel : public SvePredLogicalOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SvePredSel(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, bool _isSel=false) :
        SvePredLogicalOp("sel", machInst, SimdPredAluOp,
                       _dest, _op1, _op2, _gp, _isSel)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSel : public SveBinConstrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSel(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2,
                   RegIndex _gp, SvePredType _predType) :
        SveBinConstrPredOp("sel", machInst, SimdAluOp,
                       _dest, _op1, _op2, _gp, _predType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveSetffr : public SveWImplicitSrcDstOp
{
  private:
    RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

  public:
    SveSetffr(ExtMachInst machInst) :
        SveWImplicitSrcDstOp("setffr", machInst, SimdPredAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[PREDREG_FFR]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSmaxImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSmaxImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("smax", machInst, SimdCmpOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSmax : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSmax(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("smax", machInst, SimdCmpOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSmaxv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSmaxv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("smaxv", machInst, SimdReduceCmpOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSminImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSminImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("smin", machInst, SimdCmpOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSmin : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSmin(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("smin", machInst, SimdCmpOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSminv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSminv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("sminv", machInst, SimdReduceCmpOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSmulh : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSmulh(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("smulh", machInst, SimdMultOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSplice : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSplice(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("splice", machInst, SimdAluOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqaddImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSqaddImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("sqadd", machInst, SimdAddOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqadd : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSqadd(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("sqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqdec32 : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqdec32(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("sqdec", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqdec : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqdec(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("sqdec", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqdecv : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqdecv(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("sqdec", machInst, SimdAluOp, _dest,
                _pattern, _imm, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqdecp32 : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqdecp32(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("sqdecp", machInst, SimdAluOp,
                       _dest, _op1, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqdecp64 : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqdecp64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("sqdecp", machInst, SimdAluOp,
                       _dest, _op1, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqdecpv : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqdecpv(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("sqdecp", machInst, SimdAluOp,
                       _dest, _op1, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqinc32 : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqinc32(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("sqinc", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqinc : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqinc(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("sqinc", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqincv : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqincv(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("sqinc", machInst, SimdAluOp, _dest,
                _pattern, _imm, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqincp32 : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqincp32(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("sqincp", machInst, SimdAluOp,
                       _dest, _op1, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqincp64 : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqincp64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("sqincp", machInst, SimdAluOp,
                       _dest, _op1, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqincpv : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveSqincpv(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("sqincp", machInst, SimdAluOp,
                       _dest, _op1, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqsubImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSqsubImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("sqsub", machInst, SimdAddOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSqsub : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSqsub(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("sqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSubImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSubImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("sub", machInst, SimdAddOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSubPred : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSubPred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("sub", machInst, SimdAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSubUnpred : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSubUnpred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("sub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSubrImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSubrImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("subr", machInst, SimdAddOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveSubr : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveSubr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("subr", machInst, SimdAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveSunpkhi : public SveUnpackOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SveSunpkhi(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnpackOp("sunpkhi", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveSunpklo : public SveUnpackOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SveSunpklo(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnpackOp("sunpklo", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveSxtb : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveSxtb(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("sxtb", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveSxth : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveSxth(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("sxth", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveSxtw : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveSxtw(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("sxtw", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveTbl : public SveTblOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveTbl(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveTblOp("tbl", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveTrn1Pred : public SvePredBinPermOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveTrn1Pred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SvePredBinPermOp("trn1", machInst, SimdPredAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveTrn2Pred : public SvePredBinPermOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveTrn2Pred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SvePredBinPermOp("trn2", machInst, SimdPredAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveTrn1 : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveTrn1(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("trn1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveTrn2 : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveTrn2(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("trn2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUabd : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUabd(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("uabd", machInst, SimdAddOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUaddv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveUaddv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("uaddv", machInst, SimdReduceAddOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUcvtfNarrow : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveUcvtfNarrow(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("ucvtf", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUcvtfWiden : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveUcvtfWiden(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("ucvtf", machInst, SimdCvtOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUdiv : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUdiv(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("udiv", machInst, SimdDivOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUdivr : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUdivr(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("udivr", machInst, SimdDivOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUdoti : public SveDotProdIdxOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _DElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SveUdoti(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2, uint64_t _imm) :
        SveDotProdIdxOp("udot", machInst, SimdAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUdotv : public SveDotProdOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _DElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SveUdotv(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveDotProdOp("udot", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUmaxImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUmaxImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("umax", machInst, SimdCmpOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUmax : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUmax(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("umax", machInst, SimdCmpOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUmaxv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUmaxv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("umaxv", machInst, SimdReduceCmpOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUminImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUminImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("umin", machInst, SimdCmpOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUmin : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUmin(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("umin", machInst, SimdCmpOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUminv : public SveReducOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUminv(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _gp) :
        SveReducOp("uminv", machInst, SimdReduceCmpOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUmulh : public SveBinDestrPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUmulh(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op2, RegIndex _gp) :
        SveBinDestrPredOp("umulh", machInst, SimdMultOp,
                       _dest, _op2, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqaddImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUqaddImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("uqadd", machInst, SimdAddOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqadd : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUqadd(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("uqadd", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqdec32 : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqdec32(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("uqdec", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqdec : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqdec(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("uqdec", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqdecv : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqdecv(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("uqdec", machInst, SimdAluOp, _dest,
                _pattern, _imm, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqdecp32 : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqdecp32(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("uqdecp", machInst, SimdAluOp,
                       _dest, _op1, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqdecp64 : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqdecp64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("uqdecp", machInst, SimdAluOp,
                       _dest, _op1, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqdecpv : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqdecpv(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("uqdecp", machInst, SimdAluOp,
                       _dest, _op1, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqinc32 : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqinc32(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("uqinc", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqinc : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqinc(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("uqinc", machInst, SimdAluOp, _dest,
                _pattern, _imm, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqincv : public SveElemCountOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqincv(ExtMachInst machInst, RegIndex _dest,
            uint8_t _pattern, uint8_t _imm) :
        SveElemCountOp("uqinc", machInst, SimdAluOp, _dest,
                _pattern, _imm, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        esize = sizeof(Element);
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqincp32 : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqincp32(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("uqincp", machInst, SimdAluOp,
                       _dest, _op1, true, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqincp64 : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqincp64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("uqincp", machInst, SimdAluOp,
                       _dest, _op1, false, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqincpv : public SvePredCountOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveUqincpv(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SvePredCountOp("uqincp", machInst, SimdAluOp,
                       _dest, _op1, false, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqsubImm : public SveBinWideImmUnpredOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUqsubImm(ExtMachInst machInst, RegIndex _dest, uint64_t _imm) :
        SveBinWideImmUnpredOp("uqsub", machInst, SimdAddOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUqsub : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUqsub(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("uqsub", machInst, SimdAddOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUunpkhi : public SveUnpackOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SveUunpkhi(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnpackOp("uunpkhi", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUunpklo : public SveUnpackOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    SveUunpklo(ExtMachInst machInst, RegIndex _dest, RegIndex _op1) :
        SveUnpackOp("uunpklo", machInst, SimdAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUxtb : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveUxtb(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("uxtb", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUxth : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveUxth(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("uxth", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _SElement, class _DElement>
class SveUxtw : public SveUnaryPredOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  protected:
    typedef _SElement Element;
    typedef _SElement SElement;
    typedef _DElement DElement;
    typedef _SElement TPSElem;
    typedef _DElement TPDElem;

  public:
    // Constructor
    SveUxtw(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _gp) :
        SveUnaryPredOp("uxtw", machInst, SimdAluOp,
                       _dest, _op1, _gp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUzp1Pred : public SvePredBinPermOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUzp1Pred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SvePredBinPermOp("uzp1", machInst, SimdPredAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUzp2Pred : public SvePredBinPermOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUzp2Pred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SvePredBinPermOp("uzp2", machInst, SimdPredAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUzp1 : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUzp1(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("uzp1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveUzp2 : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveUzp2(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("uzp2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveWhilele32 : public SveWhileOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveWhilele32(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2) :
        SveWhileOp("whilele", machInst, SimdCmpOp,
                       _dest, _op1, _op2, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveWhilele64 : public SveWhileOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveWhilele64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2) :
        SveWhileOp("whilele", machInst, SimdCmpOp,
                       _dest, _op1, _op2, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveWhilelo32 : public SveWhileOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveWhilelo32(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2) :
        SveWhileOp("whilelo", machInst, SimdCmpOp,
                       _dest, _op1, _op2, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveWhilelo64 : public SveWhileOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveWhilelo64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2) :
        SveWhileOp("whilelo", machInst, SimdCmpOp,
                       _dest, _op1, _op2, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveWhilels32 : public SveWhileOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveWhilels32(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2) :
        SveWhileOp("whilels", machInst, SimdCmpOp,
                       _dest, _op1, _op2, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveWhilels64 : public SveWhileOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveWhilels64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2) :
        SveWhileOp("whilels", machInst, SimdCmpOp,
                       _dest, _op1, _op2, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveWhilelt32 : public SveWhileOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveWhilelt32(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2) :
        SveWhileOp("whilelt", machInst, SimdCmpOp,
                       _dest, _op1, _op2, true)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveWhilelt64 : public SveWhileOp
{
  private:
    RegId srcRegIdxArr[8]; RegId destRegIdxArr[4];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    SveWhilelt64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2) :
        SveWhileOp("whilelt", machInst, SimdCmpOp,
                       _dest, _op1, _op2, false)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SveWrffr : public SvePredUnaryWImplicitDstOp
{
  private:
    RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

  public:
    SveWrffr(ExtMachInst machInst, RegIndex _op1) :
        SvePredUnaryWImplicitDstOp("wrffr", machInst, SimdPredAluOp, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[PREDREG_FFR]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveZip1Pred : public SvePredBinPermOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveZip1Pred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SvePredBinPermOp("zip1", machInst, SimdPredAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveZip2Pred : public SvePredBinPermOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveZip2Pred(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SvePredBinPermOp("zip2", machInst, SimdPredAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveZip1 : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveZip1(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("zip1", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

template <class _Element>
class SveZip2 : public SveBinUnpredOp
{
  private:
    RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

  protected:
    typedef _Element Element;
    typedef _Element TPElem;

  public:
    // Constructor
    SveZip2(ExtMachInst machInst,
                   RegIndex _dest, RegIndex _op1, RegIndex _op2) :
        SveBinUnpredOp("zip2", machInst, SimdAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    Fault execute(ExecContext *, trace::InstRecord *) const override;
};


    // Decodes SVE contiguous load instructions, scalar plus scalar form.
    template <template <typename T1, typename T2> class Base>
    StaticInstPtr
    decodeSveContigLoadSSInsts(uint8_t dtype, ExtMachInst machInst,
                               RegIndex zt, RegIndex pg, RegIndex rn,
                               RegIndex rm, bool firstFaulting)
    {
        const char* mn = firstFaulting ? "ldff1" : "ld1";
        switch (dtype) {
          case 0x0:
            return new Base<uint8_t, uint8_t>(mn, machInst, zt, pg, rn, rm);
          case 0x1:
            return new Base<uint16_t, uint8_t>(mn, machInst, zt, pg, rn, rm);
          case 0x2:
            return new Base<uint32_t, uint8_t>(mn, machInst, zt, pg, rn, rm);
          case 0x3:
            return new Base<uint64_t, uint8_t>(mn, machInst, zt, pg, rn, rm);
          case 0x4:
            return new Base<int64_t, int32_t>(mn, machInst, zt, pg, rn, rm);
          case 0x5:
            return new Base<uint16_t, uint16_t>(mn, machInst, zt, pg, rn, rm);
          case 0x6:
            return new Base<uint32_t, uint16_t>(mn, machInst, zt, pg, rn, rm);
          case 0x7:
            return new Base<uint64_t, uint16_t>(mn, machInst, zt, pg, rn, rm);
          case 0x8:
            return new Base<int64_t, int16_t>(mn, machInst, zt, pg, rn, rm);
          case 0x9:
            return new Base<int32_t, int16_t>(mn, machInst, zt, pg, rn, rm);
          case 0xa:
            return new Base<uint32_t, uint32_t>(mn, machInst, zt, pg, rn, rm);
          case 0xb:
            return new Base<uint64_t, uint32_t>(mn, machInst, zt, pg, rn, rm);
          case 0xc:
            return new Base<int64_t, int8_t>(mn, machInst, zt, pg, rn, rm);
          case 0xd:
            return new Base<int32_t, int8_t>(mn, machInst, zt, pg, rn, rm);
          case 0xe:
            return new Base<int16_t, int8_t>(mn, machInst, zt, pg, rn, rm);
          case 0xf:
            return new Base<uint64_t, uint64_t>(mn, machInst, zt, pg, rn, rm);
        }
        return new Unknown64(machInst);
    }

    // Decodes SVE contiguous load instructions, scalar plus immediate form.
    template <template <typename T1, typename T2> class Base>
    StaticInstPtr
    decodeSveContigLoadSIInsts(uint8_t dtype, ExtMachInst machInst,
                               RegIndex zt, RegIndex pg, RegIndex rn,
                               uint64_t imm, bool nonFaulting,
                               bool replicate = false)
    {
        assert(!(nonFaulting && replicate));
        const char* mn = replicate ? "ld1r" : (nonFaulting ? "ldnf1" : "ld1");
        switch (dtype) {
          case 0x0:
            return new Base<uint8_t, uint8_t>(mn, machInst, zt, pg, rn, imm);
          case 0x1:
            return new Base<uint16_t, uint8_t>(mn, machInst, zt, pg, rn, imm);
          case 0x2:
            return new Base<uint32_t, uint8_t>(mn, machInst, zt, pg, rn, imm);
          case 0x3:
            return new Base<uint64_t, uint8_t>(mn, machInst, zt, pg, rn, imm);
          case 0x4:
            return new Base<int64_t, int32_t>(mn, machInst, zt, pg, rn, imm);
          case 0x5:
            return new Base<uint16_t, uint16_t>(mn, machInst, zt, pg, rn, imm);
          case 0x6:
            return new Base<uint32_t, uint16_t>(mn, machInst, zt, pg, rn, imm);
          case 0x7:
            return new Base<uint64_t, uint16_t>(mn, machInst, zt, pg, rn, imm);
          case 0x8:
            return new Base<int64_t, int16_t>(mn, machInst, zt, pg, rn, imm);
          case 0x9:
            return new Base<int32_t, int16_t>(mn, machInst, zt, pg, rn, imm);
          case 0xa:
            return new Base<uint32_t, uint32_t>(mn, machInst, zt, pg, rn, imm);
          case 0xb:
            return new Base<uint64_t, uint32_t>(mn, machInst, zt, pg, rn, imm);
          case 0xc:
            return new Base<int64_t, int8_t>(mn, machInst, zt, pg, rn, imm);
          case 0xd:
            return new Base<int32_t, int8_t>(mn, machInst, zt, pg, rn, imm);
          case 0xe:
            return new Base<int16_t, int8_t>(mn, machInst, zt, pg, rn, imm);
          case 0xf:
            return new Base<uint64_t, uint64_t>(mn, machInst, zt, pg, rn, imm);
        }
        return new Unknown64(machInst);
    }

    // Decodes SVE contiguous store instructions, scalar plus scalar form.
    template <template <typename T1, typename T2> class Base>
    StaticInstPtr
    decodeSveContigStoreSSInsts(uint8_t dtype, ExtMachInst machInst,
                                RegIndex zt, RegIndex pg, RegIndex rn,
                                RegIndex rm)
    {
        const char* mn = "st1";
        switch (dtype) {
          case 0x0:
            return new Base<uint8_t, uint8_t>(mn, machInst, zt, pg, rn, rm);
          case 0x1:
            return new Base<uint16_t, uint8_t>(mn, machInst, zt, pg, rn, rm);
          case 0x2:
            return new Base<uint32_t, uint8_t>(mn, machInst, zt, pg, rn, rm);
          case 0x3:
            return new Base<uint64_t, uint8_t>(mn, machInst, zt, pg, rn, rm);
          case 0x5:
            return new Base<uint16_t, uint16_t>(mn, machInst, zt, pg, rn, rm);
          case 0x6:
            return new Base<uint32_t, uint16_t>(mn, machInst, zt, pg, rn, rm);
          case 0x7:
            return new Base<uint64_t, uint16_t>(mn, machInst, zt, pg, rn, rm);
          case 0xa:
            return new Base<uint32_t, uint32_t>(mn, machInst, zt, pg, rn, rm);
          case 0xb:
            return new Base<uint64_t, uint32_t>(mn, machInst, zt, pg, rn, rm);
          case 0xf:
            return new Base<uint64_t, uint64_t>(mn, machInst, zt, pg, rn, rm);
        }
        return new Unknown64(machInst);
    }

    // Decodes SVE contiguous store instructions, scalar plus immediate form.
    template <template <typename T1, typename T2> class Base>
    StaticInstPtr
    decodeSveContigStoreSIInsts(uint8_t dtype, ExtMachInst machInst,
                                RegIndex zt, RegIndex pg, RegIndex rn,
                                int8_t imm)
    {
        const char* mn = "st1";
        switch (dtype) {
          case 0x0:
            return new Base<uint8_t, uint8_t>(mn, machInst, zt, pg, rn, imm);
          case 0x1:
            return new Base<uint16_t, uint8_t>(mn, machInst, zt, pg, rn, imm);
          case 0x2:
            return new Base<uint32_t, uint8_t>(mn, machInst, zt, pg, rn, imm);
          case 0x3:
            return new Base<uint64_t, uint8_t>(mn, machInst, zt, pg, rn, imm);
          case 0x5:
            return new Base<uint16_t, uint16_t>(mn, machInst, zt, pg, rn, imm);
          case 0x6:
            return new Base<uint32_t, uint16_t>(mn, machInst, zt, pg, rn, imm);
          case 0x7:
            return new Base<uint64_t, uint16_t>(mn, machInst, zt, pg, rn, imm);
          case 0xa:
            return new Base<uint32_t, uint32_t>(mn, machInst, zt, pg, rn, imm);
          case 0xb:
            return new Base<uint64_t, uint32_t>(mn, machInst, zt, pg, rn, imm);
          case 0xf:
            return new Base<uint64_t, uint64_t>(mn, machInst, zt, pg, rn, imm);
        }
        return new Unknown64(machInst);
    }

    // NOTE: SVE load-and-replicate instructions are decoded with
    // decodeSveContigLoadSIInsts(...).


    template <class RegElemType, class MemElemType>
    class SveContigLoadSI : public SveContigMemSI
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      protected:
        typedef RegElemType TPElem;

      public:
        SveContigLoadSI(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                uint64_t _imm) :
            SveContigMemSI(mnem, machInst, MemReadOp,
                    _dest, _gp, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveContigStoreSI : public SveContigMemSI
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      protected:
        typedef RegElemType TPElem;

      public:
        SveContigStoreSI(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                uint64_t _imm) :
            SveContigMemSI(mnem, machInst, MemWriteOp,
                    _dest, _gp, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveContigNFLoadSI : public SveContigMemSI
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      protected:
        typedef RegElemType TPElem;

      public:
        SveContigNFLoadSI(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                uint64_t _imm) :
            SveContigMemSI(mnem, machInst, MemReadOp,
                    _dest, _gp, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[PREDREG_FFR]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[PREDREG_FFR]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveContigLoadSS : public SveContigMemSS
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      protected:
        typedef RegElemType TPElem;

      public:
        SveContigLoadSS(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                RegIndex _offset) :
            SveContigMemSS(mnem, machInst, MemReadOp,
                    _dest, _gp, _base, _offset)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveContigStoreSS : public SveContigMemSS
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      protected:
        typedef RegElemType TPElem;

      public:
        SveContigStoreSS(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                RegIndex _offset) :
            SveContigMemSS(mnem, machInst, MemWriteOp,
                    _dest, _gp, _base, _offset)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveContigFFLoadSS : public SveContigMemSS
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

      protected:
        typedef RegElemType TPElem;

      public:
        SveContigFFLoadSS(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                RegIndex _offset) :
            SveContigMemSS(mnem, machInst, MemReadOp,
                    _dest, _gp, _base, _offset)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[PREDREG_FFR]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[PREDREG_FFR]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveLoadAndRepl : public SveContigMemSI
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      protected:
        typedef RegElemType TPElem;

      public:
        SveLoadAndRepl(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                uint64_t _imm) :
            SveContigMemSI(mnem, machInst, MemReadOp,
                    _dest, _gp, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveLd1RqSI : public SveContigMemSI
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      protected:
        typedef RegElemType TPElem;

      public:
        SveLd1RqSI(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                uint64_t _imm) :
            SveContigMemSI(mnem, machInst, MemReadOp,
                    _dest, _gp, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveLd1RqSS : public SveContigMemSS
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      protected:
        typedef RegElemType TPElem;

      public:
        SveLd1RqSS(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                RegIndex _offset) :
            SveContigMemSS(mnem, machInst, MemReadOp,
                    _dest, _gp, _base, _offset)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template<class _Element>
    class SveLoadRegImmMicroop : public MicroOp
    {
      public:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;

        RegIndex dest;
        RegIndex gp;
        RegIndex base;
        int64_t imm;

        uint8_t numRegs;
        int regIndex;

        unsigned memAccessFlags;

        bool baseIsSP;

      public:
        SveLoadRegImmMicroop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                int64_t _imm, uint8_t _numRegs, int _regIndex) :
            MicroOp(mnem, machInst, MemReadOp),
            dest(_dest), gp(_gp), base(_base), imm(_imm),
            numRegs(_numRegs), regIndex(_regIndex),
            memAccessFlags(ArmISA::MMU::AllowUnaligned)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
            baseIsSP = isSP(_base);
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            printMnemonic(ss, "", false);
            ccprintf(ss, "{");
            switch (dest) {
              case INTRLVREG0:
                ccprintf(ss, "INTRLV0");
                break;
              case INTRLVREG1:
                ccprintf(ss, "INTRLV1");
                break;
              case INTRLVREG2:
                ccprintf(ss, "INTRLV2");
                break;
              case INTRLVREG3:
                ccprintf(ss, "INTRLV3");
                break;
              default:
                printVecReg(ss, dest, true);
                break;
            }
            ccprintf(ss, "}, ");
            printVecPredReg(ss, gp);
            if (_opClass == MemReadOp) {
                ccprintf(ss, "/z");
            }
            ccprintf(ss, ", [");
            printVecReg(ss, base, true);
            if (imm != 0) {
                ccprintf(ss, ", #%d", imm * sizeof(Element));
            }
            ccprintf(ss, "] (uop reg %d tfer)", regIndex);
            return ss.str();
        }
    };

    template<class _Element>
    class SveStoreRegImmMicroop : public MicroOp
    {
      public:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;

        RegIndex dest;
        RegIndex gp;
        RegIndex base;
        int64_t imm;

        uint8_t numRegs;
        int regIndex;

        unsigned memAccessFlags;

        bool baseIsSP;

      public:
        SveStoreRegImmMicroop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                int64_t _imm, uint8_t _numRegs, int _regIndex) :
            MicroOp(mnem, machInst, MemWriteOp),
            dest(_dest), gp(_gp), base(_base), imm(_imm),
            numRegs(_numRegs), regIndex(_regIndex),
            memAccessFlags(ArmISA::MMU::AllowUnaligned)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
            baseIsSP = isSP(_base);
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            printMnemonic(ss, "", false);
            ccprintf(ss, "{");
            switch (dest) {
              case INTRLVREG0:
                ccprintf(ss, "INTRLV0");
                break;
              case INTRLVREG1:
                ccprintf(ss, "INTRLV1");
                break;
              case INTRLVREG2:
                ccprintf(ss, "INTRLV2");
                break;
              case INTRLVREG3:
                ccprintf(ss, "INTRLV3");
                break;
              default:
                printVecReg(ss, dest, true);
                break;
            }
            ccprintf(ss, "}, ");
            printVecPredReg(ss, gp);
            if (_opClass == MemReadOp) {
                ccprintf(ss, "/z");
            }
            ccprintf(ss, ", [");
            printVecReg(ss, base, true);
            if (imm != 0) {
                ccprintf(ss, ", #%d", imm * sizeof(Element));
            }
            ccprintf(ss, "] (uop reg %d tfer)", regIndex);
            return ss.str();
        }
    };

    template <class _Element>
    class SveLoadRegRegMicroop : public MicroOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;

        RegIndex dest;
        RegIndex gp;
        RegIndex base;
        RegIndex offset;

        uint8_t numRegs;
        int regIndex;

        unsigned memAccessFlags;

        bool baseIsSP;

      public:
        SveLoadRegRegMicroop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                RegIndex _offset, uint8_t _numRegs, int _regIndex) :
            MicroOp(mnem, machInst, MemReadOp),
            dest(_dest), gp(_gp), base(_base), offset(_offset),
            numRegs(_numRegs), regIndex(_regIndex),
            memAccessFlags(ArmISA::MMU::AllowUnaligned)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
            baseIsSP = isSP(_base);
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            printMnemonic(ss, "", false);
            ccprintf(ss, "{");
            switch (dest) {
              case INTRLVREG0:
                ccprintf(ss, "INTRLV0");
                break;
              case INTRLVREG1:
                ccprintf(ss, "INTRLV1");
                break;
              case INTRLVREG2:
                ccprintf(ss, "INTRLV2");
                break;
              case INTRLVREG3:
                ccprintf(ss, "INTRLV3");
                break;
              default:
                printVecReg(ss, dest, true);
                break;
            }
            ccprintf(ss, "}, ");
            printVecPredReg(ss, gp);
            if (_opClass == MemReadOp) {
                ccprintf(ss, "/z");
            }
            ccprintf(ss, ", [");
            printIntReg(ss, base);
            ccprintf(ss, ", ");
            printVecReg(ss, offset, true);
            ccprintf(ss, "] (uop reg %d tfer)", regIndex);
            return ss.str();
        }
    };

    template <class _Element>
    class SveStoreRegRegMicroop : public MicroOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;

        RegIndex dest;
        RegIndex gp;
        RegIndex base;
        RegIndex offset;

        uint8_t numRegs;
        int regIndex;

        unsigned memAccessFlags;

        bool baseIsSP;

      public:
        SveStoreRegRegMicroop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _gp, RegIndex _base,
                RegIndex _offset, uint8_t _numRegs, int _regIndex) :
            MicroOp(mnem, machInst, MemWriteOp),
            dest(_dest), gp(_gp), base(_base), offset(_offset),
            numRegs(_numRegs), regIndex(_regIndex),
            memAccessFlags(ArmISA::MMU::AllowUnaligned)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
            baseIsSP = isSP(_base);
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            printMnemonic(ss, "", false);
            ccprintf(ss, "{");
            switch (dest) {
              case INTRLVREG0:
                ccprintf(ss, "INTRLV0");
                break;
              case INTRLVREG1:
                ccprintf(ss, "INTRLV1");
                break;
              case INTRLVREG2:
                ccprintf(ss, "INTRLV2");
                break;
              case INTRLVREG3:
                ccprintf(ss, "INTRLV3");
                break;
              default:
                printVecReg(ss, dest, true);
                break;
            }
            ccprintf(ss, "}, ");
            printVecPredReg(ss, gp);
            if (_opClass == MemReadOp) {
                ccprintf(ss, "/z");
            }
            ccprintf(ss, ", [");
            printIntReg(ss, base);
            ccprintf(ss, ", ");
            printVecReg(ss, offset, true);
            ccprintf(ss, "] (uop reg %d tfer)", regIndex);
            return ss.str();
        }
    };

    class SveLdrPred : public SveMemPredFillSpill
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      protected:
        typedef uint8_t TPElem;
        typedef uint8_t RegElemType;
        typedef uint8_t MemElemType;

      public:
        SveLdrPred(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, uint64_t _imm) :
            SveMemPredFillSpill("ldr", machInst, MemReadOp,
                _dest, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[dest]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class SveStrPred : public SveMemPredFillSpill
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      protected:
        typedef uint8_t TPElem;
        typedef uint8_t RegElemType;
        typedef uint8_t MemElemType;

      public:
        SveStrPred(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, uint64_t _imm) :
            SveMemPredFillSpill("str", machInst, MemWriteOp,
                _dest, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class SveLdrVec : public SveMemVecFillSpill
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      protected:
        typedef uint8_t TPElem;
        typedef uint8_t RegElemType;
        typedef uint8_t MemElemType;

      public:
        SveLdrVec(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, uint64_t _imm) :
            SveMemVecFillSpill("ldr", machInst, MemReadOp,
                _dest, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    class SveStrVec : public SveMemVecFillSpill
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      protected:
        typedef uint8_t TPElem;
        typedef uint8_t RegElemType;
        typedef uint8_t MemElemType;

      public:
        SveStrVec(ExtMachInst machInst,
                RegIndex _dest, RegIndex _base, uint64_t _imm) :
            SveMemVecFillSpill("str", machInst, MemWriteOp,
                _dest, _base, _imm)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }
    };

    template <class RegElemType, class MemElemType>
    class SveGatherLoadVIMicroop : public MicroOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

      protected:
        typedef RegElemType TPElem;

        RegIndex dest;
        RegIndex gp;
        RegIndex base;
        uint64_t imm;

        int elemIndex;
        int numElems;
        bool firstFault;

        unsigned memAccessFlags;

      public:
        SveGatherLoadVIMicroop(const char* mnem, ExtMachInst machInst,
                OpClass __opClass, RegIndex _dest, RegIndex _gp,
                RegIndex _base, uint64_t _imm, int _elemIndex,
                int _numElems, bool _firstFault) :
            MicroOp(mnem, machInst, MemReadOp),
            dest(_dest), gp(_gp), base(_base), imm(_imm),
            elemIndex(_elemIndex), numElems(_numElems),
            firstFault(_firstFault),
            memAccessFlags(ArmISA::MMU::AllowUnaligned)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VECREG_UREG0]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[PREDREG_UREG0]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
            if (_opClass == MemReadOp && elemIndex == 0) {
                // The first micro-op is responsible for pinning the
                // destination and the fault status registers
                assert(_numDestRegs == 2);
                for (int i = 0; i < _numDestRegs; i++) {
                    auto dr = destRegIdx(i);
                    dr.setNumPinnedWrites(numElems - 1);
                    setDestRegIdx(i, dr);
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            // TODO: add suffix to transfer register
            std::stringstream ss;
            printMnemonic(ss, "", false);
            ccprintf(ss, "{");
            printVecReg(ss, dest, true);
            ccprintf(ss, "}, ");
            printVecPredReg(ss, gp);
            if (_opClass == MemReadOp) {
                ccprintf(ss, "/z");
            }
            ccprintf(ss, ", [");
            printVecReg(ss, base, true);
            if (imm != 0) {
                ccprintf(ss, ", #%d", imm * sizeof(MemElemType));
            }
            ccprintf(ss, "] (uop elem %d tfer)", elemIndex);
            return ss.str();
        }
    };

    template <class RegElemType, class MemElemType>
    class SveScatterStoreVIMicroop : public MicroOp
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      protected:
        typedef RegElemType TPElem;

        RegIndex dest;
        RegIndex gp;
        RegIndex base;
        uint64_t imm;

        int elemIndex;
        int numElems;
        bool firstFault;

        unsigned memAccessFlags;

      public:
        SveScatterStoreVIMicroop(const char* mnem, ExtMachInst machInst,
                OpClass __opClass, RegIndex _dest, RegIndex _gp,
                RegIndex _base, uint64_t _imm, int _elemIndex,
                int _numElems, bool _firstFault) :
            MicroOp(mnem, machInst, MemWriteOp),
            dest(_dest), gp(_gp), base(_base), imm(_imm),
            elemIndex(_elemIndex), numElems(_numElems),
            firstFault(_firstFault),
            memAccessFlags(ArmISA::MMU::AllowUnaligned)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
            if (_opClass == MemReadOp && elemIndex == 0) {
                // The first micro-op is responsible for pinning the
                // destination and the fault status registers
                assert(_numDestRegs == 2);
                for (int i = 0; i < _numDestRegs; i++) {
                    auto dr = destRegIdx(i);
                    dr.setNumPinnedWrites(numElems - 1);
                    setDestRegIdx(i, dr);
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            // TODO: add suffix to transfer register
            std::stringstream ss;
            printMnemonic(ss, "", false);
            ccprintf(ss, "{");
            printVecReg(ss, dest, true);
            ccprintf(ss, "}, ");
            printVecPredReg(ss, gp);
            if (_opClass == MemReadOp) {
                ccprintf(ss, "/z");
            }
            ccprintf(ss, ", [");
            printVecReg(ss, base, true);
            if (imm != 0) {
                ccprintf(ss, ", #%d", imm * sizeof(MemElemType));
            }
            ccprintf(ss, "] (uop elem %d tfer)", elemIndex);
            return ss.str();
        }
    };

    template <class RegElemType, class MemElemType>
    class SveGatherLoadSVMicroop : public MicroOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      protected:
        typedef RegElemType TPElem;

        RegIndex dest;
        RegIndex gp;
        RegIndex base;
        RegIndex offset;

        bool offsetIs32;
        bool offsetIsSigned;
        bool offsetIsScaled;

        int elemIndex;
        int numElems;
        bool firstFault;

        unsigned memAccessFlags;

      public:
        SveGatherLoadSVMicroop(const char* mnem, ExtMachInst machInst,
                OpClass __opClass, RegIndex _dest, RegIndex _gp,
                RegIndex _base, RegIndex _offset, bool _offsetIs32,
                bool _offsetIsSigned, bool _offsetIsScaled, int _elemIndex,
                int _numElems, bool _firstFault) :
            MicroOp(mnem, machInst, MemReadOp),
            dest(_dest), gp(_gp), base(_base), offset(_offset),
            offsetIs32(_offsetIs32), offsetIsSigned(_offsetIsSigned),
            offsetIsScaled(_offsetIsScaled), elemIndex(_elemIndex),
            numElems(_numElems), firstFault(_firstFault),
            memAccessFlags(ArmISA::MMU::AllowUnaligned)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VECREG_UREG0]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[PREDREG_UREG0]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
            if (_opClass == MemReadOp && elemIndex == 0) {
                // The first micro-op is responsible for pinning the
                // destination and the fault status registers
                assert(_numDestRegs == 2);
                for (int i = 0; i < _numDestRegs; i++) {
                    auto dr = destRegIdx(i);
                    dr.setNumPinnedWrites(numElems - 1);
                    setDestRegIdx(i, dr);
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            // TODO: add suffix to transfer and base registers
            std::stringstream ss;
            printMnemonic(ss, "", false);
            ccprintf(ss, "{");
            printVecReg(ss, dest, true);
            ccprintf(ss, "}, ");
            printVecPredReg(ss, gp);
            if (_opClass == MemReadOp) {
                ccprintf(ss, "/z");
            }
            ccprintf(ss, ", [");
            printIntReg(ss, base);
            ccprintf(ss, ", ");
            printVecReg(ss, offset, true);
            ccprintf(ss, "] (uop elem %d tfer)", elemIndex);
            return ss.str();
        }
    };

    template <class RegElemType, class MemElemType>
    class SveScatterStoreSVMicroop : public MicroOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[0];

      protected:
        typedef RegElemType TPElem;

        RegIndex dest;
        RegIndex gp;
        RegIndex base;
        RegIndex offset;

        bool offsetIs32;
        bool offsetIsSigned;
        bool offsetIsScaled;

        int elemIndex;
        int numElems;
        bool firstFault;

        unsigned memAccessFlags;

      public:
        SveScatterStoreSVMicroop(const char* mnem, ExtMachInst machInst,
                OpClass __opClass, RegIndex _dest, RegIndex _gp,
                RegIndex _base, RegIndex _offset, bool _offsetIs32,
                bool _offsetIsSigned, bool _offsetIsScaled, int _elemIndex,
                int _numElems, bool _firstFault) :
            MicroOp(mnem, machInst, MemWriteOp),
            dest(_dest), gp(_gp), base(_base), offset(_offset),
            offsetIs32(_offsetIs32), offsetIsSigned(_offsetIsSigned),
            offsetIsScaled(_offsetIsScaled), elemIndex(_elemIndex),
            numElems(_numElems), firstFault(_firstFault),
            memAccessFlags(ArmISA::MMU::AllowUnaligned)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[gp]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
            if (_opClass == MemReadOp && elemIndex == 0) {
                // The first micro-op is responsible for pinning the
                // destination and the fault status registers
                assert(_numDestRegs == 2);
                for (int i = 0; i < _numDestRegs; i++) {
                    auto dr = destRegIdx(i);
                    dr.setNumPinnedWrites(numElems - 1);
                    setDestRegIdx(i, dr);
                }
            }
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;

        void
        annotateFault(ArmISA::ArmFault *fault) override
        {
            
        }

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            // TODO: add suffix to transfer and base registers
            std::stringstream ss;
            printMnemonic(ss, "", false);
            ccprintf(ss, "{");
            printVecReg(ss, dest, true);
            ccprintf(ss, "}, ");
            printVecPredReg(ss, gp);
            if (_opClass == MemReadOp) {
                ccprintf(ss, "/z");
            }
            ccprintf(ss, ", [");
            printIntReg(ss, base);
            ccprintf(ss, ", ");
            printVecReg(ss, offset, true);
            ccprintf(ss, "] (uop elem %d tfer)", elemIndex);
            return ss.str();
        }
    };

    template <class RegElemType>
    class SveFirstFaultWritebackMicroop : public MicroOp
    {
      protected:
        typedef RegElemType TPElem;

        int numElems;
        StaticInst *macroOp;

      public:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

        SveFirstFaultWritebackMicroop(const char* mnem, ExtMachInst machInst,
                OpClass __opClass, int _numElems, StaticInst *_macroOp) :
            MicroOp(mnem, machInst, __opClass),
            numElems(_numElems), macroOp(_macroOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[PREDREG_UREG0]);
	setDestRegIdx(_numDestRegs++, vecPredRegClass[PREDREG_FFR]);
	_numTypedDestRegs[vecPredRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecPredRegClass[PREDREG_FFR]);
	flags[IsMicroop] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            ccprintf(ss, "%s", macroOp->disassemble(pc, symtab));
            ccprintf(ss, " (uop%d)", numElems);
            return ss.str();
        }
    };

    class SveGatherLoadCpySrcVecMicroop : public MicroOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      protected:
        RegIndex op1;

        StaticInst *macroOp;

      public:
        SveGatherLoadCpySrcVecMicroop(const char* mnem, ExtMachInst machInst,
                RegIndex _op1, StaticInst *_macroOp) :
            MicroOp(mnem, machInst, SimdAluOp), op1(_op1), macroOp(_macroOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[VECREG_UREG0]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            ccprintf(ss, "%s", macroOp->disassemble(pc, symtab));
            ccprintf(ss, " (uop src vec cpy)");
            return ss.str();
        }
    };

    template <class _Element>
    class SveIntrlv2Microop: public MicroOp
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;
        RegIndex dest;
        RegIndex op1;
        uint8_t numRegs;
        int regIndex;

        StaticInst *macroOp;

      public:
        SveIntrlv2Microop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _op1,
                uint8_t _numRegs, int _regIndex, StaticInst *_macroOp) :
            MicroOp(mnem, machInst, SimdAluOp), dest(_dest), op1(_op1),
            numRegs(_numRegs), regIndex(_regIndex), macroOp(_macroOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            ccprintf(ss, "%s", macroOp->disassemble(pc, symtab));
            ccprintf(ss, " (uop interleave)");
            return ss.str();
        }
    };

    template <class _Element>
    class SveIntrlv3Microop: public MicroOp
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;
        RegIndex dest;
        RegIndex op1;
        uint8_t numRegs;
        int regIndex;

        StaticInst *macroOp;

      public:
        SveIntrlv3Microop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _op1,
                uint8_t _numRegs, int _regIndex, StaticInst *_macroOp) :
            MicroOp(mnem, machInst, SimdAluOp), dest(_dest), op1(_op1),
            numRegs(_numRegs), regIndex(_regIndex), macroOp(_macroOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            ccprintf(ss, "%s", macroOp->disassemble(pc, symtab));
            ccprintf(ss, " (uop interleave)");
            return ss.str();
        }
    };

    template <class _Element>
    class SveIntrlv4Microop: public MicroOp
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;
        RegIndex dest;
        RegIndex op1;
        uint8_t numRegs;
        int regIndex;

        StaticInst *macroOp;

      public:
        SveIntrlv4Microop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, RegIndex _op1,
                uint8_t _numRegs, int _regIndex, StaticInst *_macroOp) :
            MicroOp(mnem, machInst, SimdAluOp), dest(_dest), op1(_op1),
            numRegs(_numRegs), regIndex(_regIndex), macroOp(_macroOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 0) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 1) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 2) % 32]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[(op1 + 3) % 32]);
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            ccprintf(ss, "%s", macroOp->disassemble(pc, symtab));
            ccprintf(ss, " (uop interleave)");
            return ss.str();
        }
    };

    template <class _Element>
    class SveDeIntrlv2Microop : public MicroOp
    {
      public:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;
        RegIndex dest;
        uint8_t numRegs;
        int regIndex;

        StaticInst *macroOp;

      public:
        SveDeIntrlv2Microop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, uint8_t _numRegs, int _regIndex,
                StaticInst *_macroOp) :
            MicroOp(mnem, machInst, SimdAluOp), dest(_dest),
            numRegs(_numRegs), regIndex(_regIndex), macroOp(_macroOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG0]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG1]);
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            ccprintf(ss, "%s", macroOp->disassemble(pc, symtab));
            ccprintf(ss, " (uop deinterleave)");
            return ss.str();
        }
    };

    template <class _Element>
    class SveDeIntrlv3Microop : public MicroOp
    {
      public:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;
        RegIndex dest;
        uint8_t numRegs;
        int regIndex;

        StaticInst *macroOp;

      public:
        SveDeIntrlv3Microop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, uint8_t _numRegs, int _regIndex,
                StaticInst *_macroOp) :
            MicroOp(mnem, machInst, SimdAluOp), dest(_dest),
            numRegs(_numRegs), regIndex(_regIndex), macroOp(_macroOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG0]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG2]);
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            ccprintf(ss, "%s", macroOp->disassemble(pc, symtab));
            ccprintf(ss, " (uop deinterleave)");
            return ss.str();
        }
    };

    template <class _Element>
    class SveDeIntrlv4Microop : public MicroOp
    {
      public:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      protected:
        typedef _Element Element;
        typedef _Element TPElem;
        RegIndex dest;
        uint8_t numRegs;
        int regIndex;

        StaticInst *macroOp;

      public:
        SveDeIntrlv4Microop(const char* mnem, ExtMachInst machInst,
                RegIndex _dest, uint8_t _numRegs, int _regIndex,
                StaticInst *_macroOp) :
            MicroOp(mnem, machInst, SimdAluOp), dest(_dest),
            numRegs(_numRegs), regIndex(_regIndex), macroOp(_macroOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG0]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[INTRLVREG3]);
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override
        {
            std::stringstream ss;
            ccprintf(ss, "%s", macroOp->disassemble(pc, symtab));
            ccprintf(ss, " (uop deinterleave)");
            return ss.str();
        }
    };

    /**
     * Static instruction class for "gem5op".
     */
    class Gem5Op64 : public PredOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        /// Constructor.
        Gem5Op64(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    /**
     * Static instruction class for "gem5op".
     */
    class Gem5Op : public PredOp
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

      public:
        /// Constructor.
        Gem5Op(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

class AESE : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AESE(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AESD : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AESD(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AESMC : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AESMC(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AESIMC : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  public:
    // Constructor
    AESIMC(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1C : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA1C(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1P : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA1P(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1M : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA1M(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1H : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA1H(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1SU0 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA1SU0(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1SU1 : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA1SU1(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA256H : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA256H(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA256H2 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA256H2(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA256SU0 : public RegRegOp
{
  private:
    RegId srcRegIdxArr[15]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA256SU0(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA256SU1 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[19]; RegId destRegIdxArr[4];

  public:
    // Constructor
    SHA256SU1(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AESE64 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AESE64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AESD64 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AESD64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AESMC64 : public RegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AESMC64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class AESIMC64 : public RegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    AESIMC64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1C64 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA1C64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1P64 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA1P64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1M64 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA1M64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1H64 : public RegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA1H64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1SU064 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA1SU064(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA1SU164 : public RegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA1SU164(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA256H64 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA256H64(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA256H264 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA256H264(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA256SU064 : public RegRegOp
{
  private:
    RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA256SU064(ExtMachInst machInst, RegIndex _dest, RegIndex _op1);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

class SHA256SU164 : public RegRegRegOp
{
  private:
    RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

  public:
    // Constructor
    SHA256SU164(ExtMachInst machInst, RegIndex _dest,
                   RegIndex _op1, RegIndex _op2);
    Fault execute(ExecContext *, trace::InstRecord *) const override;
};

namespace Aarch64
{
    StaticInstPtr decodeDataProcImm(ExtMachInst machInst);
    StaticInstPtr decodeBranchExcSys(const Decoder &dec, ExtMachInst machInst);
    StaticInstPtr decodeLoadsStores(ExtMachInst machInst);
    StaticInstPtr decodeDataProcReg(ExtMachInst machInst);

    template <typename DecoderFeatures>
    StaticInstPtr decodeFpAdvSIMD(ExtMachInst machInst);
    StaticInstPtr decodeFp(ExtMachInst machInst);
    template <typename DecoderFeatures>
    StaticInstPtr decodeAdvSIMD(ExtMachInst machInst);
    StaticInstPtr decodeAdvSIMDScalar(ExtMachInst machInst);

    StaticInstPtr decodeSveInt(ExtMachInst machInst);
    StaticInstPtr decodeSveFp(ExtMachInst machInst);
    StaticInstPtr decodeSveMem(ExtMachInst machInst);

    StaticInstPtr decodeGem5Ops(ExtMachInst machInst);
}

namespace Aarch64
{
    // AdvSIMD three same
    template <typename DecoderFeatures>
    StaticInstPtr decodeNeon3Same(ExtMachInst machInst);
    // AdvSIMD three same Extra
    template <typename DecoderFeatures>
    StaticInstPtr decodeNeon3SameExtra(ExtMachInst machInst);
    // AdvSIMD three different
    inline StaticInstPtr decodeNeon3Diff(ExtMachInst machInst);
    // AdvSIMD two-reg misc
    inline StaticInstPtr decodeNeon2RegMisc(ExtMachInst machInst);
    // AdvSIMD across lanes
    inline StaticInstPtr decodeNeonAcrossLanes(ExtMachInst machInst);
    // AdvSIMD copy
    inline StaticInstPtr decodeNeonCopy(ExtMachInst machInst);
    // AdvSIMD vector x indexed element
    template <typename DecoderFeatures>
    StaticInstPtr decodeNeonIndexedElem(ExtMachInst machInst);
    // AdvSIMD modified immediate
    inline StaticInstPtr decodeNeonModImm(ExtMachInst machInst);
    // AdvSIMD shift by immediate
    inline StaticInstPtr decodeNeonShiftByImm(ExtMachInst machInst);
    // AdvSIMD TBL/TBX
    inline StaticInstPtr decodeNeonTblTbx(ExtMachInst machInst);
    // AdvSIMD ZIP/UZP/TRN
    inline StaticInstPtr decodeNeonZipUzpTrn(ExtMachInst machInst);
    // AdvSIMD EXT
    inline StaticInstPtr decodeNeonExt(ExtMachInst machInst);

    // AdvSIMD scalar three same
    inline StaticInstPtr decodeNeonSc3Same(ExtMachInst machInst);
    // AdvSIMD scalar three same extra
    inline StaticInstPtr decodeNeonSc3SameExtra(ExtMachInst machInst);
    // AdvSIMD scalar three different
    inline StaticInstPtr decodeNeonSc3Diff(ExtMachInst machInst);
    // AdvSIMD scalar two-reg misc
    inline StaticInstPtr decodeNeonSc2RegMisc(ExtMachInst machInst);
    // AdvSIMD scalar pairwise
    inline StaticInstPtr decodeNeonScPwise(ExtMachInst machInst);
    // AdvSIMD scalar copy
    inline StaticInstPtr decodeNeonScCopy(ExtMachInst machInst);
    // AdvSIMD scalar x indexed element
    inline StaticInstPtr decodeNeonScIndexedElem(ExtMachInst machInst);
    // AdvSIMD scalar shift by immediate
    inline StaticInstPtr decodeNeonScShiftByImm(ExtMachInst machInst);

    // AdvSIMD load/store
    inline StaticInstPtr decodeNeonMem(ExtMachInst machInst);
}

namespace Aarch64
{
    StaticInstPtr decodeSveIntArithBinPred(ExtMachInst machInst);
    StaticInstPtr decodeSveIntReduc(ExtMachInst machInst);
    StaticInstPtr decodeSveShiftByImmPred(ExtMachInst machInst);
    StaticInstPtr decodeSveIntArithUnaryPred(ExtMachInst machInst);
    StaticInstPtr decodeSveIntMulAdd(ExtMachInst machInst);
    StaticInstPtr decodeSveIntArithUnpred(ExtMachInst machInst);
    StaticInstPtr decodeSveIntLogUnpred(ExtMachInst machInst);
    StaticInstPtr decodeSveIndexGen(ExtMachInst machInst);
    StaticInstPtr decodeSveStackAlloc(ExtMachInst machInst);
    StaticInstPtr decodeSveShiftByImmUnpred(ExtMachInst machInst);
    StaticInstPtr decodeSveCompVecAddr(ExtMachInst machInst);
    StaticInstPtr decodeSveIntMiscUnpred(ExtMachInst machInst);
    StaticInstPtr decodeSveElemCount(ExtMachInst machInst);
    StaticInstPtr decodeSveLogMaskImm(ExtMachInst machInst);
    StaticInstPtr decodeSveIntWideImmPred(ExtMachInst machInst);
    StaticInstPtr decodeSvePermExtract(ExtMachInst machInst);
    StaticInstPtr decodeSvePermUnpred(ExtMachInst machInst);
    StaticInstPtr decodeSvePermPredicates(ExtMachInst machInst);
    StaticInstPtr decodeSvePermIntlv(ExtMachInst machInst);
    StaticInstPtr decodeSvePermPred(ExtMachInst machInst);
    StaticInstPtr decodeSveSelVec(ExtMachInst machInst);
    StaticInstPtr decodeSveIntCmpVec(ExtMachInst machInst);
    StaticInstPtr decodeSveIntCmpUImm(ExtMachInst machInst);
    StaticInstPtr decodeSveIntCmpSImm(ExtMachInst machInst);
    StaticInstPtr decodeSvePredGen(ExtMachInst machInst);
    StaticInstPtr decodeSvePredCount(ExtMachInst machInst);
    StaticInstPtr decodeSveIntCmpSca(ExtMachInst machInst);
    StaticInstPtr decodeSveIntWideImmUnpred(ExtMachInst machInst);

    StaticInstPtr decodeSveMultiplyAddUnpred(ExtMachInst machInst);
    StaticInstPtr decodeSveMultiplyIndexed(ExtMachInst machInst);

    StaticInstPtr decodeSveFpFastReduc(ExtMachInst machInst);
    StaticInstPtr decodeSveFpUnaryUnpred(ExtMachInst machInst);
    StaticInstPtr decodeSveFpCmpZero(ExtMachInst machInst);
    StaticInstPtr decodeSveFpAccumReduc(ExtMachInst machInst);
    StaticInstPtr decodeSveFpArithUnpred(ExtMachInst machInst);
    StaticInstPtr decodeSveFpArithPred(ExtMachInst machInst);
    StaticInstPtr decodeSveFpUnaryPred(ExtMachInst machInst);
    StaticInstPtr decodeSveFpCmpVec(ExtMachInst machInst);
    StaticInstPtr decodeSveFpFusedMulAdd(ExtMachInst machInst);
    StaticInstPtr decodeSveFpCplxAdd(ExtMachInst machInst);
    StaticInstPtr decodeSveFpCplxMulAddVec(ExtMachInst machInst);
    StaticInstPtr decodeSveFpMulAddIndexed(ExtMachInst machInst);
    StaticInstPtr decodeSveFpCplxMulAddIndexed(ExtMachInst machInst);
    StaticInstPtr decodeSveFpMulIndexed(ExtMachInst machInst);

    StaticInstPtr decodeSveMemGather32(ExtMachInst machInst);
    StaticInstPtr decodeSveMemContigLoad(ExtMachInst machInst);
    StaticInstPtr decodeSveMemGather64(ExtMachInst machInst);
    StaticInstPtr decodeSveMemStore(ExtMachInst machInst);
}


    template<template <typename T> class Base>
    StaticInstPtr
    newNeonMemInst(const unsigned size,
                   const ExtMachInst &machInst,
                   const RegIndex dest, const RegIndex ra,
                   const uint32_t imm, const unsigned extraMemFlags)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, ra, imm, extraMemFlags);
          case 1:
            return new Base<uint16_t>(machInst, dest, ra, imm, extraMemFlags);
          case 2:
            return new Base<uint32_t>(machInst, dest, ra, imm, extraMemFlags);
          case 3:
            return new Base<uint64_t>(machInst, dest, ra, imm, extraMemFlags);
          default:
            panic("Unrecognized width %d for Neon mem inst.\n", (1 << size));
        }
    }

    template<template <typename T> class Base>
    StaticInstPtr
    newNeonMixInst(const unsigned size,
                   const ExtMachInst &machInst,
                   const RegIndex dest, const RegIndex op1,
                   const uint32_t step)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, step);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, step);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, step);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, step);
          default:
            panic("Unrecognized width %d for Neon mem inst.\n", (1 << size));
        }
    }


    StaticInstPtr
    decodeNeonMem(ExtMachInst machInst);
    StaticInstPtr
    decodeNeonData(ExtMachInst machInst);
    StaticInstPtr
    decodeAdvancedSIMD(ExtMachInst machInst);
    
    bool
    wrongVLdmStmRegs(RegIndex start_reg, uint8_t count, bool single);
    StaticInstPtr
    decodeExtensionRegLoadStore(ExtMachInst machInst);
    
    StaticInstPtr
    decodeShortFpTransfer(ExtMachInst machInst);
    RegIndex decodeFpVd(ExtMachInst machInst, uint32_t size, bool isInt);
    RegIndex decodeFpVm(ExtMachInst machInst, uint32_t size, bool isInt);
    RegIndex decodeFpVn(ExtMachInst machInst, uint32_t size);
    
    StaticInstPtr
    decodeVfpData(ExtMachInst machInst);
    
    StaticInstPtr
    decodeMcrMrc14(ExtMachInst machInst);
    
    StaticInstPtr decodeMcrMrc14(ExtMachInst machInst);
    StaticInstPtr decodeMcrMrc15(ExtMachInst machInst);
    
    StaticInstPtr
    decodeMcrrMrrc15(ExtMachInst machInst);
    
    StaticInstPtr
    decodeCryptoAES(ExtMachInst machInst);
    StaticInstPtr
    decodeCryptoThreeRegSHA(ExtMachInst machInst);
    StaticInstPtr
    decodeCryptoTwoRegSHA(ExtMachInst machInst);
    
// ArmUnconditional::armUnconditional(([], {}))

// ArmMultAndMultAcc::armMultAndMultAcc(([], {}))

// ArmSyncMem::armSyncMem(([], {}))

// Unknown::unknown(([], {}))

// AddrMode3::addrMode3(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcReg::armDataProcReg(([], {}))

// ArmMsrMrs::armMsrMrs(([], {}))

// ArmBxClz::armBxClz(([], {}))

// ArmBlxReg::armBlxReg(([], {}))

// Unknown::unknown(([], {}))

// Crc32::crc32(([], {}))

// ArmSatAddSub::armSatAddSub(([], {}))

// ArmERet::armERet(([], {}))

// ArmBkptHlt::armBkptHlt(([], {}))

// ArmSmcHyp::armSmcHyp(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmHalfWordMultAndMultAcc::armHalfWordMultAndMultAcc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcImm::armDataProcImm(([], {}))

// ArmMisc::armMisc(([], {}))

// Unknown::unknown(([], {}))

// AddrMode2::addrMode2((['True'], {}))

// AddrMode2::addrMode2((['False'], {}))

// ArmParallelAddSubtract::armParallelAddSubtract(([], {}))

// ArmPackUnpackSatReverse::armPackUnpackSatReverse(([], {}))

// ArmSignedMultiplies::armSignedMultiplies(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// ArmBBlxImm::armBBlxImm(([], {}))

// ArmBlBlxImm::armBlBlxImm(([], {}))

// Unknown::unknown(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStore(([], {}))

// Mcrr15::Mcrr15(([], {}))

// Mrrc15::Mrrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VfpData::vfpData(([], {}))

// Unknown::unknown(([], {}))

// Gem5Op::gem5op(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Svc::svc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Aarch64::aarch64(([], {}))

// Unknown::unknown(([], {}))

// Thumb16ShiftAddSubMoveCmp::thumb16ShiftAddMoveCmp(([], {}))

// Thumb16DataProcessing::thumb16DataProcessing(([], {}))

// Thumb16SpecDataAndBx::thumb16SpecDataAndBx(([], {}))

// Thumb16MemLit::thumb16MemLit(([], {}))

// Thumb16MemReg::thumb16MemReg(([], {}))

// Thumb16MemImm::thumb16MemImm(([], {}))

// Thumb16Adr::thumb16Adr(([], {}))

// Thumb16AddSp::thumb16AddSp(([], {}))

// Thumb16Misc::thumb16Misc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16MacroMem::thumb16MacroMem(([], {}))

// Thumb16CondBranchAndSvc::thumb16CondBranchAndSvc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16UncondBranch::thumb16UncondBranch(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32SrsRfe::thumb32SrsRfe(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// Thumb32LdrStrDExTbh::thumb32LdrStrDExTbh(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcShiftReg::thumb32DataProcShiftReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// Gem5Op::gem5op(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::ThumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// Mcrr15::Mcrr15(([], {}))

// WarnUnimpl::mcrr(([], {}))

// Mrrc15::Mrrc15(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcModImm::thumb32DataProcModImm(([], {}))

// Thumb32DataProcPlainBin::thumb32DataProcPlainBin(([], {}))

// Unknown::unknown(([], {}))

// Thumb32BranchesAndMiscCtrl::thumb32BranchesAndMiscCtrl(([], {}))

// Unknown::unknown(([], {}))

// Thumb32StoreSingle::thumb32StoreSingle(([], {}))

// ThumbNeonMem::thumbNeonMem(([], {}))

// Unknown::unknown(([], {}))

// LoadByteMemoryHints::loadByteMemoryHints(([], {}))

// LoadHalfwordMemoryHints::loadHalfwordMemoryHints(([], {}))

// Thumb32LoadWord::thumb32LoadWord(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32MulMulAccAndAbsDiff::thumb32MulMulAccAndAbsDiff(([], {}))

// Thumb32LongMulMulAccAndDiv::thumb32LongMulMulAccAndDiv(([], {}))

// Thumb32DataProcReg::thumb32DataProcReg(([], {}))

// Thumb32NeonSIMD::thumb32NeonSIMD(([], {}))

// Thumb32NeonSIMD::thumb32NeonSIMD(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// Gem5Op::gem5op(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::thumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// DecoderFault::decoderFault(([], {}))

// IllegalExec::illegalExec(([], {}))

// DebugStep::debugStep(([], {}))
