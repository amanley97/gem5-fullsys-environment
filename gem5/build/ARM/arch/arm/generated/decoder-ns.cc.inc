// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   arm/isa/main.isa

#if !defined(__SPLIT) || (__SPLIT == 1)

    Movz::Movz(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegImmImmOp("movz", machInst, IntAluOp,
                       _dest, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Movk::Movk(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegImmImmOp("movk", machInst, IntAluOp,
                       _dest, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Movn::Movn(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegImmImmOp("movn", machInst, IntAluOp,
                       _dest, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    CAS64::CAS64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("cas", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASA64::CASA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casa", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASAL64::CASAL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casal", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASL64::CASL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casl", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASB::CASB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casb", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASAB::CASAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casab", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASALB::CASALB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casalb", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASLB::CASLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("caslb", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASH::CASH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("cash", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASAH::CASAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casah", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASALH::CASALH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casalh", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASLH::CASLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("caslh", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CAS32::CAS32(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("cas", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASA32::CASA32(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casa", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASAL32::CASAL32(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casal", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASL32::CASL32(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("casl", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASP64::CASP64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryAtomicPair64("casp", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASPA64::CASPA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryAtomicPair64("caspa", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASPAL64::CASPAL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryAtomicPair64("caspal", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASPL64::CASPL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryAtomicPair64("caspl", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASP32::CASP32(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryAtomicPair64("casp", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASPA32::CASPA32(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryAtomicPair64("caspa", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASPAL32::CASPAL32(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryAtomicPair64("caspal", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    CASPL32::CASPL32(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryAtomicPair64("caspl", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result2) ? RegId() : intRegClass[result2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        flags[IsStore] = false;
        flags[IsLoad] = false;
    }

    LDADDB::LDADDB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDLB::LDADDLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDAB::LDADDAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDLAB::LDADDLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDH::LDADDH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDLH::LDADDLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDAH::LDADDAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDLAH::LDADDLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddlah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADD::LDADD(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldadd", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDL::LDADDL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDA::LDADDA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldadda", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDLA::LDADDLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADD64::LDADD64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldadd64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDL64::LDADDL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDA64::LDADDA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldadda64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDADDLA64::LDADDLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaddla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRB::LDCLRB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRLB::LDCLRLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRAB::LDCLRAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRLAB::LDCLRLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRH::LDCLRH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRLH::LDCLRLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRAH::LDCLRAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRLAH::LDCLRLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrlah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLR::LDCLR(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclr", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRL::LDCLRL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRA::LDCLRA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclra", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRLA::LDCLRLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLR64::LDCLR64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclr64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRL64::LDCLRL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRA64::LDCLRA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclra64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDCLRLA64::LDCLRLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldclrla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORB::LDEORB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORLB::LDEORLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORAB::LDEORAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORLAB::LDEORLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORH::LDEORH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORLH::LDEORLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORAH::LDEORAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORLAH::LDEORLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorlah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEOR::LDEOR(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeor", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORL::LDEORL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORA::LDEORA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeora", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORLA::LDEORLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEOR64::LDEOR64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeor64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORL64::LDEORL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORA64::LDEORA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeora64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDEORLA64::LDEORLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldeorla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETB::LDSETB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETLB::LDSETLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETAB::LDSETAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETLAB::LDSETLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETH::LDSETH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldseth", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETLH::LDSETLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETAH::LDSETAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETLAH::LDSETLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetlah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSET::LDSET(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldset", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETL::LDSETL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETA::LDSETA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldseta", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETLA::LDSETLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSET64::LDSET64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldset64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETL64::LDSETL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETA64::LDSETA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldseta64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSETLA64::LDSETLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsetla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXB::LDSMAXB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXLB::LDSMAXLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXAB::LDSMAXAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXLAB::LDSMAXLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXH::LDSMAXH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXLH::LDSMAXLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXAH::LDSMAXAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXLAH::LDSMAXLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxlah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAX::LDSMAX(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmax", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXL::LDSMAXL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXA::LDSMAXA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxa", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXLA::LDSMAXLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAX64::LDSMAX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmax64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXL64::LDSMAXL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXA64::LDSMAXA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxa64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMAXLA64::LDSMAXLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmaxla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINB::LDSMINB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINLB::LDSMINLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINAB::LDSMINAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINLAB::LDSMINLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINH::LDSMINH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINLH::LDSMINLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINAH::LDSMINAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINLAH::LDSMINLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminlah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMIN::LDSMIN(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmin", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINL::LDSMINL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINA::LDSMINA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmina", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINLA::LDSMINLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMIN64::LDSMIN64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmin64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINL64::LDSMINL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINA64::LDSMINA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsmina64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDSMINLA64::LDSMINLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldsminla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXB::LDUMAXB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXLB::LDUMAXLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXAB::LDUMAXAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXLAB::LDUMAXLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXH::LDUMAXH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXLH::LDUMAXLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXAH::LDUMAXAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXLAH::LDUMAXLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxlah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAX::LDUMAX(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumax", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXL::LDUMAXL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXA::LDUMAXA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxa", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXLA::LDUMAXLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAX64::LDUMAX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumax64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXL64::LDUMAXL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXA64::LDUMAXA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxa64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMAXLA64::LDUMAXLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumaxla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINB::LDUMINB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINLB::LDUMINLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINAB::LDUMINAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINLAB::LDUMINLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINH::LDUMINH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINLH::LDUMINLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINAH::LDUMINAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINLAH::LDUMINLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminlah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMIN::LDUMIN(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumin", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINL::LDUMINL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINA::LDUMINA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumina", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINLA::LDUMINLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMIN64::LDUMIN64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumin64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINL64::LDUMINL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINA64::LDUMINA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldumina64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LDUMINLA64::LDUMINLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("lduminla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STADDB::STADDB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("staddb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STADDLB::STADDLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("staddlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STADDH::STADDH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("staddh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STADDLH::STADDLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("staddlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STADD::STADD(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stadd", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STADDL::STADDL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("staddl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STADD64::STADD64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stadd64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STADDL64::STADDL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("staddl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STCLRB::STCLRB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stclrb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STCLRLB::STCLRLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stclrlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STCLRH::STCLRH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stclrh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STCLRLH::STCLRLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stclrlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STCLR::STCLR(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stclr", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STCLRL::STCLRL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stclrl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STCLR64::STCLR64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stclr64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STCLRL64::STCLRL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stclrl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STEORB::STEORB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("steorb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STEORLB::STEORLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("steorlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STEORH::STEORH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("steorh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STEORLH::STEORLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("steorlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STEOR::STEOR(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("steor", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STEORL::STEORL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("steorl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STEOR64::STEOR64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("steor64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STEORL64::STEORL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("steorl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSETB::STSETB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsetb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSETLB::STSETLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsetlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSETAB::STSETAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsetab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSETLAB::STSETLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsetlab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSETH::STSETH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stseth", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSETLH::STSETLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsetlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSET::STSET(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stset", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSETL::STSETL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsetl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSET64::STSET64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stset64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSETL64::STSETL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsetl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMAXB::STSMAXB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmaxb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMAXLB::STSMAXLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmaxlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMAXH::STSMAXH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmaxh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMAXLH::STSMAXLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmaxlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMAX::STSMAX(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmax", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMAXL::STSMAXL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmaxl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMAX64::STSMAX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmax64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMAXL64::STSMAXL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmaxl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMINB::STSMINB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsminb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMINLB::STSMINLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsminlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMINH::STSMINH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsminh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMINLH::STSMINLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsminlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMIN::STSMIN(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmin", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMINL::STSMINL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsminl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMIN64::STSMIN64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsmin64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STSMINL64::STSMINL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stsminl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMAXB::STUMAXB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumaxb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMAXLB::STUMAXLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumaxlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMAXH::STUMAXH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumaxh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMAXLH::STUMAXLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumaxlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMAX::STUMAX(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumax", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMAXL::STUMAXL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumaxl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMAX64::STUMAX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumax64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMAXL64::STUMAXL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumaxl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMINB::STUMINB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stuminb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMINLB::STUMINLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stuminlb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMINH::STUMINH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stuminh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMINLH::STUMINLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stuminlh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMIN::STUMIN(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumin", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMINL::STUMINL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stuminl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMIN64::STUMIN64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stumin64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    STUMINL64::STUMINL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stuminl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPB::SWPB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPLB::SWPLB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swplb", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPAB::SWPAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPLAB::SWPLAB(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swplab", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPH::SWPH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swph", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPLH::SWPLH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swplh", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPAH::SWPAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPLAH::SWPLAH(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swplah", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWP::SWP(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swp", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPL::SWPL(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpl", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPA::SWPA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpa", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPLA::SWPLA(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpla", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWP64::SWP64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swp64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsStore] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPL64::SWPL64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpl64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPA64::SWPA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpa64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    SWPLA64::SWPLA64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("swpla64", machInst, MemWriteOp,
                          _dest,  _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	flags[IsAtomic] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        isXZR = false;
        uint32_t r2 = dest;
        flags[IsStore] = false;
        flags[IsLoad] = false;
        if (r2 == 31) {
            isXZR = true;
        }
    }

    LOAD_IMM_PY_AY_WY_SN_UN_SZ4Acc::LOAD_IMM_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 1) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UN_SZ4::LOAD_IMM_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 1) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc::LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UN_SZ4::LOAD_REG_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UN_SZ4Acc::LOAD_IMM_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UN_SZ4::LOAD_IMM_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc::LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UN_SZ4::LOAD_REG_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UN_SZ4Acc::LOAD_IMM_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UN_SZ4::LOAD_IMM_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc::LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UN_SZ4::LOAD_REG_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UN_SZ4Acc::LOAD_IMM_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UN_SZ4::LOAD_IMM_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc::LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UN_SZ4::LOAD_REG_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SN_UN_SZ4::LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SN_UN_SZ4::LOAD_REG_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SN_UN_SZ4::LOAD_IMM_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SN_UN_SZ4::LOAD_REG_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UY_SZ4Acc::LOAD_IMM_PY_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UY_SZ4::LOAD_IMM_PY_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc::LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UY_SZ4::LOAD_REG_PY_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UY_SZ4Acc::LOAD_IMM_PY_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UY_SZ4::LOAD_IMM_PY_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc::LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UY_SZ4::LOAD_REG_PY_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UY_SZ4Acc::LOAD_IMM_PN_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UY_SZ4::LOAD_IMM_PN_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc::LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UY_SZ4::LOAD_REG_PN_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UY_SZ4Acc::LOAD_IMM_PN_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UY_SZ4::LOAD_IMM_PN_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc::LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UY_SZ4::LOAD_REG_PN_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SN_UY_SZ4::LOAD_IMM_PN_AY_WN_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UY_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UY_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SN_UY_SZ4::LOAD_REG_PN_AY_WN_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UY_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SN_UY_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UY_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SN_UY_SZ4::LOAD_IMM_PN_AN_WN_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UY_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UY_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SN_UY_SZ4::LOAD_REG_PN_AN_WN_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UY_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SN_UY_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UY_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UN_SZ1Acc::LOAD_IMM_PY_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UN_SZ1::LOAD_IMM_PY_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc::LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UN_SZ1::LOAD_REG_PY_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UN_SZ1Acc::LOAD_IMM_PY_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UN_SZ1::LOAD_IMM_PY_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc::LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UN_SZ1::LOAD_REG_PY_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UN_SZ1Acc::LOAD_IMM_PN_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UN_SZ1::LOAD_IMM_PN_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc::LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UN_SZ1::LOAD_REG_PN_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UN_SZ1Acc::LOAD_IMM_PN_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UN_SZ1::LOAD_IMM_PN_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc::LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UN_SZ1::LOAD_REG_PN_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SN_UN_SZ1::LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SN_UN_SZ1::LOAD_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SN_UN_SZ1::LOAD_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SN_UN_SZ1::LOAD_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UY_SZ1Acc::LOAD_IMM_PY_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UY_SZ1::LOAD_IMM_PY_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc::LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UY_SZ1::LOAD_REG_PY_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UY_SZ1Acc::LOAD_IMM_PY_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UY_SZ1::LOAD_IMM_PY_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc::LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UY_SZ1::LOAD_REG_PY_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UY_SZ1Acc::LOAD_IMM_PN_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UY_SZ1::LOAD_IMM_PN_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc::LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UY_SZ1::LOAD_REG_PN_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UY_SZ1Acc::LOAD_IMM_PN_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UY_SZ1::LOAD_IMM_PN_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc::LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UY_SZ1::LOAD_REG_PN_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SN_UY_SZ1::LOAD_IMM_PN_AY_WN_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UY_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UY_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SN_UY_SZ1::LOAD_REG_PN_AY_WN_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UY_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SN_UY_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UY_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SN_UY_SZ1::LOAD_IMM_PN_AN_WN_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UY_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UY_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SN_UY_SZ1::LOAD_REG_PN_AN_WN_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UY_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SN_UY_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UY_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SY_UN_SZ1Acc::LOAD_IMM_PY_AY_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SY_UN_SZ1::LOAD_IMM_PY_AY_WY_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc::LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SY_UN_SZ1::LOAD_REG_PY_AY_WY_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SY_UN_SZ1Acc::LOAD_IMM_PY_AN_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SY_UN_SZ1::LOAD_IMM_PY_AN_WY_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc::LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SY_UN_SZ1::LOAD_REG_PY_AN_WY_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SY_UN_SZ1Acc::LOAD_IMM_PN_AY_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SY_UN_SZ1::LOAD_IMM_PN_AY_WY_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc::LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SY_UN_SZ1::LOAD_REG_PN_AY_WY_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SY_UN_SZ1Acc::LOAD_IMM_PN_AN_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SY_UN_SZ1::LOAD_IMM_PN_AN_WY_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc::LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SY_UN_SZ1::LOAD_REG_PN_AN_WY_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UN_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SY_UN_SZ1::LOAD_IMM_PN_AY_WN_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SY_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SY_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SY_UN_SZ1::LOAD_REG_PN_AY_WN_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SY_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SY_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SY_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SY_UN_SZ1::LOAD_IMM_PN_AN_WN_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SY_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SY_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SY_UN_SZ1::LOAD_REG_PN_AN_WN_SY_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SY_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SY_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SY_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SY_UY_SZ1Acc::LOAD_IMM_PY_AY_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SY_UY_SZ1::LOAD_IMM_PY_AY_WY_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc::LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SY_UY_SZ1::LOAD_REG_PY_AY_WY_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SY_UY_SZ1Acc::LOAD_IMM_PY_AN_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SY_UY_SZ1::LOAD_IMM_PY_AN_WY_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc::LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SY_UY_SZ1::LOAD_REG_PY_AN_WY_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SY_UY_SZ1Acc::LOAD_IMM_PN_AY_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SY_UY_SZ1::LOAD_IMM_PN_AY_WY_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc::LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SY_UY_SZ1::LOAD_REG_PN_AY_WY_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SY_UY_SZ1Acc::LOAD_IMM_PN_AN_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SY_UY_SZ1::LOAD_IMM_PN_AN_WY_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc::LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SY_UY_SZ1::LOAD_REG_PN_AN_WY_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SY_UY_SZ1::LOAD_IMM_PN_AY_WN_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SY_UY_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SY_UY_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SY_UY_SZ1::LOAD_REG_PN_AY_WN_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SY_UY_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SY_UY_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SY_UY_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SY_UY_SZ1::LOAD_IMM_PN_AN_WN_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SY_UY_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SY_UY_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SY_UY_SZ1::LOAD_REG_PN_AN_WN_SY_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SY_UY_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SY_UY_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SY_UY_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UN_SZ2Acc::LOAD_IMM_PY_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UN_SZ2::LOAD_IMM_PY_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc::LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UN_SZ2::LOAD_REG_PY_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UN_SZ2Acc::LOAD_IMM_PY_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UN_SZ2::LOAD_IMM_PY_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc::LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UN_SZ2::LOAD_REG_PY_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UN_SZ2Acc::LOAD_IMM_PN_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UN_SZ2::LOAD_IMM_PN_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc::LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UN_SZ2::LOAD_REG_PN_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UN_SZ2Acc::LOAD_IMM_PN_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UN_SZ2::LOAD_IMM_PN_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc::LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UN_SZ2::LOAD_REG_PN_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SN_UN_SZ2::LOAD_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SN_UN_SZ2::LOAD_REG_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SN_UN_SZ2::LOAD_IMM_PN_AN_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SN_UN_SZ2::LOAD_REG_PN_AN_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SN_UN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UY_SZ2Acc::LOAD_IMM_PY_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SN_UY_SZ2::LOAD_IMM_PY_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc::LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SN_UY_SZ2::LOAD_REG_PY_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UY_SZ2Acc::LOAD_IMM_PY_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SN_UY_SZ2::LOAD_IMM_PY_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc::LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SN_UY_SZ2::LOAD_REG_PY_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UY_SZ2Acc::LOAD_IMM_PN_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SN_UY_SZ2::LOAD_IMM_PN_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc::LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SN_UY_SZ2::LOAD_REG_PN_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UY_SZ2Acc::LOAD_IMM_PN_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SN_UY_SZ2::LOAD_IMM_PN_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc::LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SN_UY_SZ2::LOAD_REG_PN_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SN_UY_SZ2::LOAD_IMM_PN_AY_WN_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UY_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SN_UY_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SN_UY_SZ2::LOAD_REG_PN_AY_WN_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UY_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SN_UY_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SN_UY_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SN_UY_SZ2::LOAD_IMM_PN_AN_WN_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UY_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SN_UY_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SN_UY_SZ2::LOAD_REG_PN_AN_WN_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UY_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SN_UY_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SN_UY_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SY_UN_SZ2Acc::LOAD_IMM_PY_AY_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SY_UN_SZ2::LOAD_IMM_PY_AY_WY_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc::LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SY_UN_SZ2::LOAD_REG_PY_AY_WY_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SY_UN_SZ2Acc::LOAD_IMM_PY_AN_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SY_UN_SZ2::LOAD_IMM_PY_AN_WY_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc::LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SY_UN_SZ2::LOAD_REG_PY_AN_WY_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SY_UN_SZ2Acc::LOAD_IMM_PN_AY_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SY_UN_SZ2::LOAD_IMM_PN_AY_WY_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc::LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SY_UN_SZ2::LOAD_REG_PN_AY_WY_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SY_UN_SZ2Acc::LOAD_IMM_PN_AN_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SY_UN_SZ2::LOAD_IMM_PN_AN_WY_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc::LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SY_UN_SZ2::LOAD_REG_PN_AN_WY_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UN_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SY_UN_SZ2::LOAD_IMM_PN_AY_WN_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SY_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SY_UN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SY_UN_SZ2::LOAD_REG_PN_AY_WN_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SY_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SY_UN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SY_UN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SY_UN_SZ2::LOAD_IMM_PN_AN_WN_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SY_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SY_UN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SY_UN_SZ2::LOAD_REG_PN_AN_WN_SY_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SY_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SY_UN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SY_UN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SY_UY_SZ2Acc::LOAD_IMM_PY_AY_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AY_WY_SY_UY_SZ2::LOAD_IMM_PY_AY_WY_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc::LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AY_WY_SY_UY_SZ2::LOAD_REG_PY_AY_WY_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SY_UY_SZ2Acc::LOAD_IMM_PY_AN_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PY_AN_WY_SY_UY_SZ2::LOAD_IMM_PY_AN_WY_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PY_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc::LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PY_AN_WY_SY_UY_SZ2::LOAD_REG_PY_AN_WY_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PY_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SY_UY_SZ2Acc::LOAD_IMM_PN_AY_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WY_SY_UY_SZ2::LOAD_IMM_PN_AY_WY_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc::LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WY_SY_UY_SZ2::LOAD_REG_PN_AY_WY_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SY_UY_SZ2Acc::LOAD_IMM_PN_AN_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WY_SY_UY_SZ2::LOAD_IMM_PN_AN_WY_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc::LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WY_SY_UY_SZ2::LOAD_REG_PN_AN_WY_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WY_SY_UY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AY_WN_SY_UY_SZ2::LOAD_IMM_PN_AY_WN_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AY_WN_SY_UY_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AY_WN_SY_UY_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AY_WN_SY_UY_SZ2::LOAD_REG_PN_AY_WN_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SY_UY_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AY_WN_SY_UY_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AY_WN_SY_UY_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_PN_AN_WN_SY_UY_SZ2::LOAD_IMM_PN_AN_WN_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LOAD_IMM_PN_AN_WN_SY_UY_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_PN_AN_WN_SY_UY_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_PN_AN_WN_SY_UY_SZ2::LOAD_REG_PN_AN_WN_SY_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SY_UY_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_PN_AN_WN_SY_UY_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_PN_AN_WN_SY_UY_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMMD_PY_AY_WY_SN_UN_SZ4Acc::LOAD_IMMD_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_PY_AY_WY_SN_UN_SZ4::LOAD_IMMD_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_PY_AY_WY_SN_UN_SZ4Acc::LOAD_REGD_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_PY_AY_WY_SN_UN_SZ4::LOAD_REGD_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_PY_AN_WY_SN_UN_SZ4Acc::LOAD_IMMD_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_PY_AN_WY_SN_UN_SZ4::LOAD_IMMD_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_PY_AN_WY_SN_UN_SZ4Acc::LOAD_REGD_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_PY_AN_WY_SN_UN_SZ4::LOAD_REGD_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_PN_AY_WY_SN_UN_SZ4Acc::LOAD_IMMD_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_PN_AY_WY_SN_UN_SZ4::LOAD_IMMD_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_PN_AY_WY_SN_UN_SZ4Acc::LOAD_REGD_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_PN_AY_WY_SN_UN_SZ4::LOAD_REGD_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_PN_AN_WY_SN_UN_SZ4Acc::LOAD_IMMD_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_PN_AN_WY_SN_UN_SZ4::LOAD_IMMD_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_PN_AN_WY_SN_UN_SZ4Acc::LOAD_REGD_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_PN_AN_WY_SN_UN_SZ4::LOAD_REGD_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_PN_AY_WN_SN_UN_SZ4::LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_PN_AY_WN_SN_UN_SZ4::LOAD_REGD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_PN_AN_WN_SN_UN_SZ4::LOAD_IMMD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_PN_AN_WN_SN_UN_SZ4::LOAD_REGD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#endif
    }

    RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8Acc::RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, MemReadOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8::RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, IntAluOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PY_AY_WY_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8Acc::RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, MemReadOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8::RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, IntAluOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PY_AY_WN_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8Acc::RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, MemReadOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8::RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, IntAluOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PY_AN_WY_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8Acc::RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, MemReadOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8::RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, IntAluOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PY_AN_WN_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8Acc::RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, MemReadOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8::RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, IntAluOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PN_AY_WY_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8Acc::RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, MemReadOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8::RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, IntAluOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PN_AY_WN_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8Acc::RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, MemReadOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8::RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, IntAluOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PN_AN_WY_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8Acc::RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, MemReadOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8::RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _base, int _mode, bool _wb) :
        RfeOp("rfe", machInst, IntAluOp,
                       (RegIndex)_base, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_PN_AN_WN_SN_UN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, int_reg::Ureg0, int_reg::Ureg1, int_reg::Ureg2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    PLD_LOAD_REG_PN_AN_WN_SN_UN_SZ1::PLD_LOAD_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("pld", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLD_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_IMM_PN_AN_WN_SN_UN_SZ1::PLD_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("pld", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new PLD_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLD_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_REG_PN_AY_WN_SN_UN_SZ1::PLD_LOAD_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("pld", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLD_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_IMM_PN_AY_WN_SN_UN_SZ1::PLD_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("pld", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new PLD_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLD_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_REG_PN_AN_WN_SN_UN_SZ1::PLDW_LOAD_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("pldw", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLDW_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_IMM_PN_AN_WN_SN_UN_SZ1::PLDW_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("pldw", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new PLDW_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLDW_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_REG_PN_AY_WN_SN_UN_SZ1::PLDW_LOAD_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("pldw", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLDW_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_IMM_PN_AY_WN_SN_UN_SZ1::PLDW_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("pldw", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new PLDW_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLDW_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_REG_PN_AN_WN_SN_UN_SZ1::PLI_LOAD_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("pli", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLI_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_IMM_PN_AN_WN_SN_UN_SZ1::PLI_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("pli", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new PLI_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLI_LOAD_IMM_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_REG_PN_AY_WN_SN_UN_SZ1::PLI_LOAD_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("pli", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            RegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, int_reg::Pc,
                                         int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            RegIndex wbIndexReg = int_reg::Ureg0;
            uops[0] = new MicroUopRegMov(machInst, int_reg::Ureg0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLI_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            RegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_IMM_PN_AY_WN_SN_UN_SZ1::PLI_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("pli", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new PLI_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLI_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4::LDREX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrex", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDREX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2::LDREXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrexh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDREXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1::LDREXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldrexb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDREXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4::LDREXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("ldrexd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDREXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDA_LOAD_IMM_PN_AY_WN_SN_UN_SZ4::LDA_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("lda", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDA_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDA_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDAH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2::LDAH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldah", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDAH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDAH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDAB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1::LDAB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldab", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDAB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDAB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDAEX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4::LDAEX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldaex", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDAEX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDAEX_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDAEXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2::LDAEXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldaexh", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDAEXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDAEXH_LOAD_IMM_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDAEXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1::LDAEXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("ldaexb", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new LDAEXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDAEXB_LOAD_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDAEXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4::LDAEXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("ldaexd", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDAEXD_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VLDR_LOAD_IMM_PN_AY_WN_SN_UN_SZ4::VLDR_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("vldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVectorElem] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new VLDR_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new VLDR_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    VLDR_LOAD_IMM_PN_AN_WN_SN_UN_SZ4::VLDR_LOAD_IMM_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("vldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVectorElem] = true;;
        [[maybe_unused]] bool conditional = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            uops[0] = new VLDR_LOAD_IMM_PN_AN_WN_SN_UN_SZ4(machInst, int_reg::Ureg0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(
                    machInst, int_reg::Pc, int_reg::Ureg0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == int_reg::Sp && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new VLDR_LOAD_IMM_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    VLDR_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4::VLDR_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("vldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest2) / 4) * NumVecElemPerVecReg) + (dest2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VLDR_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VLDR_LOAD_IMMD_PN_AN_WN_SN_UN_SZ4::VLDR_LOAD_IMMD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("vldr", machInst, MemReadOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest2) / 4) * NumVecElemPerVecReg) + (dest2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VLDR_LOAD_IMMD_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRAA_PREAcc::LDRAA_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldraa", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRAA_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRAA_PRE::LDRAA_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldraa", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRAA_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRAA_REG::LDRAA_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldraa", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRAA_REG(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRAB_PREAcc::LDRAB_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrab", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRAB_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRAB_PRE::LDRAB_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrab", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRAB_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRAB_REG::LDRAB_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldrab", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRAB_REG(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_IMM::LDRB64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldrb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_PREAcc::LDRB64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_PRE::LDRB64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrb", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_POSTAcc::LDRB64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_POST::LDRB64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrb", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_REG::LDRB64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldrb", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_IMM::LDRSBW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldrsb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_PREAcc::LDRSBW64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_PRE::LDRSBW64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsb", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_POSTAcc::LDRSBW64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_POST::LDRSBW64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsb", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_REG::LDRSBW64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldrsb", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_IMM::LDRSBX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldrsb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_PREAcc::LDRSBX64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_PRE::LDRSBX64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsb", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_POSTAcc::LDRSBX64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_POST::LDRSBX64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsb", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_REG::LDRSBX64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldrsb", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_IMM::LDRH64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldrh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_PREAcc::LDRH64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_PRE::LDRH64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrh", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_POSTAcc::LDRH64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_POST::LDRH64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrh", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_REG::LDRH64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldrh", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_IMM::LDRSHW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldrsh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_PREAcc::LDRSHW64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_PRE::LDRSHW64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsh", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_POSTAcc::LDRSHW64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_POST::LDRSHW64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsh", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_REG::LDRSHW64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldrsh", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_IMM::LDRSHX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldrsh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_PREAcc::LDRSHX64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_PRE::LDRSHX64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsh", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_POSTAcc::LDRSHX64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_POST::LDRSHX64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsh", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_REG::LDRSHX64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldrsh", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_IMM::LDRSW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldrsw", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_PREAcc::LDRSW64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsw", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_PRE::LDRSW64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldrsw", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_POSTAcc::LDRSW64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsw", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_POST::LDRSW64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldrsw", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_REG::LDRSW64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldrsw", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_IMM::LDRW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_PREAcc::LDRW64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_PRE::LDRW64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_POSTAcc::LDRW64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_POST::LDRW64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_REG::LDRW64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_IMM::LDRX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_PREAcc::LDRX64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_PRE::LDRX64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_POSTAcc::LDRX64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_POST::LDRX64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_REG::LDRX64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_IMM::LDRBFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_PREAcc::LDRBFP64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_PRE::LDRBFP64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_POSTAcc::LDRBFP64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_POST::LDRBFP64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_REG::LDRBFP64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_IMM::LDRHFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_PREAcc::LDRHFP64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_PRE::LDRHFP64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_POSTAcc::LDRHFP64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_POST::LDRHFP64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_REG::LDRHFP64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_IMM::LDRSFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_PREAcc::LDRSFP64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_PRE::LDRSFP64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_POSTAcc::LDRSFP64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_POST::LDRSFP64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_REG::LDRSFP64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_IMM::LDRDFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_PREAcc::LDRDFP64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_PRE::LDRDFP64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_POSTAcc::LDRDFP64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_POST::LDRDFP64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_REG::LDRDFP64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_IMM::PRFM64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("prfm", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_REG::PRFM64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("prfm", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_LIT::PRFM64_LIT(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm) :
         ArmISA::MemoryLiteral64("prfm", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsDataPrefetch] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFUM64_IMM::PRFUM64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("prfum", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFUM64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURB64_IMM::LDURB64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldurb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSBW64_IMM::LDURSBW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldursb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSBX64_IMM::LDURSBX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldursb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURH64_IMM::LDURH64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldurh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSHW64_IMM::LDURSHW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldursh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSHX64_IMM::LDURSHX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldursh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSW64_IMM::LDURSW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldursw", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURW64_IMM::LDURW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURX64_IMM::LDURX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURBFP64_IMM::LDURBFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURHFP64_IMM::LDURHFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSFP64_IMM::LDURSFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURDFP64_IMM::LDURDFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRB64_IMM::LDTRB64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtrb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSBW64_IMM::LDTRSBW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtrsb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSBX64_IMM::LDTRSBX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtrsb", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRH64_IMM::LDTRH64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtrh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSHW64_IMM::LDTRSHW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtrsh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSHX64_IMM::LDTRSHX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtrsh", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSW64_IMM::LDTRSW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtrsw", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRW64_IMM::LDTRW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRX64_IMM::LDTRX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("ldtr", machInst, MemReadOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSWL64_LIT::LDRSWL64_LIT(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm) :
         ArmISA::MemoryLiteral64("ldrsw", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSWL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRWL64_LIT::LDRWL64_LIT(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm) :
         ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRWL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRXL64_LIT::LDRXL64_LIT(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm) :
         ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRXL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_LIT::LDRSFP64_LIT(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm) :
         ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_LIT::LDRDFP64_LIT(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm) :
         ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDARX64::LDARX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("ldar", machInst, MemReadOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARW64::LDARW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("ldar", machInst, MemReadOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARH64::LDARH64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("ldarh", machInst, MemReadOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARB64::LDARB64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("ldarb", machInst, MemReadOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRX64::LDAXRX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaxr", machInst, MemReadOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRW64::LDAXRW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaxr", machInst, MemReadOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRH64::LDAXRH64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaxrh", machInst, MemReadOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRB64::LDAXRB64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldaxrb", machInst, MemReadOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDXRX64::LDXRX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldxr", machInst, MemReadOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
    }

    LDXRW64::LDXRW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldxr", machInst, MemReadOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
    }

    LDXRH64::LDXRH64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldxrh", machInst, MemReadOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
    }

    LDXRB64::LDXRB64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("ldxrb", machInst, MemReadOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
    }

    LDAPRX64::LDAPRX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("ldapr", machInst, MemReadOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAPRW64::LDAPRW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("ldapr", machInst, MemReadOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAPRH64::LDAPRH64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("ldaprh", machInst, MemReadOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAPRB64::LDAPRB64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("ldaprb", machInst, MemReadOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    MicroLdPairUop::MicroLdPairUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldp_uop", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdPairFp8Uop::MicroLdPairFp8Uop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldp_fp8_uop", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecRegClass[dest2]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16Uop::MicroLdFp16Uop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryImm64("ldfp16_uop", machInst, MemReadOp,
                        _dest, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16RegUop::MicroLdFp16RegUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("ldfp16reg_uop", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new MicroLdFp16RegUop(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDAXPW64::LDAXPW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldaxp", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDAXPX64::LDAXPX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldaxp", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDXPW64::LDXPW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldxp", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDXPX64::LDXPX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldxp", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXImmUop::MicroLdrXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryImm64("ldrxi_uop", machInst, MemReadOp,
                        _dest, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXRegUop::MicroLdrXRegUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryReg64("ldrxr_uop", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXLitUop::MicroLdrXLitUop(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryLiteral64("ldrxl_uop", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXImmUop::MicroLdrFpXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryImm64("ldrfpxi_uop", machInst, MemReadOp,
                        _dest, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXRegUop::MicroLdrFpXRegUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryReg64("ldrfpxr_uop", machInst, MemReadOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXLitUop::MicroLdrFpXLitUop(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryLiteral64("ldrfpxl_uop", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16LitUop::MicroLdFp16LitUop(ExtMachInst machInst,
            RegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryLiteral64("ldfp16_lit__uop", machInst, MemReadOp,
                 (RegIndex)_dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDUXImmUop::MicroLdrDUXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldrduxi_uop", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDSXImmUop::MicroLdrDSXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldrdsxi_uop", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDFpXImmUop::MicroLdrDFpXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("ldrdfpxi_uop", machInst, MemReadOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecRegClass[dest2]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    Svc::Svc(ExtMachInst machInst, uint64_t _imm) :
        ImmOp("svc", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        // In AArch32 semihosting commands can be issued by either
        // SVC and HLT instructions. Another degree of freedom
        // is added by the operating mode (Arm or Thumb)
        auto semihost_imm = machInst.thumb? 0xAB :
                                            0x123456;
        if (_imm == semihost_imm) {
            flags[IsReadBarrier] = true;
            flags[IsWriteBarrier] = true;
        }
    }

    Hlt::Hlt(ExtMachInst machInst, uint64_t _imm) :
        ImmOp("hlt", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        // In AArch32 semihosting commands can be issued by either
        // SVC and HLT instructions. Another degree of freedom
        // is added by the operating mode (Arm or Thumb)
        auto semihost_imm = machInst.thumb? 0x3C :
                                            0xF000;
        if (_imm == semihost_imm) {
            flags[IsReadBarrier] = true;
            flags[IsWriteBarrier] = true;
        }
    }

    Smc::Smc(ExtMachInst machInst) :
        PredOp("smc", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_HCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Hvc::Hvc(ExtMachInst machInst, uint64_t _imm) :
        ImmOp("hvc", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_HCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Eret::Eret(ExtMachInst machInst) :
        PredOp("eret", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_ELR_HYP]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Crc32b::Crc32b(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("crc32b", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Crc32h::Crc32h(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("crc32h", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Crc32w::Crc32w(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("crc32w", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Crc32cb::Crc32cb(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("crc32cb", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Crc32ch::Crc32ch(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("crc32ch", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Crc32cw::Crc32cw(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("crc32cw", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MrsCpsr::MrsCpsr(ExtMachInst machInst, RegIndex _dest) :
        MrsOp("mrs", machInst, IntAluOp, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MrsSpsr::MrsSpsr(ExtMachInst machInst, RegIndex _dest) :
        MrsOp("mrs", machInst, IntAluOp, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MrsBankedReg::MrsBankedReg(ExtMachInst machInst, RegIndex _dest,
                                   uint8_t _sysM, bool _r) :
        MrsOp("mrs", machInst, IntAluOp, _dest),
        byteMask(_sysM), r(_r)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(decodeMrsMsrBankedIntRegIndex(byteMask, r)) ? RegId() : intRegClass[decodeMrsMsrBankedIntRegIndex(byteMask, r)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MsrBankedReg::MsrBankedReg(ExtMachInst machInst, RegIndex _op1,
                                   uint8_t _sysM, bool _r) :
        MsrRegOp("msr", machInst, IntAluOp, _op1, _sysM),
        r(_r)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(decodeMrsMsrBankedIntRegIndex(byteMask, r)) ? RegId() : intRegClass[decodeMrsMsrBankedIntRegIndex(byteMask, r)]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MsrCpsrReg::MsrCpsrReg(ExtMachInst machInst, RegIndex _op1,
                                   uint8_t mask) :
        MsrRegOp("msr", machInst, IntAluOp, _op1, mask)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MsrSpsrReg::MsrSpsrReg(ExtMachInst machInst, RegIndex _op1,
                                   uint8_t mask) :
        MsrRegOp("msr", machInst, IntAluOp, _op1, mask)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MsrCpsrImm::MsrCpsrImm(ExtMachInst machInst, uint32_t imm,
                                   uint8_t mask) :
        MsrImmOp("msr", machInst, IntAluOp, imm, mask)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MsrSpsrImm::MsrSpsrImm(ExtMachInst machInst, uint32_t imm,
                                   uint8_t mask) :
        MsrImmOp("msr", machInst, IntAluOp, imm, mask)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Rev::Rev(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("rev", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Rev16::Rev16(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("rev16", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Revsh::Revsh(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("revsh", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Rbit::Rbit(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("rbit", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Clz::Clz(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("clz", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Ssat::Ssat(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        RegImmRegShiftOp("ssat", machInst, IntAluOp,
                       _dest, _imm, _op1, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Usat::Usat(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        RegImmRegShiftOp("usat", machInst, IntAluOp,
                       _dest, _imm, _op1, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Ssat16::Ssat16(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1) :
        RegImmRegOp("ssat16", machInst, IntAluOp,
                       _dest, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Usat16::Usat16(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1) :
        RegImmRegOp("usat16", machInst, IntAluOp,
                       _dest, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sxtb::Sxtb(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1) :
        RegImmRegOp("sxtb", machInst, IntAluOp,
                       _dest, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sxtab::Sxtab(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   uint64_t _imm) :
        RegRegRegImmOp("sxtab", machInst, IntAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sxtb16::Sxtb16(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1) :
        RegImmRegOp("sxtb16", machInst, IntAluOp,
                       _dest, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sxtab16::Sxtab16(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   uint64_t _imm) :
        RegRegRegImmOp("sxtab16", machInst, IntAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sxth::Sxth(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1) :
        RegImmRegOp("sxth", machInst, IntAluOp,
                       _dest, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sxtah::Sxtah(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   uint64_t _imm) :
        RegRegRegImmOp("sxtah", machInst, IntAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Uxtb::Uxtb(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1) :
        RegImmRegOp("uxtb", machInst, IntAluOp,
                       _dest, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Uxtab::Uxtab(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   uint64_t _imm) :
        RegRegRegImmOp("uxtab", machInst, IntAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Uxtb16::Uxtb16(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1) :
        RegImmRegOp("uxtb16", machInst, IntAluOp,
                       _dest, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Uxtab16::Uxtab16(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   uint64_t _imm) :
        RegRegRegImmOp("uxtab16", machInst, IntAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Uxth::Uxth(ExtMachInst machInst, RegIndex _dest,
                                   uint64_t _imm, RegIndex _op1) :
        RegImmRegOp("uxth", machInst, IntAluOp,
                       _dest, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Uxtah::Uxtah(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   uint64_t _imm) :
        RegRegRegImmOp("uxtah", machInst, IntAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sel::Sel(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sel", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Ge]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Usad8::Usad8(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("usad8", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Usada8::Usada8(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3) :
        RegRegRegRegOp("usada8", machInst, IntAluOp,
                       _dest, _op1, _op2, _op3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op3) ? RegId() : intRegClass[op3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    BkptInst::BkptInst(ExtMachInst machInst) :
        PredOp("bkpt", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        ;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    NopInst::NopInst(ExtMachInst machInst) :
        ArmStaticInst("nop", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsNop] = true;;
    }

    YieldInst::YieldInst(ExtMachInst machInst) :
        PredOp("yield", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    WfeInst::WfeInst(ExtMachInst machInst) :
        PredOp("wfe", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR_EL3]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsUnverifiable] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    WfiInst::WfiInst(ExtMachInst machInst) :
        PredOp("wfi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_HCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR_EL3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsUnverifiable] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SevInst::SevInst(ExtMachInst machInst) :
        PredOp("sev", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSquashAfter] = true;
	flags[IsUnverifiable] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SevlInst::SevlInst(ExtMachInst machInst) :
        PredOp("sevl", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSquashAfter] = true;
	flags[IsUnverifiable] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    ItInst::ItInst(ExtMachInst machInst) :
        PredOp("it", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Unknown::Unknown(ExtMachInst machInst) :
        UnknownOp("unknown", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Ubfx::Ubfx(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegRegImmImmOp("ubfx", machInst, IntAluOp,
                       _dest, _op1, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sbfx::Sbfx(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegRegImmImmOp("sbfx", machInst, IntAluOp,
                       _dest, _op1, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Bfc::Bfc(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegRegImmImmOp("bfc", machInst, IntAluOp,
                       _dest, _op1, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Bfi::Bfi(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegRegImmImmOp("bfi", machInst, IntAluOp,
                       _dest, _op1, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Mrc14::Mrc14(ExtMachInst machInst, RegIndex _dest,
                                   MiscRegIndex _op1, uint64_t _imm) :
        RegMiscRegImmOp("mrc", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Mcr14::Mcr14(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1, uint64_t _imm) :
        MiscRegRegImmOp("mcr", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Mrc15::Mrc15(ExtMachInst machInst, RegIndex _dest,
                                   MiscRegIndex _op1, uint64_t _imm) :
        RegMiscRegImmOp("mrc", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Mcr15::Mcr15(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1, uint64_t _imm) :
        MiscRegRegImmOp("mcr", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Tlbi::Tlbi(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1, uint64_t _imm) :
        TlbiOp("mcr", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Mrrc15::Mrrc15(ExtMachInst machInst, MiscRegIndex op1,
                                   RegIndex dest, RegIndex dest2,
                                   uint32_t imm) :
        MrrcOp("mrrc", machInst, IntAluOp, op1, dest,
                       dest2, imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Mcrr15::Mcrr15(ExtMachInst machInst, RegIndex op1,
                                   RegIndex op2, MiscRegIndex dest,
                                   uint32_t imm) :
        McrrOp("mcrr", machInst, IntAluOp, op1, op2,
                       dest, imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Enterx::Enterx(ExtMachInst machInst) :
        PredOp("enterx", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Leavex::Leavex(ExtMachInst machInst) :
        PredOp("leavex", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Setend::Setend(ExtMachInst machInst, uint64_t _imm) :
        ImmOp("setend", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Clrex::Clrex(ExtMachInst machInst) :
        PredOp("clrex", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    McrDcimvac::McrDcimvac(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1, uint64_t _imm) :
        MiscRegRegImmOp("mcr", machInst, MemWriteOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    McrDccmvac::McrDccmvac(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1, uint64_t _imm) :
        MiscRegRegImmOp("mcr", machInst, MemWriteOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    McrDccmvau::McrDccmvau(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1, uint64_t _imm) :
        MiscRegRegImmOp("mcr", machInst, MemWriteOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    McrDccimvac::McrDccimvac(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1, uint64_t _imm) :
        MiscRegRegImmOp("mcr", machInst, MemWriteOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Isb::Isb(ExtMachInst machInst, uint64_t _imm) :
        ImmOp("isb", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Dsb::Dsb(ExtMachInst machInst, uint64_t _imm) :
        ImmOp("dsb", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsReadBarrier] = true;
	flags[IsSerializeAfter] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Dmb::Dmb(ExtMachInst machInst, uint64_t _imm) :
        ImmOp("dmb", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Dbg::Dbg(ExtMachInst machInst) :
        PredOp("dbg", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Cps::Cps(ExtMachInst machInst, uint64_t _imm) :
        ImmOp("cps", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Svc64::Svc64(ExtMachInst machInst, uint64_t _imm) :
        ImmOp64("svc", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
    }

    Hvc64::Hvc64(ExtMachInst machInst, uint64_t _imm) :
        ImmOp64("hvc", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR_EL3]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_HCR_EL2]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
    }

    Smc64::Smc64(ExtMachInst machInst, uint64_t _imm) :
        ImmOp64("smc", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR_EL3]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    Bfm64::Bfm64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegRegImmImmOp64("bfm", machInst, IntAluOp,
                       _dest, _op1, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Ubfm64::Ubfm64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegRegImmImmOp64("ubfm", machInst, IntAluOp,
                       _dest, _op1, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Sbfm64::Sbfm64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm1, uint64_t _imm2) :
        RegRegImmImmOp64("sbfm", machInst, IntAluOp,
                       _dest, _op1, _imm1, _imm2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Extr64::Extr64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   uint64_t _imm) :
        RegRegRegImmOp64("extr", machInst, IntAluOp,
                       _dest, _op1, _op2, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Unknown64::Unknown64(ExtMachInst machInst) :
        UnknownOp64("unknown", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        ;
    }

    Isb64::Isb64(ExtMachInst machInst) :
        ArmStaticInst("isb", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsSquashAfter] = true;;
    }

    Dsb64Local::Dsb64Local(ExtMachInst machInst) :
        ArmStaticInst("dsb", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsReadBarrier] = true;
	flags[IsSerializeAfter] = true;
	flags[IsWriteBarrier] = true;;
    }

    Dsb64Shareable::Dsb64Shareable(ExtMachInst machInst, bool dvm_enabled) :
        ArmStaticInst("dsb", machInst, IntAluOp),
        dvmEnabled(dvm_enabled)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_TLBINEEDSYNC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_TLBINEEDSYNC]);
	flags[IsReadBarrier] = true;
	flags[IsSerializeAfter] = true;
	flags[IsWriteBarrier] = true;;

        if (dvmEnabled) {
            flags[IsLoad] = true;
        }
    }

    Dmb64::Dmb64(ExtMachInst machInst) :
        ArmStaticInst("dmb", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    Clrex64::Clrex64(ExtMachInst machInst) :
        ArmStaticInst("clrex", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);;
    }

    Brk64::Brk64(ExtMachInst machInst, uint64_t _imm) :
        ImmOp64("brk", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsSerializeAfter] = true;;
    }

    Hlt64::Hlt64(ExtMachInst machInst, uint64_t _imm) :
        ImmOp64("hlt", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;

        // In AArch64 there is only one instruction for issuing
        // semhosting commands: HLT #0xF000
        if (_imm == 0xF000) {
            flags[IsReadBarrier] = true;
            flags[IsWriteBarrier] = true;
        }
    }

#endif
#if __SPLIT == 2

    STRB64_IMM::STRB64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("strb", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_PREAcc::STRB64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("strb", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_PRE::STRB64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("strb", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_POSTAcc::STRB64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("strb", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_POST::STRB64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("strb", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_REG::STRB64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("strb", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_IMM::STRH64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("strh", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_PREAcc::STRH64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("strh", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_PRE::STRH64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("strh", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_POSTAcc::STRH64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("strh", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_POST::STRH64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("strh", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_REG::STRH64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("strh", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_IMM::STRW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_PREAcc::STRW64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_PRE::STRW64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_POSTAcc::STRW64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_POST::STRW64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_REG::STRW64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_IMM::STRX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_PREAcc::STRX64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_PRE::STRX64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_POSTAcc::STRX64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_POST::STRX64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_REG::STRX64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_IMM::STRBFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_PREAcc::STRBFP64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_PRE::STRBFP64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_POSTAcc::STRBFP64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_POST::STRBFP64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_REG::STRBFP64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_IMM::STRHFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_PREAcc::STRHFP64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_PRE::STRHFP64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_POSTAcc::STRHFP64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_POST::STRHFP64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_REG::STRHFP64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_IMM::STRSFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_PREAcc::STRSFP64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_PRE::STRSFP64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_POSTAcc::STRSFP64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_POST::STRSFP64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_REG::STRSFP64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_IMM::STRDFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_PREAcc::STRDFP64_PREAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_PRE::STRDFP64_PRE(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_POSTAcc::STRDFP64_POSTAcc(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_POST::STRDFP64_POST(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_REG::STRDFP64_REG(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt) :
         ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURB64_IMM::STURB64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("sturb", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURH64_IMM::STURH64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("sturh", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURW64_IMM::STURW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURX64_IMM::STURX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURBFP64_IMM::STURBFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURHFP64_IMM::STURHFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURSFP64_IMM::STURSFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURDFP64_IMM::STURDFP64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRB64_IMM::STTRB64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("sttrb", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRH64_IMM::STTRH64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("sttrh", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRW64_IMM::STTRW64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("sttr", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRX64_IMM::STTRX64_IMM(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm) :
         ArmISA::MemoryImm64("sttr", machInst, MemWriteOp,
                        (RegIndex)_dest, (RegIndex)_base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLRX64::STLRX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("stlr", machInst, MemWriteOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRW64::STLRW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("stlr", machInst, MemWriteOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRH64::STLRH64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("stlrh", machInst, MemWriteOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRB64::STLRB64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base) :
         ArmISA::MemoryRaw64("stlrb", machInst, MemWriteOp, _dest, _base)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRX64::STLXRX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stlxr", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRW64::STLXRW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stlxr", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRH64::STLXRH64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stlxrh", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRB64::STLXRB64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stlxrb", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STXRX64::STXRX64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stxr", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRW64::STXRW64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stxr", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRH64::STXRH64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stxrh", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRB64::STXRB64(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _result) :
         ArmISA::MemoryEx64("stxrb", machInst, MemWriteOp,
                        _dest, _base, _result)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STLXPW64::STLXPW64(ExtMachInst machInst,
            RegIndex _result, RegIndex _dest, RegIndex _dest2,
            RegIndex _base, int64_t _imm) :
         ArmISA::MemoryDImmEx64("stlxp", machInst, MemWriteOp,
                        _result, _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
    }

    STLXPX64::STLXPX64(ExtMachInst machInst,
            RegIndex _result, RegIndex _dest, RegIndex _dest2,
            RegIndex _base, int64_t _imm) :
         ArmISA::MemoryDImmEx64("stlxp", machInst, MemWriteOp,
                        _result, _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
    }

    STXPW64::STXPW64(ExtMachInst machInst,
            RegIndex _result, RegIndex _dest, RegIndex _dest2,
            RegIndex _base, int64_t _imm) :
         ArmISA::MemoryDImmEx64("stxp", machInst, MemWriteOp,
                        _result, _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        assert(!0);
    }

    STXPX64::STXPX64(ExtMachInst machInst,
            RegIndex _result, RegIndex _dest, RegIndex _dest2,
            RegIndex _base, int64_t _imm) :
         ArmISA::MemoryDImmEx64("stxp", machInst, MemWriteOp,
                        _result, _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        assert(!0);
    }

    MicroStrXImmUop::MicroStrXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryImm64("strxi_uop", machInst, MemWriteOp,
                        _dest, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrXRegUop::MicroStrXRegUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryReg64("strxr_uop", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrFpXImmUop::MicroStrFpXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryImm64("strfpxi_uop", machInst, MemWriteOp,
                        _dest, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrFpXRegUop::MicroStrFpXRegUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryReg64("strfpxr_uop", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQBFpXImmUop::MicroStrQBFpXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryImm64("strqbfpxi_uop", machInst, MemWriteOp,
                        _dest, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQBFpXRegUop::MicroStrQBFpXRegUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryReg64("strqbfpxr_uop", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQTFpXImmUop::MicroStrQTFpXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryImm64("strqtfpxi_uop", machInst, MemWriteOp,
                        _dest, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQTFpXRegUop::MicroStrQTFpXRegUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _base, RegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryReg64("strqtfpxr_uop", machInst, MemWriteOp,
                        _dest, _base, _offset, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(offset) ? RegId() : intRegClass[offset]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrDXImmUop::MicroStrDXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("strdxi_uop", machInst, MemWriteOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrDFpXImmUop::MicroStrDFpXImmUop(ExtMachInst machInst,
            RegIndex _dest, RegIndex _dest2, RegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel) :
         ArmISA::MemoryDImm64("strdfpxi_uop", machInst, MemWriteOp,
                        _dest, _dest2, _base, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    STORE_IMM_PY_AY_WY_SN_UN_SZ4Acc::STORE_IMM_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UN_SZ4::STORE_IMM_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("str", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UN_SZ4Acc::STORE_REG_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UN_SZ4::STORE_REG_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("str", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UN_SZ4Acc::STORE_IMM_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UN_SZ4::STORE_IMM_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("str", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UN_SZ4Acc::STORE_REG_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UN_SZ4::STORE_REG_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("str", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UN_SZ4Acc::STORE_IMM_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UN_SZ4::STORE_IMM_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("str", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UN_SZ4Acc::STORE_REG_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UN_SZ4::STORE_REG_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("str", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UN_SZ4Acc::STORE_IMM_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UN_SZ4::STORE_IMM_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("str", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UN_SZ4Acc::STORE_REG_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UN_SZ4::STORE_REG_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("str", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WN_SN_UN_SZ4::STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WN_SN_UN_SZ4::STORE_REG_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WN_SN_UN_SZ4::STORE_IMM_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WN_SN_UN_SZ4::STORE_REG_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("str", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UY_SZ4Acc::STORE_IMM_PY_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UY_SZ4::STORE_IMM_PY_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UY_SZ4Acc::STORE_REG_PY_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UY_SZ4::STORE_REG_PY_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UY_SZ4Acc::STORE_IMM_PY_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UY_SZ4::STORE_IMM_PY_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UY_SZ4Acc::STORE_REG_PY_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UY_SZ4::STORE_REG_PY_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UY_SZ4Acc::STORE_IMM_PN_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UY_SZ4::STORE_IMM_PN_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UY_SZ4Acc::STORE_REG_PN_AY_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UY_SZ4::STORE_REG_PN_AY_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UY_SZ4Acc::STORE_IMM_PN_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UY_SZ4::STORE_IMM_PN_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UY_SZ4Acc::STORE_REG_PN_AN_WY_SN_UY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UY_SZ4::STORE_REG_PN_AN_WY_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WN_SN_UY_SZ4::STORE_IMM_PN_AY_WN_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WN_SN_UY_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WN_SN_UY_SZ4::STORE_REG_PN_AY_WN_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WN_SN_UY_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WN_SN_UY_SZ4::STORE_IMM_PN_AN_WN_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WN_SN_UY_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WN_SN_UY_SZ4::STORE_REG_PN_AN_WN_SN_UY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WN_SN_UY_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UN_SZ1Acc::STORE_IMM_PY_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UN_SZ1::STORE_IMM_PY_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UN_SZ1Acc::STORE_REG_PY_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UN_SZ1::STORE_REG_PY_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UN_SZ1Acc::STORE_IMM_PY_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UN_SZ1::STORE_IMM_PY_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UN_SZ1Acc::STORE_REG_PY_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UN_SZ1::STORE_REG_PY_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UN_SZ1Acc::STORE_IMM_PN_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UN_SZ1::STORE_IMM_PN_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UN_SZ1Acc::STORE_REG_PN_AY_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UN_SZ1::STORE_REG_PN_AY_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UN_SZ1Acc::STORE_IMM_PN_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UN_SZ1::STORE_IMM_PN_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UN_SZ1Acc::STORE_REG_PN_AN_WY_SN_UN_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UN_SZ1::STORE_REG_PN_AN_WY_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UN_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WN_SN_UN_SZ1::STORE_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WN_SN_UN_SZ1::STORE_REG_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WN_SN_UN_SZ1::STORE_IMM_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WN_SN_UN_SZ1::STORE_REG_PN_AN_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WN_SN_UN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UY_SZ1Acc::STORE_IMM_PY_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UY_SZ1::STORE_IMM_PY_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UY_SZ1Acc::STORE_REG_PY_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UY_SZ1::STORE_REG_PY_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UY_SZ1Acc::STORE_IMM_PY_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UY_SZ1::STORE_IMM_PY_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UY_SZ1Acc::STORE_REG_PY_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UY_SZ1::STORE_REG_PY_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UY_SZ1Acc::STORE_IMM_PN_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UY_SZ1::STORE_IMM_PN_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UY_SZ1Acc::STORE_REG_PN_AY_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UY_SZ1::STORE_REG_PN_AY_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UY_SZ1Acc::STORE_IMM_PN_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UY_SZ1::STORE_IMM_PN_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UY_SZ1Acc::STORE_REG_PN_AN_WY_SN_UY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UY_SZ1::STORE_REG_PN_AN_WY_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WN_SN_UY_SZ1::STORE_IMM_PN_AY_WN_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WN_SN_UY_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WN_SN_UY_SZ1::STORE_REG_PN_AY_WN_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WN_SN_UY_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WN_SN_UY_SZ1::STORE_IMM_PN_AN_WN_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WN_SN_UY_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WN_SN_UY_SZ1::STORE_REG_PN_AN_WN_SN_UY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strbt", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WN_SN_UY_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UN_SZ2Acc::STORE_IMM_PY_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UN_SZ2::STORE_IMM_PY_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UN_SZ2Acc::STORE_REG_PY_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UN_SZ2::STORE_REG_PY_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UN_SZ2Acc::STORE_IMM_PY_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UN_SZ2::STORE_IMM_PY_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UN_SZ2Acc::STORE_REG_PY_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UN_SZ2::STORE_REG_PY_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UN_SZ2Acc::STORE_IMM_PN_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UN_SZ2::STORE_IMM_PN_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UN_SZ2Acc::STORE_REG_PN_AY_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UN_SZ2::STORE_REG_PN_AY_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UN_SZ2Acc::STORE_IMM_PN_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UN_SZ2::STORE_IMM_PN_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UN_SZ2Acc::STORE_REG_PN_AN_WY_SN_UN_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UN_SZ2::STORE_REG_PN_AN_WY_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UN_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WN_SN_UN_SZ2::STORE_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WN_SN_UN_SZ2::STORE_REG_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WN_SN_UN_SZ2::STORE_IMM_PN_AN_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WN_SN_UN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WN_SN_UN_SZ2::STORE_REG_PN_AN_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WN_SN_UN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UY_SZ2Acc::STORE_IMM_PY_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AY_WY_SN_UY_SZ2::STORE_IMM_PY_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UY_SZ2Acc::STORE_REG_PY_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AY_WY_SN_UY_SZ2::STORE_REG_PY_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UY_SZ2Acc::STORE_IMM_PY_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PY_AN_WY_SN_UY_SZ2::STORE_IMM_PY_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UY_SZ2Acc::STORE_REG_PY_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PY_AN_WY_SN_UY_SZ2::STORE_REG_PY_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PY_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UY_SZ2Acc::STORE_IMM_PN_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WY_SN_UY_SZ2::STORE_IMM_PN_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UY_SZ2Acc::STORE_REG_PN_AY_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WY_SN_UY_SZ2::STORE_REG_PN_AY_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UY_SZ2Acc::STORE_IMM_PN_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WY_SN_UY_SZ2::STORE_IMM_PN_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UY_SZ2Acc::STORE_REG_PN_AN_WY_SN_UY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WY_SN_UY_SZ2::STORE_REG_PN_AN_WY_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WY_SN_UY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AY_WN_SN_UY_SZ2::STORE_IMM_PN_AY_WN_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AY_WN_SN_UY_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AY_WN_SN_UY_SZ2::STORE_REG_PN_AY_WN_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AY_WN_SN_UY_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_PN_AN_WN_SN_UY_SZ2::STORE_IMM_PN_AN_WN_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_PN_AN_WN_SN_UY_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_PN_AN_WN_SN_UY_SZ2::STORE_REG_PN_AN_WN_SN_UY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryReg>("strht", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_PN_AN_WN_SN_UY_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8Acc::SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)) ? RegId() : intRegClass[int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8::SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PY_AY_WY_SN_UN_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PY_AY_WN_SN_UN_SZ8::SRS_STORE_IMM_PY_AY_WN_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)) ? RegId() : intRegClass[int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PY_AY_WN_SN_UN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8Acc::SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)) ? RegId() : intRegClass[int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8::SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PY_AN_WY_SN_UN_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PY_AN_WN_SN_UN_SZ8::SRS_STORE_IMM_PY_AN_WN_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)) ? RegId() : intRegClass[int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PY_AN_WN_SN_UN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8Acc::SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)) ? RegId() : intRegClass[int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8::SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PN_AY_WY_SN_UN_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PN_AY_WN_SN_UN_SZ8::SRS_STORE_IMM_PN_AY_WN_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)) ? RegId() : intRegClass[int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PN_AY_WN_SN_UN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8Acc::SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)) ? RegId() : intRegClass[int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8::SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PN_AN_WY_SN_UN_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              int_reg::regInMode((OperatingMode)regMode,
                                  int_reg::Sp),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_PN_AN_WN_SN_UN_SZ8::SRS_STORE_IMM_PN_AN_WN_SN_UN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb) :
         SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)) ? RegId() : intRegClass[int_reg::regInMode((OperatingMode)regMode, int_reg::Sp)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_PN_AN_WN_SN_UN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PY_AY_WY_SN_UN_SZ4Acc::STORE_IMMD_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PY_AY_WY_SN_UN_SZ4::STORE_IMMD_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PY_AY_WY_SN_UN_SZ4Acc::STORE_REGD_PY_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PY_AY_WY_SN_UN_SZ4::STORE_REGD_PY_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PY_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PY_AN_WY_SN_UN_SZ4Acc::STORE_IMMD_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PY_AN_WY_SN_UN_SZ4::STORE_IMMD_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPostIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PY_AN_WY_SN_UN_SZ4Acc::STORE_REGD_PY_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PY_AN_WY_SN_UN_SZ4::STORE_REGD_PY_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPostIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PY_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PN_AY_WY_SN_UN_SZ4Acc::STORE_IMMD_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PN_AY_WY_SN_UN_SZ4::STORE_IMMD_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PN_AY_WY_SN_UN_SZ4Acc::STORE_REGD_PN_AY_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PN_AY_WY_SN_UN_SZ4::STORE_REGD_PN_AY_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PN_AY_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PN_AN_WY_SN_UN_SZ4Acc::STORE_IMMD_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PN_AN_WY_SN_UN_SZ4::STORE_IMMD_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryPreIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PN_AN_WY_SN_UN_SZ4Acc::STORE_REGD_PN_AN_WY_SN_UN_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PN_AN_WY_SN_UN_SZ4::STORE_REGD_PN_AN_WY_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryPreIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PN_AN_WY_SN_UN_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PN_AY_WN_SN_UN_SZ4::STORE_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PN_AY_WN_SN_UN_SZ4::STORE_REGD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryDReg>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_PN_AN_WN_SN_UN_SZ4::STORE_IMMD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_PN_AN_WN_SN_UN_SZ4::STORE_REGD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index) :
         MemoryOffset<MemoryDReg>("strd", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (RegIndex)_index)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(index) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREX_STORE_IMM_PN_AY_WN_SN_UN_SZ4::STREX_STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm) :
         MemoryOffset<MemoryExImm>("strex", machInst, MemWriteOp,
                 (RegIndex)_result, (RegIndex)_dest,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREX_STORE_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2::STREXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm) :
         MemoryOffset<MemoryExImm>("strexh", machInst, MemWriteOp,
                 (RegIndex)_result, (RegIndex)_dest,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1::STREXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm) :
         MemoryOffset<MemoryExImm>("strexb", machInst, MemWriteOp,
                 (RegIndex)_result, (RegIndex)_dest,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4::STREXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryExDImm>("strexd", machInst, MemWriteOp,
                 (RegIndex)_result, (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, _result, _dest, _dest2,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STL_STORE_IMM_PN_AY_WN_SN_UN_SZ4::STL_STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("stl", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STL_STORE_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLH_STORE_IMM_PN_AY_WN_SN_UN_SZ2::STLH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("stlh", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STLH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLB_STORE_IMM_PN_AY_WN_SN_UN_SZ1::STLB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("stlb", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STLB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLEX_STORE_IMM_PN_AY_WN_SN_UN_SZ4::STLEX_STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm) :
         MemoryOffset<MemoryExImm>("stlex", machInst, MemWriteOp,
                 (RegIndex)_result, (RegIndex)_dest,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STLEX_STORE_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLEXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2::STLEXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm) :
         MemoryOffset<MemoryExImm>("stlexh", machInst, MemWriteOp,
                 (RegIndex)_result, (RegIndex)_dest,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STLEXH_STORE_IMM_PN_AY_WN_SN_UN_SZ2(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLEXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1::STLEXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm) :
         MemoryOffset<MemoryExImm>("stlexb", machInst, MemWriteOp,
                 (RegIndex)_result, (RegIndex)_dest,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STLEXB_STORE_IMM_PN_AY_WN_SN_UN_SZ1(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLEXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4::STLEXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryExDImm>("stlexd", machInst, MemWriteOp,
                 (RegIndex)_result, (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(result) ? RegId() : intRegClass[result]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STLEXD_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, _result, _dest, _dest2,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMM_PN_AY_WN_SN_UN_SZ4::VSTR_STORE_IMM_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("vstr", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMM_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMM_PN_AN_WN_SN_UN_SZ4::VSTR_STORE_IMM_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryImm>("vstr", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMM_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMMD_PN_AY_WN_SN_UN_SZ4::VSTR_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("vstr", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest2) / 4) * NumVecElemPerVecReg) + (dest2) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMMD_PN_AN_WN_SN_UN_SZ4::VSTR_STORE_IMMD_PN_AN_WN_SN_UN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm) :
         MemoryOffset<MemoryDImm>("vstr", machInst, MemWriteOp,
                 (RegIndex)_dest, (RegIndex)_dest2,
                 (RegIndex)_base, _add, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest2) / 4) * NumVecElemPerVecReg) + (dest2) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMMD_PN_AN_WN_SN_UN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    MicroLdrUop::MicroLdrUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("ldr_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroLdrRetUop::MicroLdrRetUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("ldr_ret_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroLdrFpUop::MicroLdrFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((ura) / 4) * NumVecElemPerVecReg) + (ura) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroLdrDBFpUop::MicroLdrDBFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((ura) / 4) * NumVecElemPerVecReg) + (ura) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroLdrDTFpUop::MicroLdrDTFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((ura) / 4) * NumVecElemPerVecReg) + (ura) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroStrUop::MicroStrUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("str_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroStrFpUop::MicroStrFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((ura) / 4) * NumVecElemPerVecReg) + (ura) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroStrDBFpUop::MicroStrDBFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((ura) / 4) * NumVecElemPerVecReg) + (ura) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroStrDTFpUop::MicroStrDTFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((ura) / 4) * NumVecElemPerVecReg) + (ura) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroLdr2Uop::MicroLdr2Uop(ExtMachInst machInst,
                                   RegIndex _dreg1,
                                   RegIndex _dreg2,
                                   RegIndex _base,
                                   bool _up,
                                   uint8_t _imm) :
        MicroMemPairOp("ldr2_uop", machInst, MemReadOp,
                       _dreg1, _dreg2, _base, _up, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest2) ? RegId() : intRegClass[dest2]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroAddiUop::MicroAddiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm) :
        MicroIntImmOp("addi_uop", machInst, IntAluOp,
                       _ura, _urb, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroAddXiUop::MicroAddXiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm) :
        MicroIntImmXOp("addxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroAddXiSpAlignUop::MicroAddXiSpAlignUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm) :
        MicroIntImmXOp("addxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroSubiUop::MicroSubiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm) :
        MicroIntImmOp("subi_uop", machInst, IntAluOp,
                       _ura, _urb, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroSubXiUop::MicroSubXiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm) :
        MicroIntImmXOp("subxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroAddUop::MicroAddUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        MicroIntRegOp("add_uop", machInst, IntAluOp,
                       _ura, _urb, _urc, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroSubUop::MicroSubUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        MicroIntRegOp("sub_uop", machInst, IntAluOp,
                       _ura, _urb, _urc, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroAddXERegUop::MicroAddXERegUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   ArmExtendType _type, uint32_t _shiftAmt) :
        MicroIntRegXOp("addxr_uop", machInst, IntAluOp,
                       _ura, _urb, _urc, _type, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroUopRegMov::MicroUopRegMov(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb)
        : MicroIntMov("uopReg_uop", machInst, IntAluOp,
                         _ura, _urb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroUopRegMovRet::MicroUopRegMovRet(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb)
        : MicroIntMov("movret_uop", machInst, IntAluOp,
                         _ura, _urb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MicroUopSetPCCPSR::MicroUopSetPCCPSR(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   RegIndex _urc) :
          MicroSetPCCPSR("uopSet_uop", machInst, IntAluOp,
                           _ura, _urb, _urc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urc) ? RegId() : intRegClass[urc]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(ura) ? RegId() : intRegClass[ura]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(urb) ? RegId() : intRegClass[urb]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            flags[IsCondControl] = true;
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        } else {
            flags[IsUncondControl] = true;
        }
    }

LdmStm::LdmStm(ExtMachInst machInst, RegIndex rn,
        bool index, bool up, bool user, bool writeback, bool load,
        uint32_t reglist) :
    MacroMemOp("ldmstm", machInst, IntAluOp, rn,
                     index, up, user, writeback, load, reglist)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
        }
    }
}


LdpStp::LdpStp(const char *mnemonic, ExtMachInst machInst,
        uint32_t size, bool fp, bool load, bool noAlloc, bool signExt,
        bool exclusive, bool acrel, uint32_t imm, AddrMode mode,
        RegIndex rn, RegIndex rt, RegIndex rt2) :
    PairMemOp(mnemonic, machInst, IntAluOp, size,
                   fp, load, noAlloc, signExt, exclusive, acrel,
                   imm, mode, rn, rt, rt2)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
}

BigFpMemImm::BigFpMemImm(const char *mnemonic, ExtMachInst machInst,
        bool load, RegIndex dest, RegIndex base, int64_t imm) :
    BigFpMemImmOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
}

BigFpMemPre::BigFpMemPre(const char *mnemonic, ExtMachInst machInst,
        bool load, RegIndex dest, RegIndex base, int64_t imm) :
    BigFpMemPreOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
}

BigFpMemPost::BigFpMemPost(const char *mnemonic, ExtMachInst machInst,
        bool load, RegIndex dest, RegIndex base, int64_t imm) :
    BigFpMemPostOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
}

BigFpMemReg::BigFpMemReg(const char *mnemonic, ExtMachInst machInst,
        bool load, RegIndex dest, RegIndex base,
        RegIndex offset, ArmExtendType type, int64_t imm) :
    BigFpMemRegOp(mnemonic, machInst, IntAluOp, load, dest, base,
                   offset, type, imm)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
}

BigFpMemLit::BigFpMemLit(const char *mnemonic, ExtMachInst machInst,
        RegIndex dest, int64_t imm) :
    BigFpMemLitOp(mnemonic, machInst, IntAluOp, dest, imm)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
}

VldMult::VldMult(ExtMachInst machInst, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm) :
    VldMultOp("vldmult", machInst, IntAluOp, width,
                   rn, vd, regs, inc, size, align, rm)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
        }
    }
}

VldSingle::VldSingle(ExtMachInst machInst, bool all, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm, unsigned lane) :
    VldSingleOp("vldsingle", machInst, IntAluOp, all, width,
                   rn, vd, regs, inc, size, align, rm, lane)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
        }
    }
}

VstMult::VstMult(ExtMachInst machInst, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm) :
    VstMultOp("vstmult", machInst, IntAluOp, width,
                   rn, vd, regs, inc, size, align, rm)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
        }
    }
}

VstSingle::VstSingle(ExtMachInst machInst, bool all, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm, unsigned lane) :
    VstSingleOp("vstsingle", machInst, IntAluOp, all, width,
                   rn, vd, regs, inc, size, align, rm, lane)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
        }
    }
}

VLdmStm::VLdmStm(ExtMachInst machInst, RegIndex rn,
        RegIndex vd, bool single, bool up, bool writeback, bool load,
        uint32_t offset) :
    MacroVFPMemOp("vldmstm", machInst, IntAluOp, rn,
                   vd, single, up, writeback, load, offset)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    ;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
        }
    }
}


    AndImm::AndImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("and", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndImmCc::AndImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("ands", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndReg::AndReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("and", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AndRegCc::AndRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("ands", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AndRegReg::AndRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("and", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AndRegRegCc::AndRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("ands", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AndsImmPclr::AndsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("ands", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndsRegPclr::AndsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("ands", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorImm::EorImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("eor", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorImmCc::EorImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("eors", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorReg::EorReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("eor", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorRegCc::EorRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("eors", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorRegReg::EorRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("eor", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    EorRegRegCc::EorRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("eors", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    EorsImmPclr::EorsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("eors", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorsRegPclr::EorsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("eors", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubImm::SubImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("sub", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubImmCc::SubImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("subs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubReg::SubReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("sub", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubRegCc::SubRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("subs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubRegReg::SubRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("sub", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SubRegRegCc::SubRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("subs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SubsImmPclr::SubsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("subs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubsRegPclr::SubsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("subs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbImm::RsbImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("rsb", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbImmCc::RsbImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("rsbs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbReg::RsbReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("rsb", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbRegCc::RsbRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("rsbs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbRegReg::RsbRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("rsb", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    RsbRegRegCc::RsbRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("rsbs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    RsbsImmPclr::RsbsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("rsbs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbsRegPclr::RsbsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("rsbs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddImm::AddImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("add", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddImmCc::AddImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("adds", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddReg::AddReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("add", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddRegCc::AddRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("adds", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddRegReg::AddRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("add", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AddRegRegCc::AddRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("adds", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AddsImmPclr::AddsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("adds", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddsRegPclr::AddsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("adds", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdrImm::AdrImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("adr", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdrImmCc::AdrImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("adrs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcImm::AdcImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("adc", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcImmCc::AdcImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("adcs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcReg::AdcReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("adc", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdcRegCc::AdcRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("adcs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdcRegReg::AdcRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("adc", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AdcRegRegCc::AdcRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("adcs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AdcsImmPclr::AdcsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("adcs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcsRegPclr::AdcsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("adcs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcImm::SbcImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("sbc", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcImmCc::SbcImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("sbcs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcReg::SbcReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("sbc", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcRegCc::SbcRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("sbcs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcRegReg::SbcRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("sbc", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SbcRegRegCc::SbcRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("sbcs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SbcsImmPclr::SbcsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("sbcs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcsRegPclr::SbcsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("sbcs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscImm::RscImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("rsc", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscImmCc::RscImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("rscs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscReg::RscReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("rsc", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscRegCc::RscRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("rscs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscRegReg::RscRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("rsc", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    RscRegRegCc::RscRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("rscs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    RscsImmPclr::RscsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("rscs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscsRegPclr::RscsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("rscs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstImm::TstImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("tst", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstImmCc::TstImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("tsts", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstReg::TstReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("tst", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstRegCc::TstRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("tsts", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstRegReg::TstRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("tst", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    TstRegRegCc::TstRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("tsts", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    TstsImmPclr::TstsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("tsts", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstsRegPclr::TstsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("tsts", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqImm::TeqImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("teq", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqImmCc::TeqImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("teqs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqReg::TeqReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("teq", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqRegCc::TeqRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("teqs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqRegReg::TeqRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("teq", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    TeqRegRegCc::TeqRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("teqs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    TeqsImmPclr::TeqsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("teqs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqsRegPclr::TeqsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("teqs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpImm::CmpImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("cmp", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpImmCc::CmpImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("cmps", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpReg::CmpReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("cmp", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpRegCc::CmpRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("cmps", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpRegReg::CmpRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("cmp", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    CmpRegRegCc::CmpRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("cmps", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    CmpsImmPclr::CmpsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("cmps", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpsRegPclr::CmpsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("cmps", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnImm::CmnImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("cmn", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnImmCc::CmnImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("cmns", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnReg::CmnReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("cmn", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnRegCc::CmnRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("cmns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnRegReg::CmnRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("cmn", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    CmnRegRegCc::CmnRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("cmns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    CmnsImmPclr::CmnsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("cmns", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnsRegPclr::CmnsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("cmns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrImm::OrrImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("orr", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrImmCc::OrrImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("orrs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrReg::OrrReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("orr", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrRegCc::OrrRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("orrs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrRegReg::OrrRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("orr", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    OrrRegRegCc::OrrRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("orrs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    OrrsImmPclr::OrrsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("orrs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrsRegPclr::OrrsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("orrs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnImm::OrnImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("orn", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnImmCc::OrnImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("orns", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnReg::OrnReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("orn", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnRegCc::OrnRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("orns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnRegReg::OrnRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("orn", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    OrnRegRegCc::OrnRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("orns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    OrnsImmPclr::OrnsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("orns", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnsRegPclr::OrnsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("orns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovImm::MovImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("mov", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovImmCc::MovImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("movs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovReg::MovReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("mov", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (op2 == int_reg::Lr) {
                flags[IsReturn] = true;
            }
        }

    }

    MovRegCc::MovRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("movs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (dest == int_reg::Pc && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (op2 == int_reg::Lr) {
                flags[IsReturn] = true;
            }
        }

    }

    MovRegReg::MovRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("mov", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MovRegRegCc::MovRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("movs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MovsImmPclr::MovsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("movs", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovsRegPclr::MovsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("movs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicImm::BicImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("bic", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicImmCc::BicImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("bics", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicReg::BicReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("bic", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicRegCc::BicRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("bics", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicRegReg::BicRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("bic", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    BicRegRegCc::BicRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("bics", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    BicsImmPclr::BicsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("bics", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicsRegPclr::BicsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("bics", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnImm::MvnImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("mvn", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnImmCc::MvnImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("mvns", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnReg::MvnReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("mvn", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnRegCc::MvnRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("mvns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnRegReg::MvnRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("mvn", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MvnRegRegCc::MvnRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("mvns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MvnsImmPclr::MvnsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("mvns", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnsRegPclr::MvnsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("mvns", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtImm::MovtImm(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("movt", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtImmCc::MovtImmCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("movts", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtReg::MovtReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("movt", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtRegCc::MovtRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("movts", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtRegReg::MovtRegReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("movt", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MovtRegRegCc::MovtRegRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _shift,
                                   ArmShiftType _shiftType) :
        DataRegRegOp("movts", machInst, IntAluOp,
                       _dest, _op1, _op2, _shift, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(shift) ? RegId() : intRegClass[shift]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MovtsImmPclr::MovtsImmPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint32_t _imm,
                                   bool _rotC) :
        DataImmOp("movts", machInst, IntAluOp,
                       _dest, _op1, _imm, _rotC)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtsRegPclr::MovtsRegPclr(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("movts", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCTLR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QaddRegCc::QaddRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qadds", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qadd16Reg::Qadd16Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qadd16", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qadd8Reg::Qadd8Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qadd8", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QdaddRegCc::QdaddRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qdadds", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsubReg::QsubReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qsub", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsubRegCc::QsubRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qsubs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qsub16Reg::Qsub16Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qsub16", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qsub8Reg::Qsub8Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qsub8", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QdsubRegCc::QdsubRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qdsubs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QasxReg::QasxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qasx", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsaxReg::QsaxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("qsax", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Sadd8RegCc::Sadd8RegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("sadd8s", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Sadd16RegCc::Sadd16RegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("sadd16s", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Ssub8RegCc::Ssub8RegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("ssub8s", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Ssub16RegCc::Ssub16RegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("ssub16s", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SasxReg::SasxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("sasx", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SasxRegCc::SasxRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("sasxs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SsaxReg::SsaxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("ssax", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SsaxRegCc::SsaxRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("ssaxs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shadd8Reg::Shadd8Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("shadd8", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shadd16Reg::Shadd16Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("shadd16", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shsub8Reg::Shsub8Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("shsub8", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shsub16Reg::Shsub16Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("shsub16", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShasxReg::ShasxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("shasx", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShasxRegCc::ShasxRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("shasxs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShsaxReg::ShsaxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("shsax", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShsaxRegCc::ShsaxRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("shsaxs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqadd16Reg::Uqadd16Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uqadd16", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqadd8Reg::Uqadd8Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uqadd8", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqsub16Reg::Uqsub16Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uqsub16", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqsub8Reg::Uqsub8Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uqsub8", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UqasxReg::UqasxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uqasx", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UqsaxReg::UqsaxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uqsax", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uadd16RegCc::Uadd16RegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uadd16s", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uadd8RegCc::Uadd8RegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uadd8s", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Usub16RegCc::Usub16RegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("usub16s", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Usub8RegCc::Usub8RegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("usub8s", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UasxRegCc::UasxRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uasxs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UsaxRegCc::UsaxRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("usaxs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Ge]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhadd16Reg::Uhadd16Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uhadd16", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhadd8Reg::Uhadd8Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uhadd8", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhsub16Reg::Uhsub16Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uhsub16", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhsub8Reg::Uhsub8Reg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uhsub8", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UhasxReg::UhasxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uhasx", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UhsaxReg::UhsaxReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("uhsax", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    PkhbtReg::PkhbtReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("pkhbt", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    PkhtbReg::PkhtbReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataRegOp("pkhtb", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                cc_reg::C : cc_reg::Zero)]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }

        if (0 && !isFloating() && !isVector()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdrXImm::AdrXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("adr", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    AdrpXImm::AdrpXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("adrp", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    AndXImm::AndXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("and", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    AndXImmCc::AndXImmCc(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("ands", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    AndXSReg::AndXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("and", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    AndXSRegCc::AndXSRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("ands", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    AndXEReg::AndXEReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ArmExtendType _extendType,
                                   int32_t _shiftAmt) :
        DataXERegOp("and", machInst, IntAluOp,
                       _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    AndXERegCc::AndXERegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ArmExtendType _extendType,
                                   int32_t _shiftAmt) :
        DataXERegOp("ands", machInst, IntAluOp,
                       _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    EorXImm::EorXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("eor", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    EorXSReg::EorXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("eor", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    EorXEReg::EorXEReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ArmExtendType _extendType,
                                   int32_t _shiftAmt) :
        DataXERegOp("eor", machInst, IntAluOp,
                       _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    EonXSReg::EonXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("eon", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    SubXImm::SubXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("sub", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    SubXImmCc::SubXImmCc(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("subs", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    SubXSReg::SubXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("sub", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    SubXSRegCc::SubXSRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("subs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    SubXEReg::SubXEReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ArmExtendType _extendType,
                                   int32_t _shiftAmt) :
        DataXERegOp("sub", machInst, IntAluOp,
                       _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    SubXERegCc::SubXERegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ArmExtendType _extendType,
                                   int32_t _shiftAmt) :
        DataXERegOp("subs", machInst, IntAluOp,
                       _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    AddXImm::AddXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("add", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    AddXImmCc::AddXImmCc(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("adds", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    AddXSReg::AddXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("add", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    AddXSRegCc::AddXSRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("adds", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    AddXEReg::AddXEReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ArmExtendType _extendType,
                                   int32_t _shiftAmt) :
        DataXERegOp("add", machInst, IntAluOp,
                       _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    AddXERegCc::AddXERegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ArmExtendType _extendType,
                                   int32_t _shiftAmt) :
        DataXERegOp("adds", machInst, IntAluOp,
                       _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    AdcXSReg::AdcXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("adc", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	flags[IsInteger] = true;;
    }

    AdcXSRegCc::AdcXSRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("adcs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    SbcXSReg::SbcXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("sbc", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	flags[IsInteger] = true;;
    }

    SbcXSRegCc::SbcXSRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("sbcs", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    OrrXImm::OrrXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("orr", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    OrrXSReg::OrrXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("orr", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    OrrXEReg::OrrXEReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ArmExtendType _extendType,
                                   int32_t _shiftAmt) :
        DataXERegOp("orr", machInst, IntAluOp,
                       _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    OrnXSReg::OrnXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("orn", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    BicXSReg::BicXSReg(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("bic", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    BicXSRegCc::BicXSRegCc(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   int32_t _shiftAmt,
                                   ArmShiftType _shiftType) :
        DataXSRegOp("bics", machInst, IntAluOp,
                       _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Madd64::Madd64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3) :
        DataX3RegOp("madd", machInst, IntMultOp,
                       _dest, _op1, _op2, _op3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op3) ? RegId() : intRegClass[op3]);
	flags[IsInteger] = true;;
    }

    Msub64::Msub64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3) :
        DataX3RegOp("msub", machInst, IntMultOp,
                       _dest, _op1, _op2, _op3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op3) ? RegId() : intRegClass[op3]);
	flags[IsInteger] = true;;
    }

    Smaddl64::Smaddl64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3) :
        DataX3RegOp("smaddl", machInst, IntMultOp,
                       _dest, _op1, _op2, _op3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op3) ? RegId() : intRegClass[op3]);
	flags[IsInteger] = true;;
    }

    Smsubl64::Smsubl64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3) :
        DataX3RegOp("smsubl", machInst, IntMultOp,
                       _dest, _op1, _op2, _op3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op3) ? RegId() : intRegClass[op3]);
	flags[IsInteger] = true;;
    }

    Smulh64::Smulh64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("smulh", machInst, IntMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Umaddl64::Umaddl64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3) :
        DataX3RegOp("umaddl", machInst, IntMultOp,
                       _dest, _op1, _op2, _op3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op3) ? RegId() : intRegClass[op3]);
	flags[IsInteger] = true;;
    }

    Umsubl64::Umsubl64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3) :
        DataX3RegOp("umsubl", machInst, IntMultOp,
                       _dest, _op1, _op2, _op3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op3) ? RegId() : intRegClass[op3]);
	flags[IsInteger] = true;;
    }

    Umulh64::Umulh64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("umulh", machInst, IntMultOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Asrv64::Asrv64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("asrv", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsInteger] = true;;
    }

    Lslv64::Lslv64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("lslv", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsInteger] = true;;
    }

    Lsrv64::Lsrv64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("lsrv", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsInteger] = true;;
    }

    Rorv64::Rorv64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("rorv", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsInteger] = true;;
    }

    Crc32b64::Crc32b64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("crc32b", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Crc32h64::Crc32h64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("crc32h", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Crc32w64::Crc32w64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("crc32w", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Crc32x64::Crc32x64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("crc32x", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Crc32cb64::Crc32cb64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("crc32cb", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Crc32ch64::Crc32ch64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("crc32ch", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Crc32cw64::Crc32cw64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("crc32cw", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Crc32cx64::Crc32cx64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("crc32cx", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Sdiv64::Sdiv64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("sdiv", machInst, IntDivOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Udiv64::Udiv64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("udiv", machInst, IntDivOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Cls64::Cls64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("cls", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Clz64::Clz64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("clz", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Rbit64::Rbit64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rbit", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Rev64::Rev64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Rev1664::Rev1664(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev16", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Rev3264::Rev3264(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("rev32", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Mrs64::Mrs64(ExtMachInst machInst, RegIndex _dest,
                                   MiscRegIndex _op1) :
        RegMiscRegImmOp64("mrs", machInst, IntAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
    }

    MrsNZCV64::MrsNZCV64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("mrsNZCV", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Msr64::Msr64(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1) :
        MiscRegRegImmOp64("msr", machInst, IntAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    Tlbi64LocalHub::Tlbi64LocalHub(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1) :
        TlbiOp64("msr", machInst, IntAluOp,
                       _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    Tlbi64ShareableHub::Tlbi64ShareableHub(ExtMachInst machInst, MiscRegIndex _dest,
                                   RegIndex _op1, bool dvm_enabled) :
        TlbiOp64("msr", machInst, IntAluOp,
                       _dest, _op1),
        dvmEnabled(dvm_enabled)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_TLBINEEDSYNC]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;

        if (dvmEnabled) {
            flags[IsLoad] = true;
        }
    }

    MsrNZCV64::MsrNZCV64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("msrNZCV", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Dczva::Dczva(ExtMachInst machInst, RegIndex _base,
                                   MiscRegIndex _dest) :
         SysDC64("dc zva", machInst, MemWriteOp,
                        _base, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_DCZID_EL0]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        assert(!0);
    }

    Dccvau::Dccvau(ExtMachInst machInst, RegIndex _base,
                                   MiscRegIndex _dest) :
         SysDC64("dc cvau", machInst, MemWriteOp,
                        _base, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        assert(!0);
    }

    Dccvac::Dccvac(ExtMachInst machInst, RegIndex _base,
                                   MiscRegIndex _dest) :
         SysDC64("dc cvac", machInst, MemWriteOp,
                        _base, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        assert(!0);
    }

    Dccivac::Dccivac(ExtMachInst machInst, RegIndex _base,
                                   MiscRegIndex _dest) :
         SysDC64("dc civac", machInst, MemWriteOp,
                        _base, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        assert(!0);
    }

    Dcivac::Dcivac(ExtMachInst machInst, RegIndex _base,
                                   MiscRegIndex _dest) :
         SysDC64("dc ivac", machInst, MemWriteOp,
                        _base, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(base) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_HCR_EL2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SCR_EL3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        assert(!0);
    }

    MsrImm64::MsrImm64(ExtMachInst machInst, MiscRegIndex _dest,
                                   uint64_t _imm) :
        MiscRegImmOp64("msr", machInst, IntAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[dest]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    MsrImmDAIFSet64::MsrImmDAIFSet64(ExtMachInst machInst, MiscRegIndex _dest,
                                   uint64_t _imm) :
        MiscRegImmOp64("msr", machInst, IntAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    MsrImmDAIFClr64::MsrImmDAIFClr64(ExtMachInst machInst, MiscRegIndex _dest,
                                   uint64_t _imm) :
        MiscRegImmOp64("msr", machInst, IntAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    CcmnImm64::CcmnImm64(ExtMachInst machInst, RegIndex _op1,
                                   uint64_t _imm, ConditionCode _condCode,
                                   uint8_t _defCc) :
        DataXCondCompImmOp("ccmn", machInst, IntAluOp,
                       _op1, _imm, _condCode, _defCc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    CcmpImm64::CcmpImm64(ExtMachInst machInst, RegIndex _op1,
                                   uint64_t _imm, ConditionCode _condCode,
                                   uint8_t _defCc) :
        DataXCondCompImmOp("ccmp", machInst, IntAluOp,
                       _op1, _imm, _condCode, _defCc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    CcmnReg64::CcmnReg64(ExtMachInst machInst,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode, uint8_t _defCc) :
        DataXCondCompRegOp("ccmn", machInst, IntAluOp,
                       _op1, _op2, _condCode, _defCc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    CcmpReg64::CcmpReg64(ExtMachInst machInst,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode, uint8_t _defCc) :
        DataXCondCompRegOp("ccmp", machInst, IntAluOp,
                       _op1, _op2, _condCode, _defCc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Csel64::Csel64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode) :
        DataXCondSelOp("csel", machInst, IntAluOp,
                       _dest, _op1, _op2, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsInteger] = true;;
    }

    Csinc64::Csinc64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode) :
        DataXCondSelOp("csinc", machInst, IntAluOp,
                       _dest, _op1, _op2, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsInteger] = true;;
    }

    Csinv64::Csinv64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode) :
        DataXCondSelOp("csinv", machInst, IntAluOp,
                       _dest, _op1, _op2, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsInteger] = true;;
    }

    Csneg64::Csneg64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode) :
        DataXCondSelOp("csneg", machInst, IntAluOp,
                       _dest, _op1, _op2, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsInteger] = true;;
    }

    B::B(ExtMachInst machInst, int32_t _imm,
                                   ConditionCode _condCode) :
        BranchImmCond("b", machInst, IntAluOp, _imm, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsDirectControl] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    std::unique_ptr<PCStateBase>
    B::branchTarget(const PCStateBase &branch_pc) const
    {
        ;
        ;

        PCStateBase *pc_ptr = branch_pc.clone();
        auto &pcs = pc_ptr->as<ArmISA::PCState>();
        pcs.instNPC((uint32_t)(pcs.instPC() + imm));
        pcs.advance();
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    Bl::Bl(ExtMachInst machInst, int32_t _imm,
                                   ConditionCode _condCode) :
        BranchImmCond("bl", machInst, IntAluOp, _imm, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    std::unique_ptr<PCStateBase>
    Bl::branchTarget(const PCStateBase &branch_pc) const
    {
        ;
        ;

        PCStateBase *pc_ptr = branch_pc.clone();
        auto &pcs = pc_ptr->as<ArmISA::PCState>();
        pcs.instNPC((uint32_t)(pcs.instPC() + imm));
        pcs.advance();
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    BlxImm::BlxImm(ExtMachInst machInst, int32_t _imm,
                                   ConditionCode _condCode) :
        BranchImmCond("blx", machInst, IntAluOp, _imm, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    std::unique_ptr<PCStateBase>
    BlxImm::branchTarget(const PCStateBase &branch_pc) const
    {
        ;
        ;

        PCStateBase *pc_ptr = branch_pc.clone();
        auto &pcs = pc_ptr->as<ArmISA::PCState>();
        pcs.nextThumb(!pcs.thumb());

            pcs.instNPC((uint32_t)(pcs.thumb() ? (roundDown(pcs.instPC(), 4) +
                            imm) : (pcs.instPC() + imm)));
            
        pcs.advance();
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    BlxReg::BlxReg(ExtMachInst machInst, RegIndex _op1,
                                   ConditionCode _condCode) :
        BranchRegCond("blx", machInst, IntAluOp, _op1, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::Lr) ? RegId() : intRegClass[int_reg::Lr]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (0)
            flags[IsReturn] = true;
    }

    BxReg::BxReg(ExtMachInst machInst, RegIndex _op1,
                                   ConditionCode _condCode) :
        BranchRegCond("bx", machInst, IntAluOp, _op1, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (op1 == int_reg::Lr)
            flags[IsReturn] = true;
    }

    BxjReg::BxjReg(ExtMachInst machInst, RegIndex _op1,
                                   ConditionCode _condCode) :
        BranchRegCond("bxj", machInst, IntAluOp, _op1, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_HSTR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (op1 == int_reg::Lr)
            flags[IsReturn] = true;
    }

    Cbz::Cbz(ExtMachInst machInst, int32_t _imm,
                                   RegIndex _op1) :
        BranchImmReg("cbz", machInst, IntAluOp, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        flags[IsCondControl] = true;
    }


    std::unique_ptr<PCStateBase>
    Cbz::branchTarget(const PCStateBase &branch_pc) const
    {
        ;
        ;

        PCStateBase *pc_ptr = branch_pc.clone();
        auto &pcs = pc_ptr->as<ArmISA::PCState>();
        pcs.instNPC((uint32_t)(pcs.instPC() + imm));
        pcs.advance();
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    Cbnz::Cbnz(ExtMachInst machInst, int32_t _imm,
                                   RegIndex _op1) :
        BranchImmReg("cbnz", machInst, IntAluOp, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        flags[IsCondControl] = true;
    }


    std::unique_ptr<PCStateBase>
    Cbnz::branchTarget(const PCStateBase &branch_pc) const
    {
        ;
        ;

        PCStateBase *pc_ptr = branch_pc.clone();
        auto &pcs = pc_ptr->as<ArmISA::PCState>();
        pcs.instNPC((uint32_t)(pcs.instPC() + imm));
        pcs.advance();
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    Tbb::Tbb(ExtMachInst machInst,
                                   RegIndex _op1, RegIndex _op2) :
        BranchRegReg("tbb", machInst, MemReadOp, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }

    Tbh::Tbh(ExtMachInst machInst,
                                   RegIndex _op1, RegIndex _op2) :
        BranchRegReg("tbh", machInst, MemReadOp, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }

    B64::B64(ExtMachInst machInst, int64_t _imm) :
        BranchImm64("b", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsUncondControl] = true;;
    }

    Bl64::Bl64(ExtMachInst machInst, int64_t _imm) :
        BranchImm64("bl", machInst, IntAluOp, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::X30) ? RegId() : intRegClass[int_reg::X30]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Br64::Br64(ExtMachInst machInst, RegIndex _op1) :
        BranchReg64("br", machInst, IntAluOp, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Blr64::Blr64(ExtMachInst machInst, RegIndex _op1) :
        BranchReg64("blr", machInst, IntAluOp, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::X30) ? RegId() : intRegClass[int_reg::X30]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Braa::Braa(ExtMachInst machInst, RegIndex _op1,
                                   RegIndex _op2) :
        BranchRegReg64("Braa", machInst, IntAluOp, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Blraa::Blraa(ExtMachInst machInst, RegIndex _op1,
                                   RegIndex _op2) :
        BranchRegReg64("Blraa", machInst, IntAluOp, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::X30) ? RegId() : intRegClass[int_reg::X30]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Braaz::Braaz(ExtMachInst machInst, RegIndex _op1) :
        BranchReg64("Braaz", machInst, IntAluOp, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Blraaz::Blraaz(ExtMachInst machInst, RegIndex _op1) :
        BranchReg64("Blraaz", machInst, IntAluOp, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::X30) ? RegId() : intRegClass[int_reg::X30]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Brab::Brab(ExtMachInst machInst, RegIndex _op1,
                                   RegIndex _op2) :
        BranchRegReg64("Brab", machInst, IntAluOp, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Blrab::Blrab(ExtMachInst machInst, RegIndex _op1,
                                   RegIndex _op2) :
        BranchRegReg64("Blrab", machInst, IntAluOp, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::X30) ? RegId() : intRegClass[int_reg::X30]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Brabz::Brabz(ExtMachInst machInst, RegIndex _op1) :
        BranchReg64("Brabz", machInst, IntAluOp, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Blrabz::Blrabz(ExtMachInst machInst, RegIndex _op1) :
        BranchReg64("Blrabz", machInst, IntAluOp, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(int_reg::X30) ? RegId() : intRegClass[int_reg::X30]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    BCond64::BCond64(
            ExtMachInst machInst, int64_t _imm, ConditionCode _condCode) :
        BranchImmCond64("b", machInst, IntAluOp, _imm, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;;
    }

    Ret64::Ret64(ExtMachInst machInst, RegIndex _op1) :
        BranchRet64("ret", machInst, IntAluOp, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

    Retaa::Retaa(ExtMachInst machInst) :
        BranchRetA64("retaa", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

    Retab::Retab(ExtMachInst machInst) :
        BranchRetA64("retab", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

    Eret64::Eret64(ExtMachInst machInst) :
        BranchEret64("eret", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	flags[IsControl] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
    }

    Eretaa::Eretaa(ExtMachInst machInst) :
        BranchEretA64("eretaa", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
    }

    Eretab::Eretab(ExtMachInst machInst) :
        BranchEretA64("eretab", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_SPSR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_LOCKFLAG]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_SEV_MAILBOX]);
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
    }

    Cbz64::Cbz64(ExtMachInst machInst, int64_t _imm,
                                   RegIndex _op1) :
        BranchImmReg64("cbz", machInst, IntAluOp, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Cbnz64::Cbnz64(ExtMachInst machInst, int64_t _imm,
                                   RegIndex _op1) :
        BranchImmReg64("cbnz", machInst, IntAluOp, _imm, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Tbz64::Tbz64(ExtMachInst machInst,
                                   int64_t _imm1, int64_t _imm2,
                                   RegIndex _op1) :
        BranchImmImmReg64("tbz", machInst, IntAluOp,
                       _imm1, _imm2, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Tbnz64::Tbnz64(ExtMachInst machInst,
                                   int64_t _imm1, int64_t _imm2,
                                   RegIndex _op1) :
        BranchImmImmReg64("tbnz", machInst, IntAluOp,
                       _imm1, _imm2, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Mla::Mla(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("mla", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MlaCc::MlaCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("mlas", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Mls::Mls(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("mls", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Mul::Mul(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("mul", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    MulCc::MulCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("muls", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlabbCc::SmlabbCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlabbs", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlabtCc::SmlabtCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlabts", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlatbCc::SmlatbCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlatbs", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlattCc::SmlattCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlatts", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmladCc::SmladCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlads", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmladxCc::SmladxCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smladxs", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlal::Smlal(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlal", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlalCc::SmlalCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlals", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlalbb::Smlalbb(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlalbb", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlalbt::Smlalbt(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlalbt", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlaltb::Smlaltb(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlaltb", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlaltt::Smlaltt(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlaltt", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlald::Smlald(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlald", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlaldx::Smlaldx(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlaldx", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlawbCc::SmlawbCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlawbs", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlawtCc::SmlawtCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlawts", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlsdCc::SmlsdCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlsds", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmlsdxCc::SmlsdxCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlsdxs", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlsld::Smlsld(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlsld", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smlsldx::Smlsldx(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smlsldx", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smmla::Smmla(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smmla", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smmlar::Smmlar(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smmlar", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smmls::Smmls(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smmls", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smmlsr::Smmlsr(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smmlsr", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smmul::Smmul(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smmul", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smmulr::Smmulr(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smmulr", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmuadCc::SmuadCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smuads", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmuadxCc::SmuadxCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smuadxs", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_CPSR_Q]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smulbb::Smulbb(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smulbb", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smulbt::Smulbt(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smulbt", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smultb::Smultb(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smultb", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smultt::Smultt(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smultt", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smull::Smull(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smull", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SmullCc::SmullCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("smulls", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smulwb::Smulwb(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smulwb", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smulwt::Smulwt(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smulwt", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smusd::Smusd(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smusd", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Smusdx::Smusdx(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2) :
        Mult3("smusdx", machInst, IntMultOp,
                       _reg0, _reg1, _reg2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Umaal::Umaal(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("umaal", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Umlal::Umlal(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("umlal", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    UmlalCc::UmlalCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("umlals", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Umull::Umull(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("umull", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    UmullCc::UmullCc(ExtMachInst machInst, RegIndex _reg0,
                                   RegIndex _reg1, RegIndex _reg2,
                                   RegIndex _reg3) :
        Mult4("umulls", machInst, IntMultOp,
                       _reg0, _reg1, _reg2, _reg3)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg2) ? RegId() : intRegClass[reg2]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(reg3) ? RegId() : intRegClass[reg3]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg0) ? RegId() : intRegClass[reg0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(reg1) ? RegId() : intRegClass[reg1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Sdiv::Sdiv(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sdiv", machInst, IntDivOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Udiv::Udiv(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("udiv", machInst, IntDivOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Vmsr::Vmsr(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmsr", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmsrFpscr::VmsrFpscr(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmsr", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Vmrs::Vmrs(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmrs", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_HCR]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmrsFpscr::VmrsFpscr(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmrs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Fp]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmrsApsrFpscr::VmrsApsrFpscr(ExtMachInst machInst) :
        PredOp("vmrs", machInst, SimdFloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Fp]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovImmS::VmovImmS(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovImmD::VmovImmD(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovImmQ::VmovImmQ(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovRegS::VmovRegS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovRegD::VmovRegD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovRegQ::VmovRegQ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovCoreRegB::VmovCoreRegB(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovCoreRegH::VmovCoreRegH(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovCoreRegW::VmovCoreRegW(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovRegCoreUB::VmovRegCoreUB(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovRegCoreUH::VmovRegCoreUH(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovRegCoreSB::VmovRegCoreSB(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovRegCoreSH::VmovRegCoreSH(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmovRegCoreW::VmovRegCoreW(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Vmov2Reg2Core::Vmov2Reg2Core(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Vmov2Core2Reg::Vmov2Core2Reg(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VfmaS::VfmaS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VfmaD::VfmaD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VfmsS::VfmsS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VfmsD::VfmsD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VfnmaS::VfnmaS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VfnmaD::VfnmaD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VfnmsS::VfnmsS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VfnmsD::VfnmsD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VaddS::VaddS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vadds", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VaddD::VaddD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vaddd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VsubS::VsubS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vsubs", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VsubD::VsubD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vsubd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VdivS::VdivS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vdivs", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VdivD::VdivD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vdivd", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmulS::VmulS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmuls", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmulD::VmulD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmuld", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VminnmS::VminnmS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vminnms", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VminnmD::VminnmD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vminnmd", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmaxnmS::VmaxnmS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmaxnms", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmaxnmD::VmaxnmD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmaxnmd", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VsqrtS::VsqrtS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vsqrts", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VsqrtD::VsqrtD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vsqrtd", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VnegS::VnegS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vnegs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VnegD::VnegD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vnegd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VabsS::VabsS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vabss", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VabsD::VabsD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vabsd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VRIntPS::VRIntPS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintps", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VRIntPD::VRIntPD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintpd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VRIntMS::VRIntMS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintms", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VRIntMD::VRIntMD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintmd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VRIntAS::VRIntAS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintas", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VRIntAD::VRIntAD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintad", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VRIntNS::VRIntNS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintns", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VRIntND::VRIntND(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintnd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmlaS::VmlaS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmlaD::VmlaD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmlsS::VmlsS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VmlsD::VmlsD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VnmlaS::VnmlaS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VnmlaD::VnmlaD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VnmlsS::VnmlsS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VnmlsD::VnmlsD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VnmulS::VnmulS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmuls", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VnmulD::VnmulD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmuld", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtUIntFpS::VcvtUIntFpS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtUIntFpD::VcvtUIntFpD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtSIntFpS::VcvtSIntFpS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtSIntFpD::VcvtSIntFpD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VjcvtSFixedFpD::VjcvtSFixedFpD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vjcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpUIntSR::VcvtFpUIntSR(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpUIntDR::VcvtFpUIntDR(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSIntSR::VcvtFpSIntSR(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSIntDR::VcvtFpSIntDR(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpUIntS::VcvtFpUIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtaFpUIntS::VcvtaFpUIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvta", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtmFpUIntS::VcvtmFpUIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtm", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtnFpUIntS::VcvtnFpUIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtn", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtpFpUIntS::VcvtpFpUIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtp", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpUIntD::VcvtFpUIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtaFpUIntD::VcvtaFpUIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvta", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtmFpUIntD::VcvtmFpUIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtm", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtnFpUIntD::VcvtnFpUIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtn", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtpFpUIntD::VcvtpFpUIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtp", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSIntS::VcvtFpSIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtaFpSIntS::VcvtaFpSIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvta", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtmFpSIntS::VcvtmFpSIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtm", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtnFpSIntS::VcvtnFpSIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtn", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtpFpSIntS::VcvtpFpSIntS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtp", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSIntD::VcvtFpSIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtaFpSIntD::VcvtaFpSIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvta", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtmFpSIntD::VcvtmFpSIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtm", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtnFpSIntD::VcvtnFpSIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtn", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtpFpSIntD::VcvtpFpSIntD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtp", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSFpD::VcvtFpSFpD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpDFpS::VcvtFpDFpS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpHTFpS::VcvtFpHTFpS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpHBFpS::VcvtFpHBFpS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtb", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSFpHT::VcvtFpSFpHT(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSFpHB::VcvtFpSFpHB(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtb", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcmpS::VcmpS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmps", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcmpD::VcmpD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmpd", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcmpZeroS::VcmpZeroS(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpZeros", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcmpZeroD::VcmpZeroD(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpZerod", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcmpeS::VcmpeS(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmpes", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcmpeD::VcmpeD(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmped", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcmpeZeroS::VcmpeZeroS(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpeZeros", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcmpeZeroD::VcmpeZeroD(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpeZerod", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VselS::VselS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          ConditionCode _cond,
                                          VfpMicroMode mode)
        : FpRegRegRegCondOp("vsels", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, _cond, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2) / 4) * NumVecElemPerVecReg) + (op2) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
    }

    VselD::VselD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          RegIndex _op2,
                                          ConditionCode _cond,
                                          VfpMicroMode mode)
        : FpRegRegRegCondOp("vseld", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, _cond, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
    }

    VcvtFpSFixedS::VcvtFpSFixedS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSFixedD::VcvtFpSFixedD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpUFixedS::VcvtFpUFixedS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpUFixedD::VcvtFpUFixedD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtSFixedFpS::VcvtSFixedFpS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtSFixedFpD::VcvtSFixedFpD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtUFixedFpS::VcvtUFixedFpS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtUFixedFpD::VcvtUFixedFpD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSHFixedS::VcvtFpSHFixedS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpSHFixedD::VcvtFpSHFixedD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpUHFixedS::VcvtFpUHFixedS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtFpUHFixedD::VcvtFpUHFixedD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtSHFixedFpS::VcvtSHFixedFpS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtSHFixedFpD::VcvtSHFixedFpD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtUHFixedFpS::VcvtUHFixedFpS(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1) / 4) * NumVecElemPerVecReg) + (op1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest) / 4) * NumVecElemPerVecReg) + (dest) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    VcvtUHFixedFpD::VcvtUHFixedFpD(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FmovImmS::FmovImmS(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fmov", machInst, FloatMiscOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FmovImmD::FmovImmD(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode) :
        FpRegImmOp("fmov", machInst, FloatMiscOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FmovRegS::FmovRegS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	flags[IsVector] = true;;
    }

    FmovRegD::FmovRegD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	flags[IsVector] = true;;
    }

    FmovCoreRegW::FmovCoreRegW(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FmovCoreRegX::FmovCoreRegX(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FmovUCoreRegX::FmovUCoreRegX(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FmovRegCoreW::FmovRegCoreW(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FmovRegCoreX::FmovRegCoreX(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FmovURegCoreX::FmovURegCoreX(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FMAddD::FMAddD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fmadd", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMAddS::FMAddS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fmadd", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMAddH::FMAddH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fmadd", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMSubD::FMSubD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fmsub", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMSubS::FMSubS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fmsub", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMSubH::FMSubH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fmsub", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMAddD::FNMAddD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fnmadd", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMAddS::FNMAddS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fnmadd", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMAddH::FNMAddH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fnmadd", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMSubD::FNMSubD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fnmsub", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMSubS::FNMSubS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fnmsub", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMSubH::FNMSubH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   RegIndex _op3, VfpMicroMode mode) :
        FpRegRegRegRegOp("fnmsub", machInst, FloatMultAccOp,
                       _dest, _op1, _op2, _op3, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op3]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FAddH::FAddH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fadd", machInst, FloatAddOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FAddS::FAddS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fadd", machInst, FloatAddOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FAddD::FAddD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fadd", machInst, FloatAddOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FSubH::FSubH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fsub", machInst, FloatAddOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FSubS::FSubS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fsub", machInst, FloatAddOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FSubD::FSubD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fsub", machInst, FloatAddOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FDivH::FDivH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fdiv", machInst, FloatDivOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FDivS::FDivS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fdiv", machInst, FloatDivOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FDivD::FDivD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fdiv", machInst, FloatDivOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMulH::FMulH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmul", machInst, FloatMultOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMulS::FMulS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmul", machInst, FloatMultOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMulD::FMulD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmul", machInst, FloatMultOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMulH::FNMulH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fnmul", machInst, FloatMultOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMulS::FNMulS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fnmul", machInst, FloatMultOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNMulD::FNMulD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fnmul", machInst, FloatMultOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMinH::FMinH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmin", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMinS::FMinS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmin", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMinD::FMinD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmin", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMaxH::FMaxH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmax", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMaxS::FMaxS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmax", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMaxD::FMaxD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmax", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMinNMH::FMinNMH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fminnm", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMinNMS::FMinNMS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fminnm", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMinNMD::FMinNMD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fminnm", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMaxNMH::FMaxNMH(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmaxnm", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMaxNMS::FMaxNMS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmaxnm", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FMaxNMD::FMaxNMD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   VfpMicroMode mode) :
        FpRegRegRegOp("fmaxnm", machInst, FloatCmpOp,
                       _dest, _op1, _op2, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FSqrtH::FSqrtH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fsqrt", machInst, FloatSqrtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FSqrtS::FSqrtS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fsqrt", machInst, FloatSqrtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FSqrtD::FSqrtD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fsqrt", machInst, FloatSqrtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNegH::FNegH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fneg", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNegS::FNegS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fneg", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FNegD::FNegD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fneg", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FAbsH::FAbsH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fabs", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FAbsS::FAbsS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fabs", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FAbsD::FAbsD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fabs", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntNH::FRIntNH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintn", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntNS::FRIntNS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintn", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntND::FRIntND(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintn", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntPH::FRIntPH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintp", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntPS::FRIntPS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintp", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntPD::FRIntPD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintp", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntMH::FRIntMH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintm", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntMS::FRIntMS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintm", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntMD::FRIntMD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintm", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntZH::FRIntZH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintz", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntZS::FRIntZS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintz", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntZD::FRIntZD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintz", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntAH::FRIntAH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frinta", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntAS::FRIntAS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frinta", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntAD::FRIntAD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frinta", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntIH::FRIntIH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frinti", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntIS::FRIntIS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frinti", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntID::FRIntID(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frinti", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntXH::FRIntXH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintx", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntXS::FRIntXS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintx", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FRIntXD::FRIntXD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("frintx", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FcvtWUIntFpD::FcvtWUIntFpD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("ucvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtWSIntFpD::FcvtWSIntFpD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("scvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtWUIntFpS::FcvtWUIntFpS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("ucvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtWSIntFpS::FcvtWSIntFpS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("scvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtXUIntFpD::FcvtXUIntFpD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("ucvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtXSIntFpD::FcvtXSIntFpD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("scvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtXUIntFpS::FcvtXUIntFpS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("ucvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtXSIntFpS::FcvtXSIntFpS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("scvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtFpSIntXDN::FcvtFpSIntXDN(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXDP::FcvtFpSIntXDP(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXDM::FcvtFpSIntXDM(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXDZ::FcvtFpSIntXDZ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXDA::FcvtFpSIntXDA(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWDN::FcvtFpSIntWDN(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWDP::FcvtFpSIntWDP(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWDM::FcvtFpSIntWDM(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWDZ::FcvtFpSIntWDZ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWDA::FcvtFpSIntWDA(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXDN::FcvtFpUIntXDN(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXDP::FcvtFpUIntXDP(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXDM::FcvtFpUIntXDM(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXDZ::FcvtFpUIntXDZ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXDA::FcvtFpUIntXDA(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWDN::FcvtFpUIntWDN(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWDP::FcvtFpUIntWDP(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWDM::FcvtFpUIntWDM(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWDZ::FcvtFpUIntWDZ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWDA::FcvtFpUIntWDA(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXSN::FcvtFpSIntXSN(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXSP::FcvtFpSIntXSP(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXSM::FcvtFpSIntXSM(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXSZ::FcvtFpSIntXSZ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntXSA::FcvtFpSIntXSA(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWSN::FcvtFpSIntWSN(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWSP::FcvtFpSIntWSP(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWSM::FcvtFpSIntWSM(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWSZ::FcvtFpSIntWSZ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSIntWSA::FcvtFpSIntWSA(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXSN::FcvtFpUIntXSN(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXSP::FcvtFpUIntXSP(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXSM::FcvtFpUIntXSM(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXSZ::FcvtFpUIntXSZ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntXSA::FcvtFpUIntXSA(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWSN::FcvtFpUIntWSN(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWSP::FcvtFpUIntWSP(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWSM::FcvtFpUIntWSM(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWSZ::FcvtFpUIntWSZ(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUIntWSA::FcvtFpUIntWSA(ExtMachInst machInst,
                                          RegIndex _dest, RegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FCvtFpSFpD::FCvtFpSFpD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FcvtFpDFpS::FcvtFpDFpS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FcvtFpHFpD::FcvtFpHFpD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FcvtFpHFpS::FcvtFpHFpS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FcvtFpDFpH::FcvtFpDFpH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FcvtFpSFpH::FcvtFpSFpH(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCmpImmD::FCmpImmD(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode) :
        FpRegImmOp("fcmp", machInst, FloatCmpOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCmpRegD::FCmpRegD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcmp", machInst, FloatCmpOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCmpImmS::FCmpImmS(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode) :
        FpRegImmOp("fcmp", machInst, FloatCmpOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCmpRegS::FCmpRegS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcmp", machInst, FloatCmpOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCmpEImmD::FCmpEImmD(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode) :
        FpRegImmOp("fcmpe", machInst, FloatCmpOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCmpERegD::FCmpERegD(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcmpe", machInst, FloatCmpOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCmpEImmS::FCmpEImmS(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm, VfpMicroMode mode) :
        FpRegImmOp("fcmpe", machInst, FloatCmpOp,
                _dest, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCmpERegS::FCmpERegS(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fcmpe", machInst, FloatCmpOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCCmpRegD::FCCmpRegD(ExtMachInst machInst,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode, uint8_t _defCc) :
        FpCondCompRegOp("fccmp", machInst, FloatCmpOp,
                       _op1, _op2, _condCode, _defCc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCCmpRegS::FCCmpRegS(ExtMachInst machInst,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode, uint8_t _defCc) :
        FpCondCompRegOp("fccmp", machInst, FloatCmpOp,
                       _op1, _op2, _condCode, _defCc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCCmpERegD::FCCmpERegD(ExtMachInst machInst,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode, uint8_t _defCc) :
        FpCondCompRegOp("fccmpe", machInst, FloatCmpOp,
                       _op1, _op2, _condCode, _defCc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FCCmpERegS::FCCmpERegS(ExtMachInst machInst,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode, uint8_t _defCc) :
        FpCondCompRegOp("fccmpe", machInst, FloatCmpOp,
                       _op1, _op2, _condCode, _defCc)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Fp]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsVector] = true;;
    }

    FcvtFpSFixedDX::FcvtFpSFixedDX(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint64_t _imm,
                                   VfpMicroMode mode) :
        FpRegRegImmOp("fcvtzs", machInst, FloatCvtOp,
                       _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtSFixedFpDX::FcvtSFixedFpDX(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUFixedDX::FcvtFpUFixedDX(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint64_t _imm,
                                   VfpMicroMode mode) :
        FpRegRegImmOp("fcvtzu", machInst, FloatCvtOp,
                       _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtUFixedFpDX::FcvtUFixedFpDX(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSFixedSX::FcvtFpSFixedSX(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint64_t _imm,
                                   VfpMicroMode mode) :
        FpRegRegImmOp("fcvtzs", machInst, FloatCvtOp,
                       _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtSFixedFpSX::FcvtSFixedFpSX(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUFixedSX::FcvtFpUFixedSX(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint64_t _imm,
                                   VfpMicroMode mode) :
        FpRegRegImmOp("fcvtzu", machInst, FloatCvtOp,
                       _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtUFixedFpSX::FcvtUFixedFpSX(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSFixedDW::FcvtFpSFixedDW(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint64_t _imm,
                                   VfpMicroMode mode) :
        FpRegRegImmOp("fcvtzs", machInst, FloatCvtOp,
                       _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtSFixedFpDW::FcvtSFixedFpDW(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUFixedDW::FcvtFpUFixedDW(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint64_t _imm,
                                   VfpMicroMode mode) :
        FpRegRegImmOp("fcvtzu", machInst, FloatCvtOp,
                       _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtUFixedFpDW::FcvtUFixedFpDW(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpSFixedSW::FcvtFpSFixedSW(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint64_t _imm,
                                   VfpMicroMode mode) :
        FpRegRegImmOp("fcvtzs", machInst, FloatCvtOp,
                       _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtSFixedFpSW::FcvtSFixedFpSW(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FcvtFpUFixedSW::FcvtFpUFixedSW(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, uint64_t _imm,
                                   VfpMicroMode mode) :
        FpRegRegImmOp("fcvtzu", machInst, FloatCvtOp,
                       _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FcvtUFixedFpSW::FcvtUFixedFpSW(ExtMachInst machInst,
                                          RegIndex _dest,
                                          RegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    FJcvtFpSFixedDW::FJcvtFpSFixedDW(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   VfpMicroMode mode) :
        FpRegRegOp("fjcvtzs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setDestRegIdx(_numDestRegs++, miscRegClass[MISCREG_FPSCR_EXC]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::Nz]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::V]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[cc_reg::C]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    }

    FCSelD::FCSelD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode) :
        FpCondSelOp("fcsel", machInst, FloatCvtOp,
                       _dest, _op1, _op2, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	flags[IsVector] = true;;
    }

    FCSelS::FCSelS(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2,
                                   ConditionCode _condCode) :
        FpCondSelOp("fcsel", machInst, FloatCvtOp,
                       _dest, _op1, _op2, _condCode)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::Nz]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::C]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[cc_reg::V]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	flags[IsVector] = true;;
    }

    Pacda::Pacda(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacda", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacdza::Pacdza(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacdza", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacdb::Pacdb(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacdb", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacdzb::Pacdzb(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacdzb", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacga::Pacga(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        DataX2RegOp("pacga", machInst, IntAluOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op2) ? RegId() : intRegClass[op2]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Pacia::Pacia(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacia", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacia1716::Pacia1716(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacia1716", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Paciasp::Paciasp(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("paciasp", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Paciaz::Paciaz(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("paciaz", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Paciza::Paciza(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("paciza", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacib::Pacib(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacib", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacib1716::Pacib1716(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacib1716", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacibsp::Pacibsp(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacibsp", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacibz::Pacibz(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacibz", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Pacizb::Pacizb(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("pacizb", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autda::Autda(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autda", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autdza::Autdza(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autdza", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autdb::Autdb(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autdb", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autdzb::Autdzb(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autdzb", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autia::Autia(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autia", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autia1716::Autia1716(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autia1716", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autiasp::Autiasp(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autiasp", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autiaz::Autiaz(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autiaz", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autiza::Autiza(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autiza", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autib::Autib(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autib", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autib1716::Autib1716(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autib1716", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autibsp::Autibsp(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autibsp", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autibz::Autibz(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autibz", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Autizb::Autizb(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        DataX1RegOp("autizb", machInst, IntAluOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    Xpacd::Xpacd(ExtMachInst machInst, RegIndex _dest) :
        RegOp("xpacd", machInst, IntAluOp, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        data = bits(machInst, 10);
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Xpaci::Xpaci(ExtMachInst machInst, RegIndex _dest) :
        RegOp("xpaci", machInst, IntAluOp, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        data = bits(machInst, 10);
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    Xpaclri::Xpaclri(ExtMachInst machInst, RegIndex _dest) :
        RegOp("xpaclri", machInst, IntAluOp, _dest)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        data = bits(machInst, 10);
        
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

    NVtbl1::NVtbl1(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    NVtbl2::NVtbl2(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    NVtbl3::NVtbl3(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 4) / 4) * NumVecElemPerVecReg) + (op1 + 4) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 5) / 4) * NumVecElemPerVecReg) + (op1 + 5) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    NVtbl4::NVtbl4(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtbl", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 4) / 4) * NumVecElemPerVecReg) + (op1 + 4) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 5) / 4) * NumVecElemPerVecReg) + (op1 + 5) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 6) / 4) * NumVecElemPerVecReg) + (op1 + 6) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 7) / 4) * NumVecElemPerVecReg) + (op1 + 7) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    NVtbx1::NVtbx1(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    NVtbx2::NVtbx2(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    NVtbx3::NVtbx3(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 4) / 4) * NumVecElemPerVecReg) + (op1 + 4) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 5) / 4) * NumVecElemPerVecReg) + (op1 + 5) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    NVtbx4::NVtbx4(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("vtbx", machInst, SimdMiscOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_NSACR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_FPEXC]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 4) / 4) * NumVecElemPerVecReg) + (op1 + 4) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 5) / 4) * NumVecElemPerVecReg) + (op1 + 5) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 6) / 4) * NumVecElemPerVecReg) + (op1 + 6) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 7) / 4) * NumVecElemPerVecReg) + (op1 + 7) % 4]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

#endif
#if __SPLIT == 3

    VldMult64::VldMult64(
        ExtMachInst machInst, RegIndex rn, RegIndex vd, RegIndex rm,
        uint8_t _eSize, uint8_t _dataSize, uint8_t _numStructElems,
        uint8_t _numRegs, bool _wb) :
            VldMultOp64(
                "vldmult64", machInst, IntAluOp, rn, vd, rm,
                _eSize, _dataSize, _numStructElems, _numRegs, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        ;
    }

    VstMult64::VstMult64(
        ExtMachInst machInst, RegIndex rn, RegIndex vd, RegIndex rm,
        uint8_t _eSize, uint8_t _dataSize, uint8_t _numStructElems,
        uint8_t _numRegs, bool _wb) :
            VstMultOp64(
                "vstmult64", machInst, IntAluOp, rn, vd, rm,
                _eSize, _dataSize, _numStructElems, _numRegs, _wb)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        ;
    }

    VldSingle64::VldSingle64(
        ExtMachInst machInst, RegIndex rn, RegIndex vd, RegIndex rm,
        uint8_t _eSize, uint8_t _dataSize, uint8_t _numStructElems,
        uint8_t _index, bool _wb, bool _replicate) :
            VldSingleOp64(
                "vldsingle64", machInst, IntAluOp, rn, vd, rm,
                _eSize, _dataSize, _numStructElems, _index, _wb,
                _replicate)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        ;
    }

    VstSingle64::VstSingle64(
        ExtMachInst machInst, RegIndex rn, RegIndex vd, RegIndex rm,
        uint8_t _eSize, uint8_t _dataSize, uint8_t _numStructElems,
        uint8_t _index, bool _wb, bool _replicate) :
            VstSingleOp64(
                "vstsingle64", machInst, IntAluOp, rn, vd, rm,
                _eSize, _dataSize, _numStructElems, _index, _wb,
                _replicate)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        ;
    }

    AddplXImm::AddplXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("addpl", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    AddvlXImm::AddvlXImm(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1,
                                   uint64_t _imm) :
        DataXImmOp("addvl", machInst, IntAluOp,
                       _dest, _op1, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, gem5::ArmISA::couldBeZero(op1) ? RegId() : intRegClass[op1]);
	flags[IsInteger] = true;;
    }

    SveRdvl::SveRdvl(ExtMachInst machInst,
            RegIndex _dest, uint64_t _imm) :
        RegImmOp("rdvl", machInst, IntAluOp, _dest, _imm)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPSR]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[MISCREG_CPACR_EL1]);
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(dest) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }


    template <class etype>
    StaticInstPtr
    decodeSveStructLoadSIInstsByNReg(uint8_t esize, ExtMachInst machInst,
            RegIndex zt, RegIndex pg, RegIndex xn,
            int64_t imm, int numregs)
    {
        static const char* nm[5][4] = {
            { nullptr, nullptr, nullptr, nullptr},
            { nullptr, nullptr, nullptr, nullptr},
            { "ld2b", "ld2h", "ld2w", "ld2d" },
            { "ld3b", "ld3h", "ld3w", "ld3d" },
            { "ld4b", "ld4h", "ld4w", "ld4d" } };

        switch (numregs) {
            case 2:
                return new SveLdStructSI<etype,
                        SveLoadRegImmMicroop,
                        SveDeIntrlv2Microop>(
                               nm[numregs][esize], machInst, MemReadOp,
                               zt, pg, xn, imm, numregs);
            case 3:
                return new SveLdStructSI<etype,
                        SveLoadRegImmMicroop,
                        SveDeIntrlv3Microop>(
                               nm[numregs][esize], machInst, MemReadOp,
                               zt, pg, xn, imm, numregs);
            case 4:
                return new SveLdStructSI<etype,
                        SveLoadRegImmMicroop,
                        SveDeIntrlv4Microop>(
                               nm[numregs][esize], machInst, MemReadOp,
                               zt, pg, xn, imm, numregs);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveStructLoadSIInsts(uint8_t esize, ExtMachInst machInst,
            RegIndex zt, RegIndex pg, RegIndex xn,
            int64_t imm, int numregs)
    {
        switch (esize) {
            case 0:
                return decodeSveStructLoadSIInstsByNReg<uint8_t>(esize,
                        machInst, zt, pg, xn, imm, numregs);
            case 1:
                return decodeSveStructLoadSIInstsByNReg<uint16_t>(esize,
                        machInst, zt, pg, xn, imm, numregs);
            case 2:
                return decodeSveStructLoadSIInstsByNReg<uint32_t>(esize,
                        machInst, zt, pg, xn, imm, numregs);
            case 3:
                return decodeSveStructLoadSIInstsByNReg<uint64_t>(esize,
                        machInst, zt, pg, xn, imm, numregs);
        }
        return new Unknown64(machInst);
    }

    template <class etype>
    StaticInstPtr
    decodeSveStructStoreSIInstsByNReg(uint8_t esize, ExtMachInst machInst,
            RegIndex zt, RegIndex pg, RegIndex xn,
            int64_t imm, int numregs)
    {
        static const char* nm[5][4] = {
            { nullptr, nullptr, nullptr, nullptr},
            { nullptr, nullptr, nullptr, nullptr},
            { "st2b", "st2h", "st2w", "st2d" },
            { "st3b", "st3h", "st3w", "st3d" },
            { "st4b", "st4h", "st4w", "st4d" } };

        switch (numregs) {
            case 2:
                return new SveStStructSI<etype,
                        SveStoreRegImmMicroop,
                        SveIntrlv2Microop>(
                            nm[numregs][esize], machInst, MemWriteOp,
                            zt, pg, xn, imm, numregs);
            case 3:
                return new SveStStructSI<etype,
                        SveStoreRegImmMicroop,
                        SveIntrlv3Microop>(
                            nm[numregs][esize], machInst, MemWriteOp,
                            zt, pg, xn, imm, numregs);
           case 4:
                return new SveStStructSI<etype,
                        SveStoreRegImmMicroop,
                        SveIntrlv4Microop>(
                            nm[numregs][esize], machInst, MemWriteOp,
                            zt, pg, xn, imm, numregs);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveStructStoreSIInsts(uint8_t esize, ExtMachInst machInst,
            RegIndex zt, RegIndex pg, RegIndex xn,
            int64_t imm, int numregs)
    {
        switch (esize) {
            case 0:
                return decodeSveStructStoreSIInstsByNReg<uint8_t>(esize,
                    machInst, zt, pg, xn, imm, numregs);
            case 1:
                return decodeSveStructStoreSIInstsByNReg<uint16_t>(esize,
                    machInst, zt, pg, xn, imm, numregs);
            case 2:
                return decodeSveStructStoreSIInstsByNReg<uint32_t>(esize,
                    machInst, zt, pg, xn, imm, numregs);
            case 3:
                return decodeSveStructStoreSIInstsByNReg<uint64_t>(esize,
                    machInst, zt, pg, xn, imm, numregs);
        }
        return new Unknown64(machInst);
    }

    template <class etype>
    StaticInstPtr
    decodeSveStructLoadSSInstsByNReg(uint8_t esize, ExtMachInst machInst,
            RegIndex zt, RegIndex pg, RegIndex xn,
            RegIndex xm, int numregs)
    {
        static const char* nm[5][4] = {
            { nullptr, nullptr, nullptr, nullptr},
            { nullptr, nullptr, nullptr, nullptr},
            { "ld2b", "ld2h", "ld2w", "ld2d" },
            { "ld3b", "ld3h", "ld3w", "ld3d" },
            { "ld4b", "ld4h", "ld4w", "ld4d" } };

        switch (numregs) {
            case 2:
                return new SveLdStructSS<etype,
                        SveLoadRegRegMicroop,
                        SveDeIntrlv2Microop>(
                               nm[numregs][esize], machInst, MemReadOp,
                               zt, pg, xn, xm, numregs);
            case 3:
                return new SveLdStructSS<etype,
                        SveLoadRegRegMicroop,
                        SveDeIntrlv3Microop>(
                               nm[numregs][esize], machInst, MemReadOp,
                               zt, pg, xn, xm, numregs);
            case 4:
                return new SveLdStructSS<etype,
                        SveLoadRegRegMicroop,
                        SveDeIntrlv4Microop>(
                               nm[numregs][esize], machInst, MemReadOp,
                               zt, pg, xn, xm, numregs);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveStructLoadSSInsts(uint8_t esize, ExtMachInst machInst,
            RegIndex zt, RegIndex pg, RegIndex xn,
            RegIndex xm, int numregs)
    {
        switch (esize) {
            case 0:
                return decodeSveStructLoadSSInstsByNReg<uint8_t>(esize,
                            machInst, zt, pg, xn, xm, numregs);
            case 1:
                return decodeSveStructLoadSSInstsByNReg<uint16_t>(esize,
                            machInst, zt, pg, xn, xm, numregs);
            case 2:
                return decodeSveStructLoadSSInstsByNReg<uint32_t>(esize,
                            machInst, zt, pg, xn, xm, numregs);
            case 3:
                return decodeSveStructLoadSSInstsByNReg<uint64_t>(esize,
                            machInst, zt, pg, xn, xm, numregs);
        }
        return new Unknown64(machInst);
    }

    template <class etype>
    StaticInstPtr
    decodeSveStructStoreSSInstsByNReg(uint8_t esize, ExtMachInst machInst,
            RegIndex zt, RegIndex pg, RegIndex xn,
            RegIndex xm, int numregs)
    {
        static const char* nm[5][4] = {
            { nullptr, nullptr, nullptr, nullptr},
            { nullptr, nullptr, nullptr, nullptr},
            { "st2b", "st2h", "st2w", "st2d" },
            { "st3b", "st3h", "st3w", "st3d" },
            { "st4b", "st4h", "st4w", "st4d" } };

        switch (numregs) {
            case 2:
                return new SveStStructSS<etype,
                        SveStoreRegRegMicroop,
                        SveIntrlv2Microop>(
                               nm[numregs][esize], machInst, MemWriteOp,
                               zt, pg, xn, xm, numregs);
            case 3:
                return new SveStStructSS<etype,
                        SveStoreRegRegMicroop,
                        SveIntrlv3Microop>(
                               nm[numregs][esize], machInst, MemWriteOp,
                               zt, pg, xn, xm, numregs);
            case 4:
                return new SveStStructSS<etype,
                        SveStoreRegRegMicroop,
                        SveIntrlv4Microop>(
                               nm[numregs][esize], machInst, MemWriteOp,
                               zt, pg, xn, xm, numregs);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveStructStoreSSInsts(uint8_t esize, ExtMachInst machInst,
            RegIndex zt, RegIndex pg, RegIndex xn,
            RegIndex xm, int numregs)
    {
        switch (esize) {
            case 0:
                return decodeSveStructStoreSSInstsByNReg<uint8_t>(esize,
                            machInst, zt, pg, xn, xm, numregs);
            case 1:
                return decodeSveStructStoreSSInstsByNReg<uint16_t>(esize,
                            machInst, zt, pg, xn, xm, numregs);
            case 2:
                return decodeSveStructStoreSSInstsByNReg<uint32_t>(esize,
                            machInst, zt, pg, xn, xm, numregs);
            case 3:
                return decodeSveStructStoreSSInstsByNReg<uint64_t>(esize,
                            machInst, zt, pg, xn, xm, numregs);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveGatherLoadVIInsts(uint8_t dtype, ExtMachInst machInst,
                               RegIndex zt, RegIndex pg, RegIndex zn,
                               uint64_t imm, bool esizeIs32,
                               bool firstFault)
    {
        const char* mn = firstFault ? "ldff1" : "ld1";
        switch (dtype) {
          case 0x0:
            if (esizeIs32) {
                return new SveIndexedMemVI<int32_t, int8_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            } else {
                return new SveIndexedMemVI<int64_t, int8_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            }
          case 0x1:
            if (esizeIs32) {
                return new SveIndexedMemVI<uint32_t, uint8_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            } else {
                return new SveIndexedMemVI<uint64_t, uint8_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            }
          case 0x2:
            if (esizeIs32) {
                return new SveIndexedMemVI<int32_t, int16_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            } else {
                return new SveIndexedMemVI<int64_t, int16_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            }
          case 0x3:
            if (esizeIs32) {
                return new SveIndexedMemVI<uint32_t, uint16_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            } else {
                return new SveIndexedMemVI<uint64_t, uint16_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            }
          case 0x4:
            if (esizeIs32) {
                break;
            } else {
                return new SveIndexedMemVI<int64_t, int32_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            }
          case 0x5:
            if (esizeIs32) {
                return new SveIndexedMemVI<uint32_t, uint32_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            } else {
                return new SveIndexedMemVI<uint64_t, uint32_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            }
          case 0x7:
            if (esizeIs32) {
                break;
            } else {
                return new SveIndexedMemVI<uint64_t, uint64_t,
                                           SveGatherLoadVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, zn, imm, firstFault);
            }
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveGatherLoadSVInsts(uint8_t dtype, ExtMachInst machInst,
                               RegIndex zt, RegIndex pg, RegIndex rn,
                               RegIndex zm, bool esizeIs32, bool offsetIs32,
                               bool offsetIsSigned, bool offsetIsScaled,
                               bool firstFault)
    {
        const char* mn = firstFault ? "ldff1" : "ld1";
        switch (dtype) {
          case 0x0:
            if (esizeIs32) {
                return new SveIndexedMemSV<int32_t, int8_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            } else {
                return new SveIndexedMemSV<int64_t, int8_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            }
          case 0x1:
            if (esizeIs32) {
                return new SveIndexedMemSV<uint32_t, uint8_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            } else {
                return new SveIndexedMemSV<uint64_t, uint8_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            }
          case 0x2:
            if (esizeIs32) {
                return new SveIndexedMemSV<int32_t, int16_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            } else {
                return new SveIndexedMemSV<int64_t, int16_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            }
          case 0x3:
            if (esizeIs32) {
                return new SveIndexedMemSV<uint32_t, uint16_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            } else {
                return new SveIndexedMemSV<uint64_t, uint16_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            }
          case 0x4:
            if (esizeIs32) {
                break;
            } else {
                return new SveIndexedMemSV<int64_t, int32_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            }
          case 0x5:
            if (esizeIs32) {
                return new SveIndexedMemSV<uint32_t, uint32_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            } else {
                return new SveIndexedMemSV<uint64_t, uint32_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            }
          case 0x7:
            if (esizeIs32) {
                break;
            } else {
                return new SveIndexedMemSV<uint64_t, uint64_t,
                                           SveGatherLoadSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemReadOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, firstFault);
            }
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveScatterStoreVIInsts(uint8_t msz, ExtMachInst machInst,
                                 RegIndex zt, RegIndex pg,
                                 RegIndex zn, uint64_t imm,
                                 bool esizeIs32)
    {
        const char* mn = "st1";
        switch (msz) {
          case 0x0:
            if (esizeIs32) {
                return new SveIndexedMemVI<uint32_t, uint8_t,
                                           SveScatterStoreVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, zn, imm, false);
            } else {
                return new SveIndexedMemVI<uint64_t, uint8_t,
                                           SveScatterStoreVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, zn, imm, false);
            }
          case 0x1:
            if (esizeIs32) {
                return new SveIndexedMemVI<uint32_t, uint16_t,
                                           SveScatterStoreVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, zn, imm, false);
            } else {
                return new SveIndexedMemVI<uint64_t, uint16_t,
                                           SveScatterStoreVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, zn, imm, false);
            }
          case 0x2:
            if (esizeIs32) {
                return new SveIndexedMemVI<uint32_t, uint32_t,
                                           SveScatterStoreVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, zn, imm, false);
            } else {
                return new SveIndexedMemVI<uint64_t, uint32_t,
                                           SveScatterStoreVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, zn, imm, false);
            }
          case 0x3:
            if (esizeIs32) {
                break;
            } else {
                return new SveIndexedMemVI<uint64_t, uint64_t,
                                           SveScatterStoreVIMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, zn, imm, false);
            }
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveScatterStoreSVInsts(uint8_t msz, ExtMachInst machInst,
                                 RegIndex zt, RegIndex pg,
                                 RegIndex rn, RegIndex zm,
                                 bool esizeIs32, bool offsetIs32,
                                 bool offsetIsSigned, bool offsetIsScaled)
    {
        const char* mn = "st1";
        switch (msz) {
          case 0x0:
            if (esizeIs32) {
                return new SveIndexedMemSV<uint32_t, uint8_t,
                                           SveScatterStoreSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, false);
            } else {
                return new SveIndexedMemSV<uint64_t, uint8_t,
                                           SveScatterStoreSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, false);
            }
          case 0x1:
            if (esizeIs32) {
                return new SveIndexedMemSV<uint32_t, uint16_t,
                                           SveScatterStoreSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, false);
            } else {
                return new SveIndexedMemSV<uint64_t, uint16_t,
                                           SveScatterStoreSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, false);
            }
          case 0x2:
            if (esizeIs32) {
                return new SveIndexedMemSV<uint32_t, uint32_t,
                                           SveScatterStoreSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, false);
            } else {
                return new SveIndexedMemSV<uint64_t, uint32_t,
                                           SveScatterStoreSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, false);
            }
          case 0x3:
            if (esizeIs32) {
                break;
            } else {
                return new SveIndexedMemSV<uint64_t, uint64_t,
                                           SveScatterStoreSVMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    mn, machInst, MemWriteOp, zt, pg, rn, zm,
                    offsetIs32, offsetIsSigned, offsetIsScaled, false);
            }
        }
        return new Unknown64(machInst);
    }


    Gem5Op64::Gem5Op64(ExtMachInst machInst) :
        PredOp("gem5op", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(0) ? RegId() : intRegClass[0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    Gem5Op::Gem5Op(ExtMachInst machInst) :
        PredOp("gem5op", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(0) ? RegId() : intRegClass[0]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, gem5::ArmISA::couldBeZero(1) ? RegId() : intRegClass[1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AESE::AESE(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("aese", machInst, SimdAesOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AESD::AESD(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("aesd", machInst, SimdAesOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AESMC::AESMC(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("aesmc", machInst, SimdAesMixOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AESIMC::AESIMC(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("aesimc", machInst, SimdAesMixOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1C::SHA1C(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha1c", machInst, SimdSha1HashOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1P::SHA1P(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha1p", machInst, SimdSha1HashOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1M::SHA1M(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha1m", machInst, SimdSha1HashOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1H::SHA1H(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("sha1h", machInst, SimdSha1Hash2Op, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1SU0::SHA1SU0(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha1su0", machInst, SimdShaSigma3Op,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1SU1::SHA1SU1(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("sha1su1", machInst, SimdShaSigma2Op, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA256H::SHA256H(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha256h", machInst, SimdSha256HashOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA256H2::SHA256H2(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha256h2", machInst, SimdSha256Hash2Op,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA256SU0::SHA256SU0(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("sha256su0", machInst, SimdShaSigma2Op, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA256SU1::SHA256SU1(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha256su1", machInst, SimdShaSigma3Op,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 0) / 4) * NumVecElemPerVecReg) + (op1 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 0) / 4) * NumVecElemPerVecReg) + (op2 + 0) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 0) / 4) * NumVecElemPerVecReg) + (dest + 0) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 1) / 4) * NumVecElemPerVecReg) + (op1 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 1) / 4) * NumVecElemPerVecReg) + (op2 + 1) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 1) / 4) * NumVecElemPerVecReg) + (dest + 1) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 2) / 4) * NumVecElemPerVecReg) + (op1 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 2) / 4) * NumVecElemPerVecReg) + (op2 + 2) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 2) / 4) * NumVecElemPerVecReg) + (dest + 2) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op1 + 3) / 4) * NumVecElemPerVecReg) + (op1 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((op2 + 3) / 4) * NumVecElemPerVecReg) + (op2 + 3) % 4]);
	setSrcRegIdx(_numSrcRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	setDestRegIdx(_numDestRegs++, vecElemClass[(((dest + 3) / 4) * NumVecElemPerVecReg) + (dest + 3) % 4]);
	_numTypedDestRegs[vecElemClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVectorElem] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AESE64::AESE64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("aese", machInst, SimdAesOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AESD64::AESD64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("aesd", machInst, SimdAesOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AESMC64::AESMC64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("aesmc", machInst, SimdAesMixOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    AESIMC64::AESIMC64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("aesimc", machInst, SimdAesMixOp, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1C64::SHA1C64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha1c", machInst, SimdSha1HashOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1P64::SHA1P64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha1p", machInst, SimdSha1HashOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1M64::SHA1M64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha1m", machInst, SimdSha1HashOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1H64::SHA1H64(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("sha1h", machInst, SimdSha1Hash2Op, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1SU064::SHA1SU064(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha1su0", machInst, SimdShaSigma3Op,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA1SU164::SHA1SU164(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("sha1su1", machInst, SimdShaSigma2Op, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA256H64::SHA256H64(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha256h", machInst, SimdSha256HashOp,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA256H264::SHA256H264(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha256h2", machInst, SimdSha256Hash2Op,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA256SU064::SHA256SU064(ExtMachInst machInst,
                                   RegIndex _dest, RegIndex _op1) :
        RegRegOp("sha256su0", machInst, SimdShaSigma2Op, _dest, _op1)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

    SHA256SU164::SHA256SU164(ExtMachInst machInst, RegIndex _dest,
                                   RegIndex _op1, RegIndex _op2) :
        RegRegRegOp("sha256su1", machInst, SimdShaSigma3Op,
                       _dest, _op1, _op2)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[op2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[dest]);
	setDestRegIdx(_numDestRegs++, vecRegClass[dest]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                cc_reg::Zero : cc_reg::Nz)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               cc_reg::C : cc_reg::Zero)]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                cc_reg::V : cc_reg::Zero)]);
	flags[IsVector] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                setSrcRegIdx(_numSrcRegs++, destRegIdx(x));
            }
        }
    }

namespace Aarch64
{
    StaticInstPtr
    decodeDataProcImm(ExtMachInst machInst)
    {
        RegIndex rd = (RegIndex)(uint32_t)bits(machInst, 4, 0);
        RegIndex rdsp = makeSP(rd);
        RegIndex rdzr = makeZero(rd);
        RegIndex rn = (RegIndex)(uint32_t)bits(machInst, 9, 5);
        RegIndex rnsp = makeSP(rn);

        uint8_t opc = bits(machInst, 30, 29);
        bool sf = bits(machInst, 31);
        bool n = bits(machInst, 22);
        uint8_t immr = bits(machInst, 21, 16);
        uint8_t imms = bits(machInst, 15, 10);
        switch (bits(machInst, 25, 23)) {
          case 0x0:
          case 0x1:
          {
            uint64_t immlo = bits(machInst, 30, 29);
            uint64_t immhi = bits(machInst, 23, 5);
            uint64_t imm = (immlo << 0) | (immhi << 2);
            if (bits(machInst, 31) == 0)
                return new AdrXImm(machInst, rdzr, int_reg::Zero,
                                   sext<21>(imm));
            else
                return new AdrpXImm(machInst, rdzr, int_reg::Zero,
                                    sext<33>(imm << 12));
          }
          case 0x2:
          case 0x3:
          {
            uint32_t imm12 = bits(machInst, 21, 10);
            uint8_t shift = bits(machInst, 23, 22);
            uint32_t imm;
            if (shift == 0x0)
                imm = imm12 << 0;
            else if (shift == 0x1)
                imm = imm12 << 12;
            else
                return new Unknown64(machInst);
            switch (opc) {
              case 0x0:
                return new AddXImm(machInst, rdsp, rnsp, imm);
              case 0x1:
                return new AddXImmCc(machInst, rdzr, rnsp, imm);
              case 0x2:
                return new SubXImm(machInst, rdsp, rnsp, imm);
              case 0x3:
                return new SubXImmCc(machInst, rdzr, rnsp, imm);
              default:
                GEM5_UNREACHABLE;
            }
          }
          case 0x4:
          {
            if (!sf && n)
                return new Unknown64(machInst);
            // len = MSB(n:NOT(imms)), len < 1 is undefined.
            uint8_t len = 0;
            if (n) {
                len = 6;
            } else if (imms == 0x3f || imms == 0x3e) {
                return new Unknown64(machInst);
            } else {
                len = findMsbSet(imms ^ 0x3f);
            }
            // Generate r, s, and size.
            uint64_t r = bits(immr, len - 1, 0);
            uint64_t s = bits(imms, len - 1, 0);
            uint8_t size = 1 << len;
            if (s == size - 1)
                return new Unknown64(machInst);
            // Generate the pattern with s 1s, rotated by r, with size bits.
            uint64_t pattern = mask(s + 1);
            if (r) {
                pattern = (pattern >> r) | (pattern << (size - r));
                pattern &= mask(size);
            }
            uint8_t width = sf ? 64 : 32;
            // Replicate that to fill up the immediate.
            for (unsigned i = 1; i < (width / size); i *= 2)
                pattern |= (pattern << (i * size));
            uint64_t imm = pattern;

            switch (opc) {
              case 0x0:
                return new AndXImm(machInst, rdsp, rn, imm);
              case 0x1:
                return new OrrXImm(machInst, rdsp, rn, imm);
              case 0x2:
                return new EorXImm(machInst, rdsp, rn, imm);
              case 0x3:
                return new AndXImmCc(machInst, rdzr, rn, imm);
              default:
                GEM5_UNREACHABLE;
            }
          }
          case 0x5:
          {
            RegIndex rd = (RegIndex)(uint32_t)bits(machInst, 4, 0);
            RegIndex rdzr = makeZero(rd);
            uint32_t imm16 = bits(machInst, 20, 5);
            uint32_t hw = bits(machInst, 22, 21);
            switch (opc) {
              case 0x0:
                return new Movn(machInst, rdzr, imm16, hw * 16);
              case 0x1:
                return new Unknown64(machInst);
              case 0x2:
                return new Movz(machInst, rdzr, imm16, hw * 16);
              case 0x3:
                return new Movk(machInst, rdzr, imm16, hw * 16);
              default:
                GEM5_UNREACHABLE;
            }
          }
          case 0x6:
            if ((sf != n) || (!sf && (bits(immr, 5) || bits(imms, 5))))
                return new Unknown64(machInst);
            switch (opc) {
              case 0x0:
                return new Sbfm64(machInst, rdzr, rn, immr, imms);
              case 0x1:
                return new Bfm64(machInst, rdzr, rn, immr, imms);
              case 0x2:
                return new Ubfm64(machInst, rdzr, rn, immr, imms);
              case 0x3:
                return new Unknown64(machInst);
              default:
                GEM5_UNREACHABLE;
            }
          case 0x7:
          {
            RegIndex rm = (RegIndex)(uint8_t)bits(machInst, 20, 16);
            if (opc || bits(machInst, 21))
                return new Unknown64(machInst);
            else
                return new Extr64(machInst, rdzr, rn, rm, imms);
          }
        }
        return new FailUnimplemented("Unhandled Case8", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeBranchExcSys(const Decoder &dec, ExtMachInst machInst)
    {
        switch (bits(machInst, 30, 29)) {
          case 0x0:
          {
            int64_t imm = sext<26>(bits(machInst, 25, 0)) << 2;
            if (bits(machInst, 31) == 0)
                return new B64(machInst, imm);
            else
                return new Bl64(machInst, imm);
          }
          case 0x1:
          {
            RegIndex rt = (RegIndex)(uint8_t)bits(machInst, 4, 0);
            if (bits(machInst, 25) == 0) {
                int64_t imm = sext<19>(bits(machInst, 23, 5)) << 2;
                if (bits(machInst, 24) == 0)
                    return new Cbz64(machInst, imm, rt);
                else
                    return new Cbnz64(machInst, imm, rt);
            } else {
                uint64_t bitmask = 0x1;
                bitmask <<= bits(machInst, 23, 19);
                int64_t imm = sext<14>(bits(machInst, 18, 5)) << 2;
                if (bits(machInst, 31))
                    bitmask <<= 32;
                if (bits(machInst, 24) == 0)
                    return new Tbz64(machInst, bitmask, imm, rt);
                else
                    return new Tbnz64(machInst, bitmask, imm, rt);
            }
          }
          case 0x2:
            // bit 30:26=10101
            if (bits(machInst, 31) == 0) {
                if (bits(machInst, 25, 24) || bits(machInst, 4))
                    return new Unknown64(machInst);
                int64_t imm = sext<19>(bits(machInst, 23, 5)) << 2;
                ConditionCode condCode =
                    (ConditionCode)(uint8_t)(bits(machInst, 3, 0));
                return new BCond64(machInst, imm, condCode);
            } else if (bits(machInst, 25, 24) == 0x0) {

                if (bits(machInst, 4, 2))
                    return new Unknown64(machInst);

                auto imm16 = bits(machInst, 20, 5);
                uint8_t decVal = (bits(machInst, 1, 0) << 0) |
                                 (bits(machInst, 23, 21) << 2);

                switch (decVal) {
                  case 0x01:
                    return new Svc64(machInst, imm16);
                  case 0x02:
                    return new Hvc64(machInst, imm16);
                  case 0x03:
                    return new Smc64(machInst, imm16);
                  case 0x04:
                    return new Brk64(machInst, imm16);
                  case 0x08:
                    return new Hlt64(machInst, imm16);
                  case 0x0c:
                    return new Tcancel64(machInst, imm16);
                  case 0x15:
                    return new FailUnimplemented("dcps1", machInst);
                  case 0x16:
                    return new FailUnimplemented("dcps2", machInst);
                  case 0x17:
                    return new FailUnimplemented("dcps3", machInst);
                  default:
                    return new Unknown64(machInst);
                }
            } else if (bits(machInst, 25, 22) == 0x4) {
                // bit 31:22=1101010100
                bool l = bits(machInst, 21);
                uint8_t op0 = bits(machInst, 20, 19);
                uint8_t op1 = bits(machInst, 18, 16);
                uint8_t crn = bits(machInst, 15, 12);
                uint8_t crm = bits(machInst, 11, 8);
                uint8_t op2 = bits(machInst, 7, 5);
                RegIndex rt = (RegIndex)(uint8_t)bits(machInst, 4, 0);
                switch (op0) {
                  case 0x0:
                    // early out for TME
                    if (crn == 0x3 && op1 == 0x3 && op2 == 0x3) {
                        switch (crm) {
                            case 0x0:
                              if (rt == 0b11111)
                                return new Tcommit64(machInst);
                              else
                                return new Tstart64(machInst, rt);
                            case 0x1:
                              return new Ttest64(machInst, rt);
                            default:
                              return new Unknown64(machInst);
                        }
                    }
                    else if (rt != 0x1f || l)
                        return new Unknown64(machInst);
                    if (crn == 0x2 && op1 == 0x3) {
                        switch (crm) {
                          case 0x0:
                            switch (op2) {
                              case 0x0:
                                return new NopInst(machInst);
                              case 0x1:
                                return new YieldInst(machInst);
                              case 0x2:
                                return new WfeInst(machInst);
                              case 0x3:
                                return new WfiInst(machInst);
                              case 0x4:
                                return new SevInst(machInst);
                              case 0x5:
                                return new SevlInst(machInst);
                              case 0x7:
                                return new Xpaclri(machInst, int_reg::X30);
                            }
                            break;
                          case 0x1:
                            switch (op2) {
                              case 0x0:
                                return new Pacia1716(machInst, int_reg::X17,
                                                               int_reg::X16);
                              case 0x2:
                                return new Pacib1716(machInst, int_reg::X17,
                                                               int_reg::X16);
                              case 0x4:
                                return new Autia1716(machInst, int_reg::X17,
                                                               int_reg::X16);
                              case 0x6:
                                return new Autib1716(machInst, int_reg::X17,
                                                               int_reg::X16);
                            }
                            break;
                          case 0x2:
                            switch (op2) {
                              case 0x0:
                                return new WarnUnimplemented(
                                        "esb", machInst);
                              case 0x1:
                                return new WarnUnimplemented(
                                        "psb csync", machInst);
                              case 0x2:
                                return new WarnUnimplemented(
                                        "tsb csync", machInst);
                              case 0x4:
                                return new WarnUnimplemented(
                                        "csdb", machInst);
                            }
                            break;
                          case 0x3:
                            switch (op2) {
                              case 0x0:
                                return new Paciaz(machInst,
                                         int_reg::X30, int_reg::Zero);
                              case 0x1:
                                return new Paciasp(machInst,
                                         int_reg::X30, int_reg::Spx);
                              case 0x2:
                                return new Pacibz(machInst,
                                         int_reg::X30, int_reg::Zero);
                              case 0x3:
                                return new Pacibsp(machInst,
                                         int_reg::X30, int_reg::Spx);
                              case 0x4:
                                return new Autiaz(machInst,
                                         int_reg::X30, int_reg::Zero);
                              case 0x5:
                                return new Autiasp(machInst,
                                         int_reg::X30, int_reg::Spx);
                              case 0x6:
                                return new Autibz(machInst,
                                         int_reg::X30, int_reg::Zero);
                              case 0x7:
                                return new Autibsp(machInst,
                                         int_reg::X30, int_reg::Spx);
                            }
                            break;
                          case 0x4:
                            switch (op2 & 0x1) {
                              case 0x0:
                                return new WarnUnimplemented(
                                        "bti", machInst);
                            }
                            break;
                        }
                        return new WarnUnimplemented(
                                "unallocated_hint", machInst);
                    } else if (crn == 0x3 && op1 == 0x3) {
                        switch (op2) {
                          case 0x2:
                            return new Clrex64(machInst);
                          case 0x4:
                            switch (bits(crm, 3, 2)) {
                              case 0x1: // Non-Shareable
                                return new Dsb64Local(machInst);
                              case 0x0: // OuterShareable
                              case 0x2: // InnerShareable
                              case 0x3: // FullSystem
                                return new Dsb64Shareable(
                                    machInst, dec.dvmEnabled);
                              default:
                                GEM5_UNREACHABLE;
                            }
                          case 0x5:
                            return new Dmb64(machInst);
                          case 0x6:
                            return new Isb64(machInst);
                          default:
                            return new Unknown64(machInst);
                        }
                    } else if (crn == 0x4) {
                        // MSR immediate: moving immediate value to selected
                        // bits of the PSTATE
                        switch (op1 << 3 | op2) {
                          case 0x3:
                            // UAO
                            return new MsrImm64(
                                machInst, MISCREG_UAO, crm);
                          case 0x4:
                            // PAN
                            return new MsrImm64(
                                machInst, MISCREG_PAN, crm);
                          case 0x5:
                            // SP
                            return new MsrImm64(
                                machInst, MISCREG_SPSEL, crm);
                          case 0x1e:
                            // DAIFSet
                            return new MsrImmDAIFSet64(
                                machInst, MISCREG_DAIF, crm);
                          case 0x1f:
                            // DAIFClr
                            return new MsrImmDAIFClr64(
                                machInst, MISCREG_DAIF, crm);
                          default:
                            return new Unknown64(machInst);
                        }
                    } else {
                        return new Unknown64(machInst);
                    }
                    break;
                  case 0x1:
                  case 0x2:
                  case 0x3:
                  {
                    // bit 31:22=1101010100, 20:19=11
                    bool read = l;
                    MiscRegIndex miscReg =
                        decodeAArch64SysReg(op0, op1, crn, crm, op2);

                    // Check for invalid registers
                    if (miscReg == MISCREG_UNKNOWN) {
                        auto full_mnemonic =
                            csprintf("%s op0:%d op1:%d crn:%d crm:%d op2:%d",
                                     read ? "mrs" : "msr",
                                     op0, op1, crn, crm, op2);

                        return new FailUnimplemented(read ? "mrs" : "msr",
                            machInst, full_mnemonic);

                    } else if (miscReg == MISCREG_IMPDEF_UNIMPL) {
                        auto full_mnemonic =
                            csprintf("%s op0:%d op1:%d crn:%d crm:%d op2:%d",
                                     read ? "mrs" : "msr",
                                     op0, op1, crn, crm, op2);

                        return new MiscRegImplDefined64(
                            read ? "mrs" : "msr",
                            machInst, MiscRegNum64(op0, op1, crn, crm, op2),
                            rt, read, full_mnemonic);

                    } else {
                        if (read) {
                            switch (miscReg) {
                              case MISCREG_NZCV:
                                return new MrsNZCV64(machInst, rt, miscReg);
                              case MISCREG_DC_CIVAC_Xt:
                              case MISCREG_DC_CVAC_Xt:
                              case MISCREG_DC_IVAC_Xt:
                              case MISCREG_DC_ZVA_Xt:
                                return new Unknown64(machInst);
                              default: {
                                StaticInstPtr si = new Mrs64(machInst, rt, miscReg);
                                if (lookUpMiscReg[miscReg].info[MISCREG_UNVERIFIABLE])
                                    si->setFlag(StaticInst::IsUnverifiable);
                                return si;
                              }
                            }
                        } else {
                            switch (miscReg) {
                              case MISCREG_NZCV:
                                return new MsrNZCV64(machInst, miscReg, rt);
                              case MISCREG_DC_ZVA_Xt:
                                return new Dczva(machInst, rt, miscReg);
                              case MISCREG_DC_CVAU_Xt:
                                return new Dccvau(machInst, rt, miscReg);
                              case MISCREG_DC_CVAC_Xt:
                                return new Dccvac(machInst, rt, miscReg);
                              case MISCREG_DC_CIVAC_Xt:
                                return new Dccivac(machInst, rt, miscReg);
                              case MISCREG_DC_IVAC_Xt:
                                return new Dcivac(machInst, rt, miscReg);
                              // 64-bit TLBIs split into "Local"
                              // and "Shareable"
                              case MISCREG_TLBI_ALLE3:
                              case MISCREG_TLBI_ALLE2:
                              case MISCREG_TLBI_ALLE1:
                              case MISCREG_TLBI_VMALLS12E1:
                              case MISCREG_TLBI_VMALLE1:
                              case MISCREG_TLBI_VAE3_Xt:
                              case MISCREG_TLBI_VALE3_Xt:
                              case MISCREG_TLBI_VAE2_Xt:
                              case MISCREG_TLBI_VALE2_Xt:
                              case MISCREG_TLBI_VAE1_Xt:
                              case MISCREG_TLBI_VALE1_Xt:
                              case MISCREG_TLBI_ASIDE1_Xt:
                              case MISCREG_TLBI_VAAE1_Xt:
                              case MISCREG_TLBI_VAALE1_Xt:
                              case MISCREG_TLBI_IPAS2E1_Xt:
                              case MISCREG_TLBI_IPAS2LE1_Xt:
                                return new Tlbi64LocalHub(
                                  machInst, miscReg, rt);
                              case MISCREG_TLBI_ALLE3IS:
                              case MISCREG_TLBI_ALLE2IS:
                              case MISCREG_TLBI_ALLE1IS:
                              case MISCREG_TLBI_VMALLS12E1IS:
                              case MISCREG_TLBI_VMALLE1IS:
                              case MISCREG_TLBI_VAE3IS_Xt:
                              case MISCREG_TLBI_VALE3IS_Xt:
                              case MISCREG_TLBI_VAE2IS_Xt:
                              case MISCREG_TLBI_VALE2IS_Xt:
                              case MISCREG_TLBI_VAE1IS_Xt:
                              case MISCREG_TLBI_VALE1IS_Xt:
                              case MISCREG_TLBI_ASIDE1IS_Xt:
                              case MISCREG_TLBI_VAAE1IS_Xt:
                              case MISCREG_TLBI_VAALE1IS_Xt:
                              case MISCREG_TLBI_IPAS2E1IS_Xt:
                              case MISCREG_TLBI_IPAS2LE1IS_Xt:
                                return new Tlbi64ShareableHub(
                                  machInst, miscReg, rt, dec.dvmEnabled);
                              default:
                                return new Msr64(machInst, miscReg, rt);
                            }
                        }
                    }
                  }
                  break;
                  default:
                    GEM5_UNREACHABLE;
                }
            } else if (bits(machInst, 25) == 0x1) {
                uint8_t opc = bits(machInst, 24, 21);
                uint8_t op2 = bits(machInst, 20, 16);
                uint8_t op3 = bits(machInst, 15, 12);
                RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
                RegIndex rm = (RegIndex)(uint8_t)bits(machInst, 4, 0);
                uint8_t op4 = bits(machInst, 4, 0);
                if (op2 != 0x1f || op3 != 0x0)
                    return new Unknown64(machInst);
                switch (opc) {
                  case 0x0:
                    if (bits(machInst, 11) == 0)
                        return new Br64(machInst, rn);
                    else if (op4 != 0x1f)
                        return new Unknown64(machInst);
                    // 24(Z):0, 11(A):1
                    if (bits(machInst, 10) == 0)
                        return new Braaz(machInst, rn);
                    else
                        return new Brabz(machInst, rn);
                  case 0x1:
                    if (bits(machInst, 11) == 0)
                        return new Blr64(machInst, rn);
                    else if (op4 != 0x1f)
                        return new Unknown64(machInst);
                    // 24(Z):0, 11(A):1
                    if (bits(machInst, 10) == 0)
                        return new Blraaz(machInst, rn);
                    else
                        return new Blrabz(machInst, rn);
                  case 0x2:
                    if (op4 == 0x1f) {
                        bool m = bits(machInst, 10);
                        if (m)
                            return new Retab(machInst);
                        else
                            return new Retaa(machInst);
                    } else
                        return new Ret64(machInst, rn);
                  case 0x4:
                    if (rn != 0x1f)
                        return new Unknown64(machInst);
                    if (bits(machInst, 11) == 0)
                        return new Eret64(machInst);
                    else if (op4 != 0x1f)
                        return new Unknown64(machInst);
                    // 24(Z):0, 11(A):1
                    if (bits(machInst, 10) == 0)
                        return new Eretaa(machInst);
                    else
                        return new Eretab(machInst);
                  case 0x5:
                    if (rn != 0x1f)
                        return new Unknown64(machInst);
                    return new FailUnimplemented("dret", machInst);
                  case 0x8:
                    if (bits(machInst, 11) == 0)
                        return new Unknown64(machInst);
                    if (bits(machInst, 10) == 0)
                        return new Braa(machInst, rn, makeSP(rm));
                    else
                        return new Brab(machInst, rn, makeSP(rm));
                  case 0x9:
                    if (bits(machInst, 11) == 0)
                        return new Unknown64(machInst);
                    if (bits(machInst, 10) == 0)
                        return new Blraa(machInst, rn, makeSP(rm));
                    else
                        return new Blrab(machInst, rn, makeSP(rm));
                  default:
                    return new Unknown64(machInst);
                }
            }
          [[fallthrough]];
          default:
            return new Unknown64(machInst);
        }
        return new FailUnimplemented("Unhandled Case7", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeAtomicArithOp(ExtMachInst machInst)
    {
        uint8_t opc  = bits(machInst, 14, 12);
        uint8_t o3  = bits(machInst, 15);
        uint8_t size_ar = bits(machInst, 23, 22)<<0 | bits(machInst, 31, 30)<<2;
        RegIndex rt = (RegIndex)(uint8_t)bits(machInst, 4, 0);
        RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
        RegIndex rnsp = makeSP(rn);
        RegIndex rs = (RegIndex)(uint8_t)bits(machInst, 20, 16);
        uint8_t  A_rt = bits(machInst, 4, 0)<<0 | bits(machInst, 23)<<5;

        switch(opc) {
            case 0x0:
                switch(size_ar){
                    case 0x0:
                        if (o3 == 1)
                            return new SWPB(machInst, rt, rnsp, rs);
                        else if (A_rt == 0x1f)
                            return new STADDB(machInst, rt, rnsp, rs);
                        else
                            return new LDADDB(machInst, rt, rnsp, rs);
                    case 0x1 :
                        if (o3 == 1)
                            return new SWPLB(machInst, rt, rnsp, rs);
                        else if (A_rt == 0x1f)
                            return new STADDLB(machInst, rt, rnsp, rs);
                        else
                            return new LDADDLB(machInst, rt, rnsp, rs);
                    case 0x2:
                        if (o3 == 1)
                            return new SWPAB(machInst, rt, rnsp, rs);
                        else
                            return new LDADDAB(machInst, rt, rnsp, rs);
                    case 0x3:
                        if (o3 == 1)
                            return new SWPLAB(machInst, rt, rnsp, rs);
                        else
                            return new LDADDLAB(machInst, rt, rnsp, rs);
                    case 0x4:
                        if (o3 == 1)
                            return new SWPH(machInst, rt, rnsp, rs);
                        else if (A_rt == 0x1f)
                            return new STADDH(machInst, rt, rnsp, rs);
                        else
                            return new LDADDH(machInst, rt, rnsp, rs);
                    case 0x5 :
                        if (o3 == 1)
                            return new SWPLH(machInst, rt, rnsp, rs);
                        else if (A_rt == 0x1f)
                            return new STADDLH(machInst, rt, rnsp, rs);
                        else
                            return new LDADDLH(machInst, rt, rnsp, rs);
                    case 0x6:
                        if (o3 == 1)
                            return new SWPAH(machInst, rt, rnsp, rs);
                        else
                            return new LDADDAH(machInst, rt, rnsp, rs);
                    case 0x7:
                        if (o3 == 1)
                            return new SWPLAH(machInst, rt, rnsp, rs);
                        else
                            return new LDADDLAH(machInst, rt, rnsp, rs);
                    case 0x8:
                        if (o3 == 1)
                            return new SWP(machInst, rt, rnsp, rs);
                        else if (A_rt == 0x1f)
                            return new STADD(machInst, rt, rnsp, rs);
                        else
                            return new LDADD(machInst, rt, rnsp, rs);
                    case 0x9 :
                        if (o3 == 1)
                            return new SWPL(machInst, rt, rnsp, rs);
                        else if (A_rt == 0x1f)
                            return new STADDL(machInst, rt, rnsp, rs);
                        else
                            return new LDADDL(machInst, rt, rnsp, rs);
                    case 0xa:
                        if (o3 == 1)
                            return new SWPA(machInst, rt, rnsp, rs);
                        else
                            return new LDADDA(machInst, rt, rnsp, rs);
                    case 0xb:
                        if (o3 == 1)
                            return new SWPLA(machInst, rt, rnsp, rs);
                        else
                            return new LDADDLA(machInst, rt, rnsp, rs);
                    case 0xc:
                        if (o3 == 1)
                            return new SWP64(machInst, rt, rnsp, rs);

                        else if (A_rt == 0x1f)
                            return new STADD64(machInst, rt, rnsp, rs);
                        else
                            return new LDADD64(machInst, rt, rnsp, rs);
                    case 0xd :
                        if (o3 == 1)
                            return new SWPL64(machInst, rt, rnsp, rs);
                        else if (A_rt == 0x1f)
                            return new STADDL64(machInst, rt, rnsp, rs);
                        else
                            return new LDADDL64(machInst, rt, rnsp, rs);
                    case 0xe:
                        if (o3 == 1)
                            return new SWPA64(machInst, rt, rnsp, rs);
                        else
                            return new LDADDA64(machInst, rt, rnsp, rs);
                    case 0xf:
                        if (o3 == 1)
                            return new SWPLA64(machInst, rt, rnsp, rs);
                        else
                            return new LDADDLA64(machInst, rt, rnsp, rs);
                    default:
                        GEM5_UNREACHABLE;
                }
            case 0x1:
                switch(size_ar){
                    case 0x0:
                        if (A_rt == 0x1f)
                            return new STCLRB(machInst, rt, rnsp, rs);
                        else
                            return new LDCLRB(machInst, rt, rnsp, rs);
                    case 0x1 :
                        if (A_rt == 0x1f)
                            return new STCLRLB(machInst, rt, rnsp, rs);
                        else
                            return new LDCLRLB(machInst, rt, rnsp, rs);
                    case 0x2:
                        return new LDCLRAB(machInst, rt, rnsp, rs);
                    case 0x3:
                        return new LDCLRLAB(machInst, rt, rnsp, rs);
                    case 0x4:
                        if (A_rt == 0x1f)
                            return new STCLRH(machInst, rt, rnsp, rs);
                        else
                            return new LDCLRH(machInst, rt, rnsp, rs);
                    case 0x5 :
                        if (A_rt == 0x1f)
                            return new STCLRLH(machInst, rt, rnsp, rs);
                        else
                            return new LDCLRLH(machInst, rt, rnsp, rs);
                    case 0x6:
                        return new LDCLRAH(machInst, rt, rnsp, rs);
                    case 0x7:
                        return new LDCLRLAH(machInst, rt, rnsp, rs);
                    case 0x8:
                        if (A_rt == 0x1f)
                            return new STCLR(machInst, rt, rnsp, rs);
                        else
                            return new LDCLR(machInst, rt, rnsp, rs);
                    case 0x9 :
                        if (A_rt == 0x1f)
                            return new STCLRL(machInst, rt, rnsp, rs);
                        else
                            return new LDCLRL(machInst, rt, rnsp, rs);
                    case 0xa:
                        return new LDCLRA(machInst, rt, rnsp, rs);
                    case 0xb:
                        return new LDCLRLA(machInst, rt, rnsp, rs);
                    case 0xc:
                        if (A_rt == 0x1f)
                            return new STCLR64(machInst, rt, rnsp, rs);
                        else
                            return new LDCLR64(machInst, rt, rnsp, rs);
                    case 0xd :
                        if (A_rt == 0x1f)
                            return new STCLRL64(machInst, rt, rnsp, rs);
                        else
                            return new LDCLRL64(machInst, rt, rnsp, rs);
                    case 0xe:
                        return new LDCLRA64(machInst, rt, rnsp, rs);
                    case 0xf:
                        return new LDCLRLA64(machInst, rt, rnsp, rs);
                    default:
                        GEM5_UNREACHABLE;
                }
            case 0x2:
                switch(size_ar){
                    case 0x0:
                        if (A_rt == 0x1f)
                            return new STEORB(machInst, rt, rnsp, rs);
                        else
                            return new LDEORB(machInst, rt, rnsp, rs);
                    case 0x1 :
                        if (A_rt == 0x1f)
                            return new STEORLB(machInst, rt, rnsp, rs);
                        else
                            return new LDEORLB(machInst, rt, rnsp, rs);
                    case 0x2:
                        return new LDEORAB(machInst, rt, rnsp, rs);
                    case 0x3:
                        return new LDEORLAB(machInst, rt, rnsp, rs);
                    case 0x4:
                        if (A_rt == 0x1f)
                            return new STEORH(machInst, rt, rnsp, rs);
                        else
                            return new LDEORH(machInst, rt, rnsp, rs);
                    case 0x5 :
                        if (A_rt == 0x1f)
                            return new STEORLH(machInst, rt, rnsp, rs);
                        else
                            return new LDEORLH(machInst, rt, rnsp, rs);
                    case 0x6:
                        return new LDEORAH(machInst, rt, rnsp, rs);
                    case 0x7:
                        return new LDEORLAH(machInst, rt, rnsp, rs);
                    case 0x8:
                        if (A_rt == 0x1f)
                            return new STEOR(machInst, rt, rnsp, rs);
                        else
                            return new LDEOR(machInst, rt, rnsp, rs);
                    case 0x9 :
                        if (A_rt == 0x1f)
                            return new STEORL(machInst, rt, rnsp, rs);
                        else
                            return new LDEORL(machInst, rt, rnsp, rs);
                    case 0xa:
                        return new LDEORA(machInst, rt, rnsp, rs);
                    case 0xb:
                        return new LDEORLA(machInst, rt, rnsp, rs);
                    case 0xc:
                        if (A_rt == 0x1f)
                            return new STEOR64(machInst, rt, rnsp, rs);
                        else
                            return new LDEOR64(machInst, rt, rnsp, rs);
                    case 0xd :
                        if (A_rt == 0x1f)
                            return new STEORL64(machInst, rt, rnsp, rs);
                        else
                            return new LDEORL64(machInst, rt, rnsp, rs);
                    case 0xe:
                        return new LDEORA64(machInst, rt, rnsp, rs);
                    case 0xf:
                        return new LDEORLA64(machInst, rt, rnsp, rs);
                    default:
                        GEM5_UNREACHABLE;
                }
            case 0x3:
                switch(size_ar){
                    case 0x0:
                        if (A_rt == 0x1f)
                            return new STSETB(machInst, rt, rnsp, rs);
                        else
                            return new LDSETB(machInst, rt, rnsp, rs);
                    case 0x1 :
                        if (A_rt == 0x1f)
                            return new STSETLB(machInst, rt, rnsp, rs);
                        else
                            return new LDSETLB(machInst, rt, rnsp, rs);
                    case 0x2:
                        return new LDSETAB(machInst, rt, rnsp, rs);
                    case 0x3:
                        return new LDSETLAB(machInst, rt, rnsp, rs);
                    case 0x4:
                        if (A_rt == 0x1f)
                            return new STSETH(machInst, rt, rnsp, rs);
                        else
                            return new LDSETH(machInst, rt, rnsp, rs);
                    case 0x5 :
                        if (A_rt == 0x1f)
                            return new STSETLH(machInst, rt, rnsp, rs);
                        else
                            return new LDSETLH(machInst, rt, rnsp, rs);
                    case 0x6:
                        return new LDSETAH(machInst, rt, rnsp, rs);
                    case 0x7:
                        return new LDSETLAH(machInst, rt, rnsp, rs);
                    case 0x8:
                        if (A_rt == 0x1f)
                            return new STSET(machInst, rt, rnsp, rs);
                        else
                            return new LDSET(machInst, rt, rnsp, rs);
                    case 0x9 :
                        if (A_rt == 0x1f)
                            return new STSETL(machInst, rt, rnsp, rs);
                        else
                            return new LDSETL(machInst, rt, rnsp, rs);
                    case 0xa:
                        return new LDSETA(machInst, rt, rnsp, rs);
                    case 0xb:
                        return new LDSETLA(machInst, rt, rnsp, rs);
                    case 0xc:
                        if (A_rt == 0x1f)
                            return new STSET64(machInst, rt, rnsp, rs);
                        else
                            return new LDSET64(machInst, rt, rnsp, rs);
                    case 0xd :
                        if (A_rt == 0x1f)
                            return new STSETL64(machInst, rt, rnsp, rs);
                        else
                            return new LDSETL64(machInst, rt, rnsp, rs);
                    case 0xe:
                        return new LDSETA64(machInst, rt, rnsp, rs);
                    case 0xf:
                        return new LDSETLA64(machInst, rt, rnsp, rs);
                    default:
                        GEM5_UNREACHABLE;
                }
            case 0x4:
                switch(size_ar){
                    case 0x0:
                        if (A_rt == 0x1f)
                            return new STSMAXB(machInst, rt, rnsp, rs);
                        else
                            return new LDSMAXB(machInst, rt, rnsp, rs);
                    case 0x1 :
                        if (A_rt == 0x1f)
                            return new STSMAXLB(machInst, rt, rnsp, rs);
                        else
                            return new LDSMAXLB(machInst, rt, rnsp, rs);
                    case 0x2:
                        return new LDSMAXAB(machInst, rt, rnsp, rs);
                    case 0x3:
                        return new LDSMAXLAB(machInst, rt, rnsp, rs);
                    case 0x4:
                        if (A_rt == 0x1f)
                            return new STSMAXH(machInst, rt, rnsp, rs);
                        else
                            return new LDSMAXH(machInst, rt, rnsp, rs);
                    case 0x5 :
                        if (A_rt == 0x1f)
                            return new STSMAXLH(machInst, rt, rnsp, rs);
                        else
                            return new LDSMAXLH(machInst, rt, rnsp, rs);
                    case 0x6:
                        return new LDSMAXAH(machInst, rt, rnsp, rs);
                    case 0x7:
                        return new LDSMAXLAH(machInst, rt, rnsp, rs);
                    case 0x8:
                        if (A_rt == 0x1f)
                            return new STSMAX(machInst, rt, rnsp, rs);
                        else
                            return new LDSMAX(machInst, rt, rnsp, rs);
                    case 0x9 :
                        if (A_rt == 0x1f)
                            return new STSMAXL(machInst, rt, rnsp, rs);
                        else
                            return new LDSMAXL(machInst, rt, rnsp, rs);
                    case 0xa:
                        return new LDSMAXA(machInst, rt, rnsp, rs);
                    case 0xb:
                        return new LDSMAXLA(machInst, rt, rnsp, rs);
                    case 0xc:
                        if (A_rt == 0x1f)
                            return new STSMAX64(machInst, rt, rnsp, rs);
                        else
                            return new LDSMAX64(machInst, rt, rnsp, rs);
                    case 0xd :
                        if (A_rt == 0x1f)
                            return new STSMAXL64(machInst, rt, rnsp, rs);
                        else
                            return new LDSMAXL64(machInst, rt, rnsp, rs);
                    case 0xe:
                        return new LDSMAXA64(machInst, rt, rnsp, rs);
                    case 0xf:
                        return new LDSMAXLA64(machInst, rt, rnsp, rs);
                    default:
                        GEM5_UNREACHABLE;
                }
            case 0x5:
                switch(size_ar){
                    case 0x0:
                        if (A_rt == 0x1f)
                            return new STSMINB(machInst, rt, rnsp, rs);
                        else
                            return new LDSMINB(machInst, rt, rnsp, rs);
                    case 0x1 :
                        if (A_rt == 0x1f)
                            return new STSMINLB(machInst, rt, rnsp, rs);
                        else
                            return new LDSMINLB(machInst, rt, rnsp, rs);
                    case 0x2:
                        return new LDSMINAB(machInst, rt, rnsp, rs);
                    case 0x3:
                        return new LDSMINLAB(machInst, rt, rnsp, rs);
                    case 0x4:
                        if (A_rt == 0x1f)
                            return new STSMINH(machInst, rt, rnsp, rs);
                        else
                            return new LDSMINH(machInst, rt, rnsp, rs);
                    case 0x5 :
                        if (A_rt == 0x1f)
                            return new STSMINLH(machInst, rt, rnsp, rs);
                        else
                            return new LDSMINLH(machInst, rt, rnsp, rs);
                    case 0x6:
                        return new LDSMINAH(machInst, rt, rnsp, rs);
                    case 0x7:
                        return new LDSMINLAH(machInst, rt, rnsp, rs);
                    case 0x8:
                        if (A_rt == 0x1f)
                            return new STSMIN(machInst, rt, rnsp, rs);
                        else
                            return new LDSMIN(machInst, rt, rnsp, rs);
                    case 0x9 :
                        if (A_rt == 0x1f)
                            return new STSMINL(machInst, rt, rnsp, rs);
                        else
                            return new LDSMINL(machInst, rt, rnsp, rs);
                    case 0xa:
                        return new LDSMINA(machInst, rt, rnsp, rs);
                    case 0xb:
                        return new LDSMINLA(machInst, rt, rnsp, rs);
                    case 0xc:
                        if (A_rt == 0x1f)
                            return new STSMIN64(machInst, rt, rnsp, rs);
                        else
                            return new LDSMIN64(machInst, rt, rnsp, rs);
                    case 0xd :
                        if (A_rt == 0x1f)
                            return new STSMINL64(machInst, rt, rnsp, rs);
                        else
                            return new LDSMINL64(machInst, rt, rnsp, rs);
                    case 0xe:
                        return new LDSMINA64(machInst, rt, rnsp, rs);
                    case 0xf:
                        return new LDSMINLA64(machInst, rt, rnsp, rs);
                    default:
                        GEM5_UNREACHABLE;
                }
            case 0x6:
                switch(size_ar){
                    case 0x0:
                        if (A_rt == 0x1f)
                            return new STUMAXB(machInst, rt, rnsp, rs);
                        else
                            return new LDUMAXB(machInst, rt, rnsp, rs);
                    case 0x1 :
                        if (A_rt == 0x1f)
                            return new STUMAXLB(machInst, rt, rnsp, rs);
                        else
                            return new LDUMAXLB(machInst, rt, rnsp, rs);
                    case 0x2:
                        return new LDUMAXAB(machInst, rt, rnsp, rs);
                    case 0x3:
                        return new LDUMAXLAB(machInst, rt, rnsp, rs);
                    case 0x4:
                        if (A_rt == 0x1f)
                            return new STUMAXH(machInst, rt, rnsp, rs);
                        else
                            return new LDUMAXH(machInst, rt, rnsp, rs);
                    case 0x5 :
                        if (A_rt == 0x1f)
                            return new STUMAXLH(machInst, rt, rnsp, rs);
                        else
                            return new LDUMAXLH(machInst, rt, rnsp, rs);
                    case 0x6:
                        return new LDUMAXAH(machInst, rt, rnsp, rs);
                    case 0x7:
                        return new LDUMAXLAH(machInst, rt, rnsp, rs);
                    case 0x8:
                        if (A_rt == 0x1f)
                            return new STUMAX(machInst, rt, rnsp, rs);
                        else
                            return new LDUMAX(machInst, rt, rnsp, rs);
                    case 0x9 :
                        if (A_rt == 0x1f)
                            return new STUMAXL(machInst, rt, rnsp, rs);
                        else
                            return new LDUMAXL(machInst, rt, rnsp, rs);
                    case 0xa:
                        return new LDUMAXA(machInst, rt, rnsp, rs);
                    case 0xb:
                        return new LDUMAXLA(machInst, rt, rnsp, rs);
                    case 0xc:
                        if (A_rt == 0x1f)
                            return new STUMAX64(machInst, rt, rnsp, rs);
                        else
                            return new LDUMAX64(machInst, rt, rnsp, rs);
                    case 0xd :
                        if (A_rt == 0x1f)
                            return new STUMAXL64(machInst, rt, rnsp, rs);
                        else
                            return new LDUMAXL64(machInst, rt, rnsp, rs);
                    case 0xe:
                        return new LDUMAXA64(machInst, rt, rnsp, rs);
                    case 0xf:
                        return new LDUMAXLA64(machInst, rt, rnsp, rs);
                    default:
                        GEM5_UNREACHABLE;
                }
            case 0x7:
                switch(size_ar){
                    case 0x0:
                        if (A_rt == 0x1f)
                            return new STUMINB(machInst, rt, rnsp, rs);
                        else
                            return new LDUMINB(machInst, rt, rnsp, rs);
                    case 0x1 :
                        if (A_rt == 0x1f)
                            return new STUMINLB(machInst, rt, rnsp, rs);
                        else
                            return new LDUMINLB(machInst, rt, rnsp, rs);
                    case 0x2:
                        return new LDUMINAB(machInst, rt, rnsp, rs);
                    case 0x3:
                        return new LDUMINLAB(machInst, rt, rnsp, rs);
                    case 0x4:
                        if (A_rt == 0x1f)
                            return new STUMINH(machInst, rt, rnsp, rs);
                        else
                            return new LDUMINH(machInst, rt, rnsp, rs);
                    case 0x5 :
                        if (A_rt == 0x1f)
                            return new STUMINLH(machInst, rt, rnsp, rs);
                        else
                            return new LDUMINLH(machInst, rt, rnsp, rs);
                    case 0x6:
                        return new LDUMINAH(machInst, rt, rnsp, rs);
                    case 0x7:
                        return new LDUMINLAH(machInst, rt, rnsp, rs);
                    case 0x8:
                        if (A_rt == 0x1f)
                            return new STUMIN(machInst, rt, rnsp, rs);
                        else
                            return new LDUMIN(machInst, rt, rnsp, rs);
                    case 0x9 :
                        if (A_rt == 0x1f)
                            return new STUMINL(machInst, rt, rnsp, rs);
                        else
                            return new LDUMINL(machInst, rt, rnsp, rs);
                    case 0xa:
                        return new LDUMINA(machInst, rt, rnsp, rs);
                    case 0xb:
                        return new LDUMINLA(machInst, rt, rnsp, rs);
                    case 0xc:
                        if (A_rt == 0x1f)
                            return new STUMIN64(machInst, rt, rnsp, rs);
                        else
                            return new LDUMIN64(machInst, rt, rnsp, rs);
                    case 0xd :
                        if (A_rt == 0x1f)
                            return new STUMINL64(machInst, rt, rnsp, rs);
                        else
                            return new LDUMINL64(machInst, rt, rnsp, rs);
                    case 0xe:
                        return new LDUMINA64(machInst, rt, rnsp, rs);
                    case 0xf:
                        return new LDUMINLA64(machInst, rt, rnsp, rs);
                    default:
                        GEM5_UNREACHABLE;
                }
            default:
                return new Unknown64(machInst);
        }
    }
}

namespace Aarch64
{

    StaticInstPtr
    decodeLoadsStores(ExtMachInst machInst)
    {
        // bit 27,25=10
        switch (bits(machInst, 29, 28)) {
          case 0x0:
            if (bits(machInst, 26) == 0) {
                if (bits(machInst, 24) != 0)
                    return new Unknown64(machInst);
                RegIndex rt = (RegIndex)(uint8_t)bits(machInst, 4, 0);
                RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
                RegIndex rnsp = makeSP(rn);
                RegIndex rt2 = (RegIndex)(uint8_t)bits(machInst, 14, 10);
                RegIndex rs = (RegIndex)(uint8_t)bits(machInst, 20, 16);
                uint8_t opc = (bits(machInst, 15) << 0) |
                              (bits(machInst, 23, 21) << 1);
                uint8_t size = bits(machInst, 31, 30);
                switch (opc) {
                  case 0x0:
                    switch (size) {
                      case 0x0:
                        return new STXRB64(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new STXRH64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new STXRW64(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new STXRX64(machInst, rt, rnsp, rs);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0x1:
                    switch (size) {
                      case 0x0:
                        return new STLXRB64(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new STLXRH64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new STLXRW64(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new STLXRX64(machInst, rt, rnsp, rs);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0x2:
                    switch (size) {
                      case 0x0:
                        return new CASP32(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new CASP64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new STXPW64(machInst, rs, rt, rt2, rnsp);
                      case 0x3:
                        return new STXPX64(machInst, rs, rt, rt2, rnsp);
                      default:
                        GEM5_UNREACHABLE;
                    }

                  case 0x3:
                    switch (size) {
                      case 0x0:
                        return new CASPL32(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new CASPL64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new STLXPW64(machInst, rs, rt, rt2, rnsp);
                      case 0x3:
                        return new STLXPX64(machInst, rs, rt, rt2, rnsp);
                      default:
                        GEM5_UNREACHABLE;
                    }

                  case 0x4:
                    switch (size) {
                      case 0x0:
                        return new LDXRB64(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new LDXRH64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new LDXRW64(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new LDXRX64(machInst, rt, rnsp, rs);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0x5:
                    switch (size) {
                      case 0x0:
                        return new LDAXRB64(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new LDAXRH64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new LDAXRW64(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new LDAXRX64(machInst, rt, rnsp, rs);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0x6:
                    switch (size) {
                      case 0x0:
                        return new CASPA32(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new CASPA64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new LDXPW64(machInst, rt, rt2, rnsp);
                      case 0x3:
                        return new LDXPX64(machInst, rt, rt2, rnsp);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0x7:
                    switch (size) {
                      case 0x0:
                        return new CASPAL32(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new CASPAL64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new LDAXPW64(machInst, rt, rt2, rnsp);
                      case 0x3:
                        return new LDAXPX64(machInst, rt, rt2, rnsp);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0x9:
                    switch (size) {
                      case 0x0:
                        return new STLRB64(machInst, rt, rnsp);
                      case 0x1:
                        return new STLRH64(machInst, rt, rnsp);
                      case 0x2:
                        return new STLRW64(machInst, rt, rnsp);
                      case 0x3:
                        return new STLRX64(machInst, rt, rnsp);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0xa:
                    switch (size) {
                      case 0x0:
                        return new CASB(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new CASH(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new CAS32(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new CAS64(machInst, rt, rnsp, rs);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0xb:
                    switch (size) {
                      case 0x0:
                        return new CASLB(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new CASLH(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new CASL32(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new CASL64(machInst, rt, rnsp, rs);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0xd:
                    switch (size) {
                      case 0x0:
                        return new LDARB64(machInst, rt, rnsp);
                      case 0x1:
                        return new LDARH64(machInst, rt, rnsp);
                      case 0x2:
                        return new LDARW64(machInst, rt, rnsp);
                      case 0x3:
                        return new LDARX64(machInst, rt, rnsp);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0xe:
                    switch (size) {
                      case 0x0:
                        return new CASAB(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new CASAH(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new CASA32(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new CASA64(machInst, rt, rnsp, rs);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  case 0xf:
                    switch (size) {
                      case 0x0:
                        return new CASALB(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new CASALH(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new CASAL32(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new CASAL64(machInst, rt, rnsp, rs);
                      default:
                        GEM5_UNREACHABLE;
                    }
                  default:
                    return new Unknown64(machInst);
                }
            } else if (bits(machInst, 31)) {
                return new Unknown64(machInst);
            } else {
                return decodeNeonMem(machInst);
            }
          case 0x1:
          {
            if (bits(machInst, 24) != 0)
                return new Unknown64(machInst);
            uint8_t switchVal = (bits(machInst, 26) << 0) |
                                (bits(machInst, 31, 30) << 1);
            int64_t imm = sext<19>(bits(machInst, 23, 5)) << 2;
            RegIndex rt = (RegIndex)(uint32_t)bits(machInst, 4, 0);
            switch (switchVal) {
              case 0x0:
                return new LDRWL64_LIT(machInst, rt, imm);
              case 0x1:
                return new LDRSFP64_LIT(machInst, rt, imm);
              case 0x2:
                return new LDRXL64_LIT(machInst, rt, imm);
              case 0x3:
                return new LDRDFP64_LIT(machInst, rt, imm);
              case 0x4:
                return new LDRSWL64_LIT(machInst, rt, imm);
              case 0x5:
                return new BigFpMemLit("ldr", machInst, rt, imm);
              case 0x6:
                return new PRFM64_LIT(machInst, rt, imm);
              default:
                return new Unknown64(machInst);
            }
          }
          case 0x2:
          {
            uint8_t opc = bits(machInst, 31, 30);
            if (opc >= 3)
                return new Unknown64(machInst);
            uint32_t size = 0;
            bool fp = bits(machInst, 26);
            bool load = bits(machInst, 22);
            if (fp) {
                size = 4 << opc;
            } else {
                if ((opc == 1) && !load)
                    return new Unknown64(machInst);
                size = (opc == 0 || opc == 1) ? 4 : 8;
            }
            uint8_t type = bits(machInst, 24, 23);
            int64_t imm = sext<7>(bits(machInst, 21, 15)) * size;

            RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
            RegIndex rt = (RegIndex)(uint8_t)bits(machInst, 4, 0);
            RegIndex rt2 = (RegIndex)(uint8_t)bits(machInst, 14, 10);

            bool noAlloc = (type == 0);
            bool signExt = !noAlloc && !fp && opc == 1;
            PairMemOp::AddrMode mode;
            const char *mnemonic = NULL;
            switch (type) {
              case 0x0:
              case 0x2:
                mode = PairMemOp::AddrMd_Offset;
                break;
              case 0x1:
                mode = PairMemOp::AddrMd_PostIndex;
                break;
              case 0x3:
                mode = PairMemOp::AddrMd_PreIndex;
                break;
              default:
                return new Unknown64(machInst);
            }
            if (load) {
                if (noAlloc)
                    mnemonic = "ldnp";
                else if (signExt)
                    mnemonic = "ldpsw";
                else
                    mnemonic = "ldp";
            } else {
                if (noAlloc)
                    mnemonic = "stnp";
                else
                    mnemonic = "stp";
            }

            return new LdpStp(mnemonic, machInst, size, fp, load, noAlloc,
                    signExt, false, false, imm, mode, rn, rt, rt2);
          }
          // bit 29:27=111, 25=0
          case 0x3:
          {
            uint8_t switchVal = (bits(machInst, 23, 22) << 0) |
                                (bits(machInst, 26) << 2) |
                                (bits(machInst, 31, 30) << 3);
            if (bits(machInst, 24) == 1) {
                uint64_t imm12 = bits(machInst, 21, 10);
                RegIndex rt = (RegIndex)(uint32_t)bits(machInst, 4, 0);
                RegIndex rn = (RegIndex)(uint32_t)bits(machInst, 9, 5);
                RegIndex rnsp = makeSP(rn);
                switch (switchVal) {
                  case 0x00:
                    return new STRB64_IMM(machInst, rt, rnsp, imm12);
                  case 0x01:
                    return new LDRB64_IMM(machInst, rt, rnsp, imm12);
                  case 0x02:
                    return new LDRSBX64_IMM(machInst, rt, rnsp, imm12);
                  case 0x03:
                    return new LDRSBW64_IMM(machInst, rt, rnsp, imm12);
                  case 0x04:
                    return new STRBFP64_IMM(machInst, rt, rnsp, imm12);
                  case 0x05:
                    return new LDRBFP64_IMM(machInst, rt, rnsp, imm12);
                  case 0x06:
                    return new BigFpMemImm("str", machInst, false,
                                           rt, rnsp, imm12 << 4);
                  case 0x07:
                    return new BigFpMemImm("ldr", machInst, true,
                                           rt, rnsp, imm12 << 4);
                  case 0x08:
                    return new STRH64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x09:
                    return new LDRH64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x0a:
                    return new LDRSHX64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x0b:
                    return new LDRSHW64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x0c:
                    return new STRHFP64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x0d:
                    return new LDRHFP64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x10:
                    return new STRW64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x11:
                    return new LDRW64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x12:
                    return new LDRSW64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x14:
                    return new STRSFP64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x15:
                    return new LDRSFP64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x18:
                    return new STRX64_IMM(machInst, rt, rnsp, imm12 << 3);
                  case 0x19:
                    return new LDRX64_IMM(machInst, rt, rnsp, imm12 << 3);
                  case 0x1a:
                    return new PRFM64_IMM(machInst, rt, rnsp, imm12 << 3);
                  case 0x1c:
                    return new STRDFP64_IMM(machInst, rt, rnsp, imm12 << 3);
                  case 0x1d:
                    return new LDRDFP64_IMM(machInst, rt, rnsp, imm12 << 3);
                  default:
                    return new Unknown64(machInst);
                }
            } else if (bits(machInst, 21) == 1) {
                uint8_t group = bits(machInst, 11, 10);
                switch (group) {
                  case 0x0:
                    {
                        if ((switchVal & 0x7) == 0x2 &&
                                bits(machInst, 20, 12) == 0x1fc) {
                            RegIndex rt = (RegIndex)(uint32_t)
                                bits(machInst, 4, 0);
                            RegIndex rn = (RegIndex)(uint32_t)
                                bits(machInst, 9, 5);
                            RegIndex rnsp = makeSP(rn);
                            uint8_t size = bits(machInst, 31, 30);
                            switch (size) {
                              case 0x0:
                                return new LDAPRB64(machInst, rt, rnsp);
                              case 0x1:
                                return new LDAPRH64(machInst, rt, rnsp);
                              case 0x2:
                                return new LDAPRW64(machInst, rt, rnsp);
                              case 0x3:
                                return new LDAPRX64(machInst, rt, rnsp);
                              default:
                                GEM5_UNREACHABLE;
                            }
                        } else {
                            return decodeAtomicArithOp(machInst);
                        }
                    }
                  case 0x1:
                  case 0x3:
                    {
                        RegIndex rt = (RegIndex)(uint32_t)
                                           bits(machInst, 4, 0);
                        RegIndex rn = (RegIndex)(uint32_t)
                                           bits(machInst, 9, 5);
                        uint8_t  s = bits(machInst, 22);
                        uint64_t imm9 = bits(machInst, 20, 12);
                        uint64_t imm10 = sext<10>(s<<9 | imm9)<<3;
                        uint8_t val = bits(machInst, 23)<<1
                                      | bits(machInst, 11);
                        switch (val) {
                          case 0x0:
                            return new LDRAA_REG(machInst, rt,
                                                 makeSP(rn), imm10);
                          case 0x1:
                            return new LDRAA_PRE(machInst, rt,
                                                 makeSP(rn), imm10);
                          case 0x2:
                            return new LDRAB_REG(machInst, rt,
                                                 makeSP(rn), imm10);
                          case 0x3:
                            return new LDRAB_PRE(machInst, rt,
                                                 makeSP(rn), imm10);
                          default:
                            GEM5_UNREACHABLE;
                        }
                    }
                  case 0x2:
                    {
                        if (!bits(machInst, 14))
                            return new Unknown64(machInst);
                        RegIndex rt = (RegIndex)(uint32_t)
                            bits(machInst, 4, 0);
                        RegIndex rn = (RegIndex)(uint32_t)
                            bits(machInst, 9, 5);
                        RegIndex rnsp = makeSP(rn);
                        RegIndex rm = (RegIndex)(uint32_t)
                            bits(machInst, 20, 16);
                        ArmExtendType type =
                            (ArmExtendType)(uint32_t)bits(machInst, 15, 13);
                        uint8_t s = bits(machInst, 12);
                        switch (switchVal) {
                          case 0x00:
                            return new STRB64_REG(machInst, rt, rnsp, rm,
                                                  type, 0);
                          case 0x01:
                            return new LDRB64_REG(machInst, rt, rnsp, rm,
                                                  type, 0);
                          case 0x02:
                            return new LDRSBX64_REG(machInst, rt, rnsp, rm,
                                                    type, 0);
                          case 0x03:
                            return new LDRSBW64_REG(machInst, rt, rnsp, rm,
                                                    type, 0);
                          case 0x04:
                            return new STRBFP64_REG(machInst, rt, rnsp, rm,
                                                    type, 0);
                          case 0x05:
                            return new LDRBFP64_REG(machInst, rt, rnsp, rm,
                                                    type, 0);
                          case 0x6:
                            return new BigFpMemReg("str", machInst, false,
                                                   rt, rnsp, rm, type, s * 4);
                          case 0x7:
                            return new BigFpMemReg("ldr", machInst, true,
                                                   rt, rnsp, rm, type, s * 4);
                          case 0x08:
                            return new STRH64_REG(machInst, rt, rnsp, rm,
                                                  type, s);
                          case 0x09:
                            return new LDRH64_REG(machInst, rt, rnsp, rm,
                                                  type, s);
                          case 0x0a:
                            return new LDRSHX64_REG(machInst, rt, rnsp, rm,
                                                    type, s);
                          case 0x0b:
                            return new LDRSHW64_REG(machInst, rt, rnsp, rm,
                                                    type, s);
                          case 0x0c:
                            return new STRHFP64_REG(machInst, rt, rnsp, rm,
                                                    type, s);
                          case 0x0d:
                            return new LDRHFP64_REG(machInst, rt, rnsp, rm,
                                                    type, s);
                          case 0x10:
                            return new STRW64_REG(machInst, rt, rnsp, rm,
                                                  type, s * 2);
                          case 0x11:
                            return new LDRW64_REG(machInst, rt, rnsp, rm,
                                                  type, s * 2);
                          case 0x12:
                            return new LDRSW64_REG(machInst, rt, rnsp, rm,
                                                   type, s * 2);
                          case 0x14:
                            return new STRSFP64_REG(machInst, rt, rnsp, rm,
                                                    type, s * 2);
                          case 0x15:
                            return new LDRSFP64_REG(machInst, rt, rnsp, rm,
                                                    type, s * 2);
                          case 0x18:
                            return new STRX64_REG(machInst, rt, rnsp, rm,
                                                  type, s * 3);
                          case 0x19:
                            return new LDRX64_REG(machInst, rt, rnsp, rm,
                                                  type, s * 3);
                          case 0x1a:
                            return new PRFM64_REG(machInst, rt, rnsp, rm,
                                                  type, s * 3);
                          case 0x1c:
                            return new STRDFP64_REG(machInst, rt, rnsp, rm,
                                                    type, s * 3);
                          case 0x1d:
                            return new LDRDFP64_REG(machInst, rt, rnsp, rm,
                                                    type, s * 3);
                          default:
                            return new Unknown64(machInst);

                        }
                    }
                  default:
                    return new Unknown64(machInst);
                }
            } else {
                // bit 29:27=111, 25:24=00, 21=0
                switch (bits(machInst, 11, 10)) {
                  case 0x0:
                  {
                    RegIndex rt =
                        (RegIndex)(uint32_t)bits(machInst, 4, 0);
                    RegIndex rn =
                        (RegIndex)(uint32_t)bits(machInst, 9, 5);
                    RegIndex rnsp = makeSP(rn);
                    uint64_t imm = sext<9>(bits(machInst, 20, 12));
                    switch (switchVal) {
                      case 0x00:
                        return new STURB64_IMM(machInst, rt, rnsp, imm);
                      case 0x01:
                        return new LDURB64_IMM(machInst, rt, rnsp, imm);
                      case 0x02:
                        return new LDURSBX64_IMM(machInst, rt, rnsp, imm);
                      case 0x03:
                        return new LDURSBW64_IMM(machInst, rt, rnsp, imm);
                      case 0x04:
                        return new STURBFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x05:
                        return new LDURBFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x06:
                        return new BigFpMemImm("stur", machInst, false,
                                               rt, rnsp, imm);
                      case 0x07:
                        return new BigFpMemImm("ldur", machInst, true,
                                               rt, rnsp, imm);
                      case 0x08:
                        return new STURH64_IMM(machInst, rt, rnsp, imm);
                      case 0x09:
                        return new LDURH64_IMM(machInst, rt, rnsp, imm);
                      case 0x0a:
                        return new LDURSHX64_IMM(machInst, rt, rnsp, imm);
                      case 0x0b:
                        return new LDURSHW64_IMM(machInst, rt, rnsp, imm);
                      case 0x0c:
                        return new STURHFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x0d:
                        return new LDURHFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x10:
                        return new STURW64_IMM(machInst, rt, rnsp, imm);
                      case 0x11:
                        return new LDURW64_IMM(machInst, rt, rnsp, imm);
                      case 0x12:
                        return new LDURSW64_IMM(machInst, rt, rnsp, imm);
                      case 0x14:
                        return new STURSFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x15:
                        return new LDURSFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x18:
                        return new STURX64_IMM(machInst, rt, rnsp, imm);
                      case 0x19:
                        return new LDURX64_IMM(machInst, rt, rnsp, imm);
                      case 0x1a:
                        return new PRFUM64_IMM(machInst, rt, rnsp, imm);
                      case 0x1c:
                        return new STURDFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x1d:
                        return new LDURDFP64_IMM(machInst, rt, rnsp, imm);
                      default:
                        return new Unknown64(machInst);
                    }
                  }
                  // bit 29:27=111, 25:24=00, 21=0, 11:10=01
                  case 0x1:
                  {
                    RegIndex rt =
                        (RegIndex)(uint32_t)bits(machInst, 4, 0);
                    RegIndex rn =
                        (RegIndex)(uint32_t)bits(machInst, 9, 5);
                    RegIndex rnsp = makeSP(rn);
                    uint64_t imm = sext<9>(bits(machInst, 20, 12));
                    switch (switchVal) {
                      case 0x00:
                        return new STRB64_POST(machInst, rt, rnsp, imm);
                      case 0x01:
                        return new LDRB64_POST(machInst, rt, rnsp, imm);
                      case 0x02:
                        return new LDRSBX64_POST(machInst, rt, rnsp, imm);
                      case 0x03:
                        return new LDRSBW64_POST(machInst, rt, rnsp, imm);
                      case 0x04:
                        return new STRBFP64_POST(machInst, rt, rnsp, imm);
                      case 0x05:
                        return new LDRBFP64_POST(machInst, rt, rnsp, imm);
                      case 0x06:
                        return new BigFpMemPost("str", machInst, false,
                                                rt, rnsp, imm);
                      case 0x07:
                        return new BigFpMemPost("ldr", machInst, true,
                                                rt, rnsp, imm);
                      case 0x08:
                        return new STRH64_POST(machInst, rt, rnsp, imm);
                      case 0x09:
                        return new LDRH64_POST(machInst, rt, rnsp, imm);
                      case 0x0a:
                        return new LDRSHX64_POST(machInst, rt, rnsp, imm);
                      case 0x0b:
                        return new LDRSHW64_POST(machInst, rt, rnsp, imm);
                      case 0x0c:
                        return new STRHFP64_POST(machInst, rt, rnsp, imm);
                      case 0x0d:
                        return new LDRHFP64_POST(machInst, rt, rnsp, imm);
                      case 0x10:
                        return new STRW64_POST(machInst, rt, rnsp, imm);
                      case 0x11:
                        return new LDRW64_POST(machInst, rt, rnsp, imm);
                      case 0x12:
                        return new LDRSW64_POST(machInst, rt, rnsp, imm);
                      case 0x14:
                        return new STRSFP64_POST(machInst, rt, rnsp, imm);
                      case 0x15:
                        return new LDRSFP64_POST(machInst, rt, rnsp, imm);
                      case 0x18:
                        return new STRX64_POST(machInst, rt, rnsp, imm);
                      case 0x19:
                        return new LDRX64_POST(machInst, rt, rnsp, imm);
                      case 0x1c:
                        return new STRDFP64_POST(machInst, rt, rnsp, imm);
                      case 0x1d:
                        return new LDRDFP64_POST(machInst, rt, rnsp, imm);
                      default:
                        return new Unknown64(machInst);
                    }
                  }
                  case 0x2:
                  {
                    RegIndex rt =
                        (RegIndex)(uint32_t)bits(machInst, 4, 0);
                    RegIndex rn =
                        (RegIndex)(uint32_t)bits(machInst, 9, 5);
                    RegIndex rnsp = makeSP(rn);
                    uint64_t imm = sext<9>(bits(machInst, 20, 12));
                    switch (switchVal) {
                      case 0x00:
                        return new STTRB64_IMM(machInst, rt, rnsp, imm);
                      case 0x01:
                        return new LDTRB64_IMM(machInst, rt, rnsp, imm);
                      case 0x02:
                        return new LDTRSBX64_IMM(machInst, rt, rnsp, imm);
                      case 0x03:
                        return new LDTRSBW64_IMM(machInst, rt, rnsp, imm);
                      case 0x08:
                        return new STTRH64_IMM(machInst, rt, rnsp, imm);
                      case 0x09:
                        return new LDTRH64_IMM(machInst, rt, rnsp, imm);
                      case 0x0a:
                        return new LDTRSHX64_IMM(machInst, rt, rnsp, imm);
                      case 0x0b:
                        return new LDTRSHW64_IMM(machInst, rt, rnsp, imm);
                      case 0x10:
                        return new STTRW64_IMM(machInst, rt, rnsp, imm);
                      case 0x11:
                        return new LDTRW64_IMM(machInst, rt, rnsp, imm);
                      case 0x12:
                        return new LDTRSW64_IMM(machInst, rt, rnsp, imm);
                      case 0x18:
                        return new STTRX64_IMM(machInst, rt, rnsp, imm);
                      case 0x19:
                        return new LDTRX64_IMM(machInst, rt, rnsp, imm);
                      default:
                        return new Unknown64(machInst);
                    }
                  }
                  case 0x3:
                  {
                    RegIndex rt =
                        (RegIndex)(uint32_t)bits(machInst, 4, 0);
                    RegIndex rn =
                        (RegIndex)(uint32_t)bits(machInst, 9, 5);
                    RegIndex rnsp = makeSP(rn);
                    uint64_t imm = sext<9>(bits(machInst, 20, 12));
                    switch (switchVal) {
                      case 0x00:
                        return new STRB64_PRE(machInst, rt, rnsp, imm);
                      case 0x01:
                        return new LDRB64_PRE(machInst, rt, rnsp, imm);
                      case 0x02:
                        return new LDRSBX64_PRE(machInst, rt, rnsp, imm);
                      case 0x03:
                        return new LDRSBW64_PRE(machInst, rt, rnsp, imm);
                      case 0x04:
                        return new STRBFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x05:
                        return new LDRBFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x06:
                        return new BigFpMemPre("str", machInst, false,
                                               rt, rnsp, imm);
                      case 0x07:
                        return new BigFpMemPre("ldr", machInst, true,
                                               rt, rnsp, imm);
                      case 0x08:
                        return new STRH64_PRE(machInst, rt, rnsp, imm);
                      case 0x09:
                        return new LDRH64_PRE(machInst, rt, rnsp, imm);
                      case 0x0a:
                        return new LDRSHX64_PRE(machInst, rt, rnsp, imm);
                      case 0x0b:
                        return new LDRSHW64_PRE(machInst, rt, rnsp, imm);
                      case 0x0c:
                        return new STRHFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x0d:
                        return new LDRHFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x10:
                        return new STRW64_PRE(machInst, rt, rnsp, imm);
                      case 0x11:
                        return new LDRW64_PRE(machInst, rt, rnsp, imm);
                      case 0x12:
                        return new LDRSW64_PRE(machInst, rt, rnsp, imm);
                      case 0x14:
                        return new STRSFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x15:
                        return new LDRSFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x18:
                        return new STRX64_PRE(machInst, rt, rnsp, imm);
                      case 0x19:
                        return new LDRX64_PRE(machInst, rt, rnsp, imm);
                      case 0x1c:
                        return new STRDFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x1d:
                        return new LDRDFP64_PRE(machInst, rt, rnsp, imm);
                      default:
                        return new Unknown64(machInst);
                    }
                  }
                  default:
                    GEM5_UNREACHABLE;
                }
            }
          }
          default:
            GEM5_UNREACHABLE;
        }
        return new FailUnimplemented("Unhandled Case1", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeDataProcReg(ExtMachInst machInst)
    {
        uint8_t switchVal = (bits(machInst, 28) << 1) |
                            (bits(machInst, 24) << 0);
        switch (switchVal) {
          case 0x0:
          {
            uint8_t switchVal = (bits(machInst, 21) << 0) |
                                (bits(machInst, 30, 29) << 1);
            ArmShiftType type = (ArmShiftType)(uint8_t)bits(machInst, 23, 22);
            uint8_t imm6 = bits(machInst, 15, 10);
            bool sf = bits(machInst, 31);
            if (!sf && (imm6 & 0x20))
                return new Unknown64(machInst);
            RegIndex rd = (RegIndex)(uint8_t)bits(machInst, 4, 0);
            RegIndex rdzr = makeZero(rd);
            RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
            RegIndex rm = (RegIndex)(uint8_t)bits(machInst, 20, 16);

            switch (switchVal) {
              case 0x0:
                return new AndXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x1:
                return new BicXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x2:
                return new OrrXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x3:
                return new OrnXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x4:
                return new EorXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x5:
                return new EonXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x6:
                return new AndXSRegCc(machInst, rdzr, rn, rm, imm6, type);
              case 0x7:
                return new BicXSRegCc(machInst, rdzr, rn, rm, imm6, type);
              default:
                GEM5_UNREACHABLE;
            }
          }
          case 0x1:
          {
            uint8_t switchVal = bits(machInst, 30, 29);
            if (bits(machInst, 21) == 0) {
                ArmShiftType type =
                    (ArmShiftType)(uint8_t)bits(machInst, 23, 22);
                if (type == ROR)
                    return new Unknown64(machInst);
                uint8_t imm6 = bits(machInst, 15, 10);
                if (!bits(machInst, 31) && bits(imm6, 5))
                    return new Unknown64(machInst);
                RegIndex rd = (RegIndex)(uint8_t)bits(machInst, 4, 0);
                RegIndex rdzr = makeZero(rd);
                RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
                RegIndex rm = (RegIndex)(uint8_t)bits(machInst, 20, 16);
                switch (switchVal) {
                  case 0x0:
                    return new AddXSReg(machInst, rdzr, rn, rm, imm6, type);
                  case 0x1:
                    return new AddXSRegCc(machInst, rdzr, rn, rm, imm6, type);
                  case 0x2:
                    return new SubXSReg(machInst, rdzr, rn, rm, imm6, type);
                  case 0x3:
                    return new SubXSRegCc(machInst, rdzr, rn, rm, imm6, type);
                  default:
                    GEM5_UNREACHABLE;
                }
            } else {
                if (bits(machInst, 23, 22) != 0 || bits(machInst, 12, 10) > 0x4)
                   return new Unknown64(machInst);
                ArmExtendType type =
                    (ArmExtendType)(uint8_t)bits(machInst, 15, 13);
                uint8_t imm3 = bits(machInst, 12, 10);
                RegIndex rd = (RegIndex)(uint8_t)bits(machInst, 4, 0);
                RegIndex rdsp = makeSP(rd);
                RegIndex rdzr = makeZero(rd);
                RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
                RegIndex rnsp = makeSP(rn);
                RegIndex rm = (RegIndex)(uint8_t)bits(machInst, 20, 16);

                switch (switchVal) {
                  case 0x0:
                    return new AddXEReg(machInst, rdsp, rnsp, rm, type, imm3);
                  case 0x1:
                    return new AddXERegCc(machInst, rdzr, rnsp, rm, type, imm3);
                  case 0x2:
                    return new SubXEReg(machInst, rdsp, rnsp, rm, type, imm3);
                  case 0x3:
                    return new SubXERegCc(machInst, rdzr, rnsp, rm, type, imm3);
                  default:
                    GEM5_UNREACHABLE;
                }
            }
          }
          case 0x2:
          {
            if (bits(machInst, 21) == 1)
                return new Unknown64(machInst);
            RegIndex rd = (RegIndex)(uint8_t)bits(machInst, 4, 0);
            RegIndex rdzr = makeZero(rd);
            RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
            RegIndex rm = (RegIndex)(uint8_t)bits(machInst, 20, 16);
            switch (bits(machInst, 23, 22)) {
              case 0x0:
              {
                if (bits(machInst, 15, 10))
                    return new Unknown64(machInst);
                uint8_t switchVal = bits(machInst, 30, 29);
                switch (switchVal) {
                  case 0x0:
                    return new AdcXSReg(machInst, rdzr, rn, rm, 0, LSL);
                  case 0x1:
                    return new AdcXSRegCc(machInst, rdzr, rn, rm, 0, LSL);
                  case 0x2:
                    return new SbcXSReg(machInst, rdzr, rn, rm, 0, LSL);
                  case 0x3:
                    return new SbcXSRegCc(machInst, rdzr, rn, rm, 0, LSL);
                  default:
                    GEM5_UNREACHABLE;
                }
              }
              case 0x1:
              {
                if ((bits(machInst, 4) == 1) ||
                        (bits(machInst, 10) == 1) ||
                        (bits(machInst, 29) == 0)) {
                    return new Unknown64(machInst);
                }
                ConditionCode cond =
                    (ConditionCode)(uint8_t)bits(machInst, 15, 12);
                uint8_t flags = bits(machInst, 3, 0);
                RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
                if (bits(machInst, 11) == 0) {
                    RegIndex rm =
                        (RegIndex)(uint8_t)bits(machInst, 20, 16);
                    if (bits(machInst, 30) == 0) {
                        return new CcmnReg64(machInst, rn, rm, cond, flags);
                    } else {
                        return new CcmpReg64(machInst, rn, rm, cond, flags);
                    }
                } else {
                    uint8_t imm5 = bits(machInst, 20, 16);
                    if (bits(machInst, 30) == 0) {
                        return new CcmnImm64(machInst, rn, imm5, cond, flags);
                    } else {
                        return new CcmpImm64(machInst, rn, imm5, cond, flags);
                    }
                }
              }
              case 0x2:
              {
                if (bits(machInst, 29) == 1 ||
                        bits(machInst, 11) == 1) {
                    return new Unknown64(machInst);
                }
                uint8_t switchVal = (bits(machInst, 10) << 0) |
                                    (bits(machInst, 30) << 1);
                RegIndex rd = (RegIndex)(uint8_t)bits(machInst, 4, 0);
                RegIndex rdzr = makeZero(rd);
                RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
                RegIndex rm = (RegIndex)(uint8_t)bits(machInst, 20, 16);
                ConditionCode cond =
                    (ConditionCode)(uint8_t)bits(machInst, 15, 12);
                switch (switchVal) {
                  case 0x0:
                    return new Csel64(machInst, rdzr, rn, rm, cond);
                  case 0x1:
                    return new Csinc64(machInst, rdzr, rn, rm, cond);
                  case 0x2:
                    return new Csinv64(machInst, rdzr, rn, rm, cond);
                  case 0x3:
                    return new Csneg64(machInst, rdzr, rn, rm, cond);
                  default:
                    GEM5_UNREACHABLE;
                }
              }
              case 0x3:
                if (bits(machInst, 30) == 0) {
                    if (bits(machInst, 29) != 0)
                        return new Unknown64(machInst);
                    uint8_t switchVal = bits(machInst, 15, 10);
                    switch (switchVal) {
                      case 0x2:
                        return new Udiv64(machInst, rdzr, rn, rm);
                      case 0x3:
                        return new Sdiv64(machInst, rdzr, rn, rm);
                      case 0x8:
                        return new Lslv64(machInst, rdzr, rn, rm);
                      case 0x9:
                        return new Lsrv64(machInst, rdzr, rn, rm);
                      case 0xa:
                        return new Asrv64(machInst, rdzr, rn, rm);
                      case 0xb:
                        return new Rorv64(machInst, rdzr, rn, rm);
                     case 0xc:
                        return new Pacga(machInst, rd, rn, makeSP(rm));
                      case 0x10:
                        return new Crc32b64(machInst, rdzr, rn, rm);
                      case 0x11:
                        return new Crc32h64(machInst, rdzr, rn, rm);
                      case 0x12:
                        return new Crc32w64(machInst, rdzr, rn, rm);
                      case 0x13:
                        return new Crc32x64(machInst, rdzr, rn, rm);
                      case 0x14:
                        return new Crc32cb64(machInst, rdzr, rn, rm);
                      case 0x15:
                        return new Crc32ch64(machInst, rdzr, rn, rm);
                      case 0x16:
                        return new Crc32cw64(machInst, rdzr, rn, rm);
                      case 0x17:
                        return new Crc32cx64(machInst, rdzr, rn, rm);
                      default:
                        return new Unknown64(machInst);
                    }
                } else {
                    uint8_t dm = bits(machInst, 20, 14);
                    switch(dm){
                        case 0x4:
                        {
                          uint8_t zflags = bits(machInst, 13, 10);
                          switch (zflags) {
                            case 0x0:
                                return new Pacia(machInst, rd, makeSP(rn));
                            case 0x1:
                                return new Pacib(machInst, rd, makeSP(rn));
                            case 0x2:
                                return new Pacda(machInst, rd, makeSP(rn));
                            case 0x3:
                                return new Pacdb(machInst, rd, makeSP(rn));
                            case 0x4:
                                return new Autia(machInst, rd, makeSP(rn));
                            case 0x5:
                                return new Autib(machInst, rd, makeSP(rn));
                            case 0x6:
                                return new Autda(machInst, rd, makeSP(rn));
                            case 0x7:
                                return new Autdb(machInst, rd, makeSP(rn));
                            case 0x8:
                                if (rn == 0x1f)
                                    return new Paciza(machInst, rd,
                                                      int_reg::Zero);
                                else
                                    return new Unknown64(machInst);
                            case 0x9:
                                if (rn == 0x1f)
                                    return new Pacizb(machInst, rd,
                                                      int_reg::Zero);
                                else
                                    return new Unknown64(machInst);
                            case 0xa:
                                if (rn == 0x1f)
                                    return new Pacdza(machInst, rd,
                                                      int_reg::Zero);
                                else
                                    return new Unknown64(machInst);
                            case 0xb:
                                if (rn == 0x1f)
                                    return new Pacdzb(machInst, rd,
                                                      int_reg::Zero);
                                else
                                    return new Unknown64(machInst);
                            case 0xc:
                                if (rn == 0x1f)
                                    return new Autiza(machInst, rd,
                                                      int_reg::Zero);
                                else
                                    return new Unknown64(machInst);
                            case 0xd:
                                if (rn == 0x1f)
                                    return new Autizb(machInst, rd,
                                                      int_reg::Zero);
                                else
                                    return new Unknown64(machInst);
                            case 0xe:
                                if (rn == 0x1f)
                                    return new Autdza(machInst, rd,
                                                      int_reg::Zero);
                                else
                                    return new Unknown64(machInst);
                            case 0xf:
                                if (rn == 0x1f)
                                    return new Autdzb(machInst, rd,
                                                      int_reg::Zero);
                                else
                                    return new Unknown64(machInst);
                            default:
                                return new Unknown64(machInst);
                          }
                        }
                        case 0x5:
                          {
                            if (rn != 0x1f)
                                return new Unknown64(machInst);
                            bool d = bits(machInst,10);
                            if (d)
                                return new Xpacd(machInst, rd);
                            else
                                return new Xpaci(machInst, rd);
                          }
                    }
                    if (dm != 0 || bits(machInst, 29) != 0) {
                        // dm !=0 and dm != 0x1
                        return new Unknown64(machInst);
                    }
                    uint8_t switchVal = bits(machInst, 15, 10);
                    switch (switchVal) {
                      case 0x0:
                        return new Rbit64(machInst, rdzr, rn);
                      case 0x1:
                        return new Rev1664(machInst, rdzr, rn);
                      case 0x2:
                        if (bits(machInst, 31) == 0)
                            return new Rev64(machInst, rdzr, rn);
                        else
                            return new Rev3264(machInst, rdzr, rn);
                      case 0x3:
                        if (bits(machInst, 31) != 1)
                            return new Unknown64(machInst);
                        return new Rev64(machInst, rdzr, rn);
                      case 0x4:
                        return new Clz64(machInst, rdzr, rn);
                      case 0x5:
                        return new Cls64(machInst, rdzr, rn);
                      default:
                        return new Unknown64(machInst);
                    }
                }
              default:
                GEM5_UNREACHABLE;
            }
          }
          case 0x3:
          {
            if (bits(machInst, 30, 29) != 0x0 ||
                    (bits(machInst, 23, 21) != 0 && bits(machInst, 31) == 0))
                return new Unknown64(machInst);
            RegIndex rd = (RegIndex)(uint8_t)bits(machInst, 4, 0);
            RegIndex rdzr = makeZero(rd);
            RegIndex rn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
            RegIndex ra = (RegIndex)(uint8_t)bits(machInst, 14, 10);
            RegIndex rm = (RegIndex)(uint8_t)bits(machInst, 20, 16);
            switch (bits(machInst, 23, 21)) {
              case 0x0:
                if (bits(machInst, 15) == 0)
                    return new Madd64(machInst, rdzr, ra, rn, rm);
                else
                    return new Msub64(machInst, rdzr, ra, rn, rm);
              case 0x1:
                if (bits(machInst, 15) == 0)
                    return new Smaddl64(machInst, rdzr, ra, rn, rm);
                else
                    return new Smsubl64(machInst, rdzr, ra, rn, rm);
              case 0x2:
                if (bits(machInst, 15) != 0)
                    return new Unknown64(machInst);
                return new Smulh64(machInst, rdzr, rn, rm);
              case 0x5:
                if (bits(machInst, 15) == 0)
                    return new Umaddl64(machInst, rdzr, ra, rn, rm);
                else
                    return new Umsubl64(machInst, rdzr, ra, rn, rm);
              case 0x6:
                if (bits(machInst, 15) != 0)
                    return new Unknown64(machInst);
                return new Umulh64(machInst, rdzr, rn, rm);
              default:
                return new Unknown64(machInst);
            }
          }
          default:
            GEM5_UNREACHABLE;
        }
        return new FailUnimplemented("Unhandled Case2", machInst);
    }
}

namespace Aarch64
{
    template <typename DecoderFeatures>
    StaticInstPtr
    decodeAdvSIMD(ExtMachInst machInst)
    {
        if (bits(machInst, 24) == 1) {
            if (bits(machInst, 10) == 0) {
                return decodeNeonIndexedElem<DecoderFeatures>(machInst);
            } else if (bits(machInst, 23) == 1) {
                return new Unknown64(machInst);
            } else {
                if (bits(machInst, 22, 19)) {
                    return decodeNeonShiftByImm(machInst);
                } else {
                    return decodeNeonModImm(machInst);
                }
            }
        } else if (bits(machInst, 21) == 1) {
            if (bits(machInst, 10) == 1) {
                return decodeNeon3Same<DecoderFeatures>(machInst);
            } else if (bits(machInst, 11) == 0) {
                return decodeNeon3Diff(machInst);
            } else if (bits(machInst, 20, 17) == 0x0) {
                return decodeNeon2RegMisc(machInst);
            } else if (bits(machInst, 20, 17) == 0x4) {
                return decodeCryptoAES(machInst);
            } else if (bits(machInst, 20, 17) == 0x8) {
                return decodeNeonAcrossLanes(machInst);
            } else {
                return new Unknown64(machInst);
            }
        } else if (bits(machInst, 15) == 1) {
            return decodeNeon3SameExtra<DecoderFeatures>(machInst);
        } else if (bits(machInst, 10) == 1) {
            if (bits(machInst, 23, 22))
                return new Unknown64(machInst);
            return decodeNeonCopy(machInst);
        } else if (bits(machInst, 29) == 1) {
            return decodeNeonExt(machInst);
        } else if (bits(machInst, 11) == 1) {
            return decodeNeonZipUzpTrn(machInst);
        } else if (bits(machInst, 23, 22) == 0x0) {
            return decodeNeonTblTbx(machInst);
        } else {
            return new Unknown64(machInst);
        }
        return new FailUnimplemented("Unhandled Case3", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    // bit 30=0, 28:25=1111
    decodeFp(ExtMachInst machInst)
    {
        if (bits(machInst, 24) == 1) {
            if (bits(machInst, 31) || bits(machInst, 29))
                return new Unknown64(machInst);
            RegIndex rd    = (RegIndex)(uint32_t)bits(machInst, 4, 0);
            RegIndex rn    = (RegIndex)(uint32_t)bits(machInst, 9, 5);
            RegIndex rm    = (RegIndex)(uint32_t)bits(machInst, 20, 16);
            RegIndex ra    = (RegIndex)(uint32_t)bits(machInst, 14, 10);
            uint8_t switchVal = (bits(machInst, 23, 21) << 1) |
                                (bits(machInst, 15)     << 0);
            switch (switchVal) {
              case 0x0: // FMADD Sd = Sa + Sn*Sm
                return new FMAddS(machInst, rd, rn, rm, ra);
              case 0x1: // FMSUB Sd = Sa + (-Sn)*Sm
                return new FMSubS(machInst, rd, rn, rm, ra);
              case 0x2: // FNMADD Sd = (-Sa) + (-Sn)*Sm
                return new FNMAddS(machInst, rd, rn, rm, ra);
              case 0x3: // FNMSUB Sd = (-Sa) + Sn*Sm
                return new FNMSubS(machInst, rd, rn, rm, ra);
              case 0x4: // FMADD Dd = Da + Dn*Dm
                return new FMAddD(machInst, rd, rn, rm, ra);
              case 0x5: // FMSUB Dd = Da + (-Dn)*Dm
                return new FMSubD(machInst, rd, rn, rm, ra);
              case 0x6: // FNMADD Dd = (-Da) + (-Dn)*Dm
                return new FNMAddD(machInst, rd, rn, rm, ra);
              case 0x7: // FNMSUB Dd = (-Da) + Dn*Dm
                return new FNMSubD(machInst, rd, rn, rm, ra);
              default:
                return new Unknown64(machInst);
            }
        } else if (bits(machInst, 21) == 0) {
            bool s = bits(machInst, 29);
            if (s)
                return new Unknown64(machInst);
            uint8_t switchVal = bits(machInst, 20, 16);
            uint8_t type      = bits(machInst, 23, 22);
            uint8_t scale     = bits(machInst, 15, 10);
            RegIndex rd    = (RegIndex)(uint32_t)bits(machInst, 4, 0);
            RegIndex rn    = (RegIndex)(uint32_t)bits(machInst, 9, 5);
            if (bits(machInst, 18, 17) == 3 && scale != 0)
                return new Unknown64(machInst);
            // 30:24=0011110, 21=0
            switch (switchVal) {
              case 0x00:
                return new FailUnimplemented("fcvtns", machInst);
              case 0x01:
                return new FailUnimplemented("fcvtnu", machInst);
              case 0x02:
                switch ( (bits(machInst, 31) << 2) | type ) {
                  case 0: // SCVTF Sd = convertFromInt(Wn/(2^fbits))
                    return new FcvtSFixedFpSW(machInst, rd, rn, scale);
                  case 1: // SCVTF Dd = convertFromInt(Wn/(2^fbits))
                    return new FcvtSFixedFpDW(machInst, rd, rn, scale);
                  case 4: // SCVTF Sd = convertFromInt(Xn/(2^fbits))
                    return new FcvtSFixedFpSX(machInst, rd, rn, scale);
                  case 5: // SCVTF Dd = convertFromInt(Xn/(2^fbits))
                    return new FcvtSFixedFpDX(machInst, rd, rn, scale);
                  default:
                    return new Unknown64(machInst);
                }
              case 0x03:
                switch ( (bits(machInst, 31) << 2) | type ) {
                  case 0: // UCVTF Sd = convertFromInt(Wn/(2^fbits))
                    return new FcvtUFixedFpSW(machInst, rd, rn, scale);
                  case 1: // UCVTF Dd = convertFromInt(Wn/(2^fbits))
                    return new FcvtUFixedFpDW(machInst, rd, rn, scale);
                  case 4: // UCVTF Sd = convertFromInt(Xn/(2^fbits))
                    return new FcvtUFixedFpSX(machInst, rd, rn, scale);
                  case 5: // UCVTF Dd = convertFromInt(Xn/(2^fbits))
                    return new FcvtUFixedFpDX(machInst, rd, rn, scale);
                  default:
                    return new Unknown64(machInst);
                }
              case 0x04:
                return new FailUnimplemented("fcvtas", machInst);
              case 0x05:
                return new FailUnimplemented("fcvtau", machInst);
              case 0x08:
                return new FailUnimplemented("fcvtps", machInst);
              case 0x09:
                return new FailUnimplemented("fcvtpu", machInst);
              case 0x0e:
                return new FailUnimplemented("fmov elem. to 64", machInst);
              case 0x0f:
                return new FailUnimplemented("fmov 64 bit", machInst);
              case 0x10:
                return new FailUnimplemented("fcvtms", machInst);
              case 0x11:
                return new FailUnimplemented("fcvtmu", machInst);
              case 0x18:
                switch ( (bits(machInst, 31) << 2) | type ) {
                  case 0: // FCVTZS Wd = convertToIntExactTowardZero(Sn*(2^fbits))
                    return new FcvtFpSFixedSW(machInst, rd, rn, scale);
                  case 1: // FCVTZS Wd = convertToIntExactTowardZero(Dn*(2^fbits))
                    return new FcvtFpSFixedDW(machInst, rd, rn, scale);
                  case 4: // FCVTZS Xd = convertToIntExactTowardZero(Sn*(2^fbits))
                    return new FcvtFpSFixedSX(machInst, rd, rn, scale);
                  case 5: // FCVTZS Xd = convertToIntExactTowardZero(Dn*(2^fbits))
                    return new FcvtFpSFixedDX(machInst, rd, rn, scale);
                  default:
                    return new Unknown64(machInst);
                }
              case 0x19:
                switch ( (bits(machInst, 31) << 2) | type ) {
                  case 0: // FCVTZU Wd = convertToIntExactTowardZero(Sn*(2^fbits))
                    return new FcvtFpUFixedSW(machInst, rd, rn, scale);
                  case 1: // FCVTZU Wd = convertToIntExactTowardZero(Dn*(2^fbits))
                    return new FcvtFpUFixedDW(machInst, rd, rn, scale);
                  case 4: // FCVTZU Xd = convertToIntExactTowardZero(Sn*(2^fbits))
                    return new FcvtFpUFixedSX(machInst, rd, rn, scale);
                  case 5: // FCVTZU Xd = convertToIntExactTowardZero(Dn*(2^fbits))
                    return new FcvtFpUFixedDX(machInst, rd, rn, scale);
                  default:
                    return new Unknown64(machInst);
                }
              default:
                return new Unknown64(machInst);
            }
        } else {
            // 30=0, 28:24=11110, 21=1
            uint8_t type   = bits(machInst, 23, 22);
            uint8_t imm8   = bits(machInst, 20, 13);
            RegIndex rd = (RegIndex)(uint32_t)bits(machInst, 4, 0);
            RegIndex rn = (RegIndex)(uint32_t)bits(machInst, 9, 5);
            switch (bits(machInst, 11, 10)) {
              case 0x0:
                if (bits(machInst, 12) == 1) {
                    if (bits(machInst, 31) ||
                            bits(machInst, 29) ||
                            bits(machInst, 9, 5)) {
                        return new Unknown64(machInst);
                    }
                    // 31:29=000, 28:24=11110, 21=1, 12:10=100
                    if (type == 0) {
                        // FMOV S[d] = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,5)
                        //             :bits(imm8, 5, 0):Zeros(19)
                        uint32_t imm = vfp_modified_imm(imm8,
                                                        FpDataType::Fp32);
                        return new FmovImmS(machInst, rd, imm);
                    } else if (type == 1) {
                        // FMOV D[d] = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,8)
                        //             :bits(imm8, 5, 0):Zeros(48)
                        uint64_t imm = vfp_modified_imm(imm8,
                                                        FpDataType::Fp64);
                        return new FmovImmD(machInst, rd, imm);
                    } else {
                        return new Unknown64(machInst);
                    }
                } else if (bits(machInst, 13) == 1) {
                    if (bits(machInst, 31) ||
                            bits(machInst, 29) ||
                            bits(machInst, 15, 14) ||
                            bits(machInst, 23) ||
                            bits(machInst, 2, 0)) {
                        return new Unknown64(machInst);
                    }
                    uint8_t switchVal = (bits(machInst, 4, 3) << 0) |
                                        (bits(machInst, 22) << 2);
                    RegIndex rm = (RegIndex)(uint32_t)
                                        bits(machInst, 20, 16);
                    // 28:23=000111100, 21=1, 15:10=001000, 2:0=000
                    switch (switchVal) {
                      case 0x0:
                        // FCMP flags = compareQuiet(Sn,Sm)
                        return new FCmpRegS(machInst, rn, rm);
                      case 0x1:
                        // FCMP flags = compareQuiet(Sn,0.0)
                        return new FCmpImmS(machInst, rn, 0);
                      case 0x2:
                        // FCMPE flags = compareSignaling(Sn,Sm)
                        return new FCmpERegS(machInst, rn, rm);
                      case 0x3:
                        // FCMPE flags = compareSignaling(Sn,0.0)
                        return new FCmpEImmS(machInst, rn, 0);
                      case 0x4:
                        // FCMP flags = compareQuiet(Dn,Dm)
                        return new FCmpRegD(machInst, rn, rm);
                      case 0x5:
                        // FCMP flags = compareQuiet(Dn,0.0)
                        return new FCmpImmD(machInst, rn, 0);
                      case 0x6:
                        // FCMPE flags = compareSignaling(Dn,Dm)
                        return new FCmpERegD(machInst, rn, rm);
                      case 0x7:
                        // FCMPE flags = compareSignaling(Dn,0.0)
                        return new FCmpEImmD(machInst, rn, 0);
                      default:
                        return new Unknown64(machInst);
                    }
                } else if (bits(machInst, 14) == 1) {
                    if (bits(machInst, 31) || bits(machInst, 29))
                        return new Unknown64(machInst);
                    uint8_t opcode = bits(machInst, 20, 15);
                    // Bits 31:24=00011110, 21=1, 14:10=10000
                    switch (opcode) {
                      case 0x0:
                        if (type == 0)
                            // FMOV Sd = Sn
                            return new FmovRegS(machInst, rd, rn);
                        else if (type == 1)
                            // FMOV Dd = Dn
                            return new FmovRegD(machInst, rd, rn);
                        break;
                      case 0x1:
                        if (type == 0)
                            // FABS Sd = abs(Sn)
                            return new FAbsS(machInst, rd, rn);
                        else if (type == 1)
                            // FABS Dd = abs(Dn)
                            return new FAbsD(machInst, rd, rn);
                        break;
                      case 0x2:
                        if (type == 0)
                            // FNEG Sd = -Sn
                            return new FNegS(machInst, rd, rn);
                        else if (type == 1)
                            // FNEG Dd = -Dn
                            return new FNegD(machInst, rd, rn);
                        break;
                      case 0x3:
                        if (type == 0)
                            // FSQRT Sd = sqrt(Sn)
                            return new FSqrtS(machInst, rd, rn);
                        else if (type == 1)
                            // FSQRT Dd = sqrt(Dn)
                            return new FSqrtD(machInst, rd, rn);
                        break;
                      case 0x4:
                        if (type == 1)
                            // FCVT Sd = convertFormat(Dn)
                            return new FcvtFpDFpS(machInst, rd, rn);
                        else if (type == 3)
                            // FCVT Sd = convertFormat(Hn)
                            return new FcvtFpHFpS(machInst, rd, rn);
                        break;
                      case 0x5:
                        if (type == 0)
                            // FCVT Dd = convertFormat(Sn)
                            return new FCvtFpSFpD(machInst, rd, rn);
                        else if (type == 3)
                            // FCVT Dd = convertFormat(Hn)
                            return new FcvtFpHFpD(machInst, rd, rn);
                        break;
                      case 0x7:
                        if (type == 0)
                            // FCVT Hd = convertFormat(Sn)
                            return new FcvtFpSFpH(machInst, rd, rn);
                        else if (type == 1)
                            // FCVT Hd = convertFormat(Dn)
                            return new FcvtFpDFpH(machInst, rd, rn);
                        break;
                      case 0x8:
                        if (type == 0) // FRINTN Sd = roundToIntegralTiesToEven(Sn)
                            return new FRIntNS(machInst, rd, rn);
                        else if (type == 1) // FRINTN Dd = roundToIntegralTiesToEven(Dn)
                            return new FRIntND(machInst, rd, rn);
                        break;
                      case 0x9:
                        if (type == 0) // FRINTP Sd = roundToIntegralTowardPlusInf(Sn)
                            return new FRIntPS(machInst, rd, rn);
                        else if (type == 1) // FRINTP Dd = roundToIntegralTowardPlusInf(Dn)
                            return new FRIntPD(machInst, rd, rn);
                        break;
                      case 0xa:
                        if (type == 0) // FRINTM Sd = roundToIntegralTowardMinusInf(Sn)
                            return new FRIntMS(machInst, rd, rn);
                        else if (type == 1) // FRINTM Dd = roundToIntegralTowardMinusInf(Dn)
                            return new FRIntMD(machInst, rd, rn);
                        break;
                      case 0xb:
                        if (type == 0) // FRINTZ Sd = roundToIntegralTowardZero(Sn)
                            return new FRIntZS(machInst, rd, rn);
                        else if (type == 1) // FRINTZ Dd = roundToIntegralTowardZero(Dn)
                            return new FRIntZD(machInst, rd, rn);
                        break;
                      case 0xc:
                        if (type == 0) // FRINTA Sd = roundToIntegralTiesToAway(Sn)
                            return new FRIntAS(machInst, rd, rn);
                        else if (type == 1) // FRINTA Dd = roundToIntegralTiesToAway(Dn)
                            return new FRIntAD(machInst, rd, rn);
                        break;
                      case 0xe:
                        if (type == 0) // FRINTX Sd = roundToIntegralExact(Sn)
                            return new FRIntXS(machInst, rd, rn);
                        else if (type == 1) // FRINTX Dd = roundToIntegralExact(Dn)
                            return new FRIntXD(machInst, rd, rn);
                        break;
                      case 0xf:
                        if (type == 0) // FRINTI Sd = roundToIntegral(Sn)
                            return new FRIntIS(machInst, rd, rn);
                        else if (type == 1) // FRINTI Dd = roundToIntegral(Dn)
                            return new FRIntID(machInst, rd, rn);
                        break;
                      default:
                        return new Unknown64(machInst);
                    }
                    return new Unknown64(machInst);
                } else if (bits(machInst, 15) == 1) {
                    return new Unknown64(machInst);
                } else {
                    if (bits(machInst, 29))
                        return new Unknown64(machInst);
                    uint8_t rmode      = bits(machInst, 20, 19);
                    uint8_t switchVal1 = bits(machInst, 18, 16);
                    uint8_t switchVal2 = (type << 1) | bits(machInst, 31);
                    // 30:24=0011110, 21=1, 15:10=000000
                    switch (switchVal1) {
                      case 0x0:
                        switch ((switchVal2 << 2) | rmode) {
                          case 0x0: //FCVTNS Wd = convertToIntExactTiesToEven(Sn)
                            return new FcvtFpSIntWSN(machInst, rd, rn);
                          case 0x1: //FCVTPS Wd = convertToIntExactTowardPlusInf(Sn)
                            return new FcvtFpSIntWSP(machInst, rd, rn);
                          case 0x2: //FCVTMS Wd = convertToIntExactTowardMinusInf(Sn)
                            return new FcvtFpSIntWSM(machInst, rd, rn);
                          case 0x3: //FCVTZS Wd = convertToIntExactTowardZero(Sn)
                            return new FcvtFpSIntWSZ(machInst, rd, rn);
                          case 0x4: //FCVTNS Xd = convertToIntExactTiesToEven(Sn)
                            return new FcvtFpSIntXSN(machInst, rd, rn);
                          case 0x5: //FCVTPS Xd = convertToIntExactTowardPlusInf(Sn)
                            return new FcvtFpSIntXSP(machInst, rd, rn);
                          case 0x6: //FCVTMS Xd = convertToIntExactTowardMinusInf(Sn)
                            return new FcvtFpSIntXSM(machInst, rd, rn);
                          case 0x7: //FCVTZS Xd = convertToIntExactTowardZero(Sn)
                            return new FcvtFpSIntXSZ(machInst, rd, rn);
                          case 0x8: //FCVTNS Wd = convertToIntExactTiesToEven(Dn)
                            return new FcvtFpSIntWDN(machInst, rd, rn);
                          case 0x9: //FCVTPS Wd = convertToIntExactTowardPlusInf(Dn)
                            return new FcvtFpSIntWDP(machInst, rd, rn);
                          case 0xA: //FCVTMS Wd = convertToIntExactTowardMinusInf(Dn)
                            return new FcvtFpSIntWDM(machInst, rd, rn);
                          case 0xB: //FCVTZS Wd = convertToIntExactTowardZero(Dn)
                            return new FcvtFpSIntWDZ(machInst, rd, rn);
                          case 0xC: //FCVTNS Xd = convertToIntExactTiesToEven(Dn)
                            return new FcvtFpSIntXDN(machInst, rd, rn);
                          case 0xD: //FCVTPS Xd = convertToIntExactTowardPlusInf(Dn)
                            return new FcvtFpSIntXDP(machInst, rd, rn);
                          case 0xE: //FCVTMS Xd = convertToIntExactTowardMinusInf(Dn)
                            return new FcvtFpSIntXDM(machInst, rd, rn);
                          case 0xF: //FCVTZS Xd = convertToIntExactTowardZero(Dn)
                            return new FcvtFpSIntXDZ(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x1:
                        switch ((switchVal2 << 2) | rmode) {
                          case 0x0: //FCVTNU Wd = convertToIntExactTiesToEven(Sn)
                            return new FcvtFpUIntWSN(machInst, rd, rn);
                          case 0x1: //FCVTPU Wd = convertToIntExactTowardPlusInf(Sn)
                            return new FcvtFpUIntWSP(machInst, rd, rn);
                          case 0x2: //FCVTMU Wd = convertToIntExactTowardMinusInf(Sn)
                            return new FcvtFpUIntWSM(machInst, rd, rn);
                          case 0x3: //FCVTZU Wd = convertToIntExactTowardZero(Sn)
                            return new FcvtFpUIntWSZ(machInst, rd, rn);
                          case 0x4: //FCVTNU Xd = convertToIntExactTiesToEven(Sn)
                            return new FcvtFpUIntXSN(machInst, rd, rn);
                          case 0x5: //FCVTPU Xd = convertToIntExactTowardPlusInf(Sn)
                            return new FcvtFpUIntXSP(machInst, rd, rn);
                          case 0x6: //FCVTMU Xd = convertToIntExactTowardMinusInf(Sn)
                            return new FcvtFpUIntXSM(machInst, rd, rn);
                          case 0x7: //FCVTZU Xd = convertToIntExactTowardZero(Sn)
                            return new FcvtFpUIntXSZ(machInst, rd, rn);
                          case 0x8: //FCVTNU Wd = convertToIntExactTiesToEven(Dn)
                            return new FcvtFpUIntWDN(machInst, rd, rn);
                          case 0x9: //FCVTPU Wd = convertToIntExactTowardPlusInf(Dn)
                            return new FcvtFpUIntWDP(machInst, rd, rn);
                          case 0xA: //FCVTMU Wd = convertToIntExactTowardMinusInf(Dn)
                            return new FcvtFpUIntWDM(machInst, rd, rn);
                          case 0xB: //FCVTZU Wd = convertToIntExactTowardZero(Dn)
                            return new FcvtFpUIntWDZ(machInst, rd, rn);
                          case 0xC: //FCVTNU Xd = convertToIntExactTiesToEven(Dn)
                            return new FcvtFpUIntXDN(machInst, rd, rn);
                          case 0xD: //FCVTPU Xd = convertToIntExactTowardPlusInf(Dn)
                            return new FcvtFpUIntXDP(machInst, rd, rn);
                          case 0xE: //FCVTMU Xd = convertToIntExactTowardMinusInf(Dn)
                            return new FcvtFpUIntXDM(machInst, rd, rn);
                          case 0xF: //FCVTZU Xd = convertToIntExactTowardZero(Dn)
                            return new FcvtFpUIntXDZ(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x2:
                        if (rmode != 0)
                            return new Unknown64(machInst);
                        switch (switchVal2) {
                          case 0: // SCVTF Sd = convertFromInt(Wn)
                            return new FcvtWSIntFpS(machInst, rd, rn);
                          case 1: // SCVTF Sd = convertFromInt(Xn)
                            return new FcvtXSIntFpS(machInst, rd, rn);
                          case 2: // SCVTF Dd = convertFromInt(Wn)
                            return new FcvtWSIntFpD(machInst, rd, rn);
                          case 3: // SCVTF Dd = convertFromInt(Xn)
                            return new FcvtXSIntFpD(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x3:
                        switch (switchVal2) {
                          case 0: // UCVTF Sd = convertFromInt(Wn)
                            return new FcvtWUIntFpS(machInst, rd, rn);
                          case 1: // UCVTF Sd = convertFromInt(Xn)
                            return new FcvtXUIntFpS(machInst, rd, rn);
                          case 2: // UCVTF Dd = convertFromInt(Wn)
                            return new FcvtWUIntFpD(machInst, rd, rn);
                          case 3: // UCVTF Dd = convertFromInt(Xn)
                            return new FcvtXUIntFpD(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x4:
                        if (rmode != 0)
                            return new Unknown64(machInst);
                        switch (switchVal2) {
                          case 0: // FCVTAS Wd = convertToIntExactTiesToAway(Sn)
                            return new FcvtFpSIntWSA(machInst, rd, rn);
                          case 1: // FCVTAS Xd = convertToIntExactTiesToAway(Sn)
                            return new FcvtFpSIntXSA(machInst, rd, rn);
                          case 2: // FCVTAS Wd = convertToIntExactTiesToAway(Dn)
                            return new FcvtFpSIntWDA(machInst, rd, rn);
                          case 3: // FCVTAS Wd = convertToIntExactTiesToAway(Dn)
                            return new FcvtFpSIntXDA(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x5:
                        switch (switchVal2) {
                          case 0: // FCVTAU Wd = convertToIntExactTiesToAway(Sn)
                            return new FcvtFpUIntWSA(machInst, rd, rn);
                          case 1: // FCVTAU Xd = convertToIntExactTiesToAway(Sn)
                            return new FcvtFpUIntXSA(machInst, rd, rn);
                          case 2: // FCVTAU Wd = convertToIntExactTiesToAway(Dn)
                            return new FcvtFpUIntWDA(machInst, rd, rn);
                          case 3: // FCVTAU Xd = convertToIntExactTiesToAway(Dn)
                            return new FcvtFpUIntXDA(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x06:
                        switch (switchVal2) {
                          case 0: // FMOV Wd = Sn
                            if (rmode != 0)
                                return new Unknown64(machInst);
                            return new FmovRegCoreW(machInst, rd, rn);
                          case 2:
                            return new FJcvtFpSFixedDW(machInst, rd, rn);
                          case 3: // FMOV Xd = Dn
                            if (rmode != 0)
                                return new Unknown64(machInst);
                            return new FmovRegCoreX(machInst, rd, rn);
                          case 5: // FMOV Xd = bits(Vn, 127, 64)
                            if (rmode != 1)
                                return new Unknown64(machInst);
                            return new FmovURegCoreX(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                        break;
                      case 0x07:
                        switch (switchVal2) {
                          case 0: // FMOV Sd = Wn
                            if (rmode != 0)
                                return new Unknown64(machInst);
                            return new FmovCoreRegW(machInst, rd, rn);
                          case 3: // FMOV Xd = Dn
                            if (rmode != 0)
                                return new Unknown64(machInst);
                            return new FmovCoreRegX(machInst, rd, rn);
                          case 5: // FMOV Xd = bits(Vn, 127, 64)
                            if (rmode != 1)
                                return new Unknown64(machInst);
                            return new FmovUCoreRegX(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                        break;
                      default: // Warning! missing cases in switch statement above, that still need to be added
                        return new Unknown64(machInst);
                    }
                }
                GEM5_UNREACHABLE;
              case 0x1:
              {
                if (bits(machInst, 31) ||
                    bits(machInst, 29) ||
                    bits(machInst, 23)) {
                    return new Unknown64(machInst);
                }
                RegIndex rm = (RegIndex)(uint32_t) bits(machInst, 20, 16);
                RegIndex rn = (RegIndex)(uint32_t) bits(machInst, 9, 5);
                uint8_t    imm = (RegIndex)(uint32_t) bits(machInst, 3, 0);
                ConditionCode cond =
                    (ConditionCode)(uint8_t)(bits(machInst, 15, 12));
                uint8_t switchVal = (bits(machInst, 4) << 0) |
                                    (bits(machInst, 22) << 1);
                // 31:23=000111100, 21=1, 11:10=01
                switch (switchVal) {
                  case 0x0:
                    // FCCMP flags = if cond the compareQuiet(Sn,Sm) else #nzcv
                    return new FCCmpRegS(machInst, rn, rm, cond, imm);
                  case 0x1:
                    // FCCMP flags = if cond then compareSignaling(Sn,Sm)
                    //               else #nzcv
                    return new FCCmpERegS(machInst, rn, rm, cond, imm);
                  case 0x2:
                    // FCCMP flags = if cond then compareQuiet(Dn,Dm) else #nzcv
                    return new FCCmpRegD(machInst, rn, rm, cond, imm);
                  case 0x3:
                    // FCCMP flags = if cond then compareSignaling(Dn,Dm)
                    //               else #nzcv
                    return new FCCmpERegD(machInst, rn, rm, cond, imm);
                  default:
                    return new Unknown64(machInst);
                }
              }
              case 0x2:
              {
                if (bits(machInst, 31) ||
                        bits(machInst, 29) ||
                        bits(machInst, 23)) {
                    return new Unknown64(machInst);
                }
                RegIndex rd = (RegIndex)(uint32_t)bits(machInst,  4,  0);
                RegIndex rn = (RegIndex)(uint32_t)bits(machInst,  9,  5);
                RegIndex rm = (RegIndex)(uint32_t)bits(machInst, 20, 16);
                uint8_t switchVal = (bits(machInst, 15, 12) << 0) |
                                    (bits(machInst, 22) << 4);
                switch (switchVal) {
                  case 0x00: // FMUL Sd = Sn * Sm
                    return new FMulS(machInst, rd, rn, rm);
                  case 0x10: // FMUL Dd = Dn * Dm
                    return new FMulD(machInst, rd, rn, rm);
                  case 0x01: // FDIV Sd = Sn / Sm
                    return new FDivS(machInst, rd, rn, rm);
                  case 0x11: // FDIV Dd = Dn / Dm
                    return new FDivD(machInst, rd, rn, rm);
                  case 0x02: // FADD Sd = Sn + Sm
                    return new FAddS(machInst, rd, rn, rm);
                  case 0x12: // FADD Dd = Dn + Dm
                    return new FAddD(machInst, rd, rn, rm);
                  case 0x03: // FSUB Sd = Sn - Sm
                    return new FSubS(machInst, rd, rn, rm);
                  case 0x13: // FSUB Dd = Dn - Dm
                    return new FSubD(machInst, rd, rn, rm);
                  case 0x04: // FMAX Sd = max(Sn, Sm)
                    return new FMaxS(machInst, rd, rn, rm);
                  case 0x14: // FMAX Dd = max(Dn, Dm)
                    return new FMaxD(machInst, rd, rn, rm);
                  case 0x05: // FMIN Sd = min(Sn, Sm)
                    return new FMinS(machInst, rd, rn, rm);
                  case 0x15: // FMIN Dd = min(Dn, Dm)
                    return new FMinD(machInst, rd, rn, rm);
                  case 0x06: // FMAXNM Sd = maxNum(Sn, Sm)
                    return new FMaxNMS(machInst, rd, rn, rm);
                  case 0x16: // FMAXNM Dd = maxNum(Dn, Dm)
                    return new FMaxNMD(machInst, rd, rn, rm);
                  case 0x07: // FMINNM Sd = minNum(Sn, Sm)
                    return new FMinNMS(machInst, rd, rn, rm);
                  case 0x17: // FMINNM Dd = minNum(Dn, Dm)
                    return new FMinNMD(machInst, rd, rn, rm);
                  case 0x08: // FNMUL Sd = -(Sn * Sm)
                    return new FNMulS(machInst, rd, rn, rm);
                  case 0x18: // FNMUL Dd = -(Dn * Dm)
                    return new FNMulD(machInst, rd, rn, rm);
                  default:
                    return new Unknown64(machInst);
                }
              }
              case 0x3:
              {
                if (bits(machInst, 31) || bits(machInst, 29))
                    return new Unknown64(machInst);
                uint8_t type = bits(machInst, 23, 22);
                RegIndex rd = (RegIndex)(uint32_t)bits(machInst,  4,  0);
                RegIndex rn = (RegIndex)(uint32_t)bits(machInst,  9,  5);
                RegIndex rm = (RegIndex)(uint32_t)bits(machInst, 20, 16);
                ConditionCode cond =
                    (ConditionCode)(uint8_t)(bits(machInst, 15, 12));
                if (type == 0) // FCSEL Sd = if cond then Sn else Sm
                    return new FCSelS(machInst, rd, rn, rm, cond);
                else if (type == 1) // FCSEL Dd = if cond then Dn else Dm
                    return new FCSelD(machInst, rd, rn, rm, cond);
                else
                    return new Unknown64(machInst);
              }
              default:
                GEM5_UNREACHABLE;
            }
        }
        GEM5_UNREACHABLE;
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeAdvSIMDScalar(ExtMachInst machInst)
    {
        if (bits(machInst, 24) == 1) {
            if (bits(machInst, 10) == 0) {
                return decodeNeonScIndexedElem(machInst);
            } else if (bits(machInst, 23) == 0) {
                return decodeNeonScShiftByImm(machInst);
            }
        } else if (bits(machInst, 21) == 1) {
            if (bits(machInst, 10) == 1) {
                return decodeNeonSc3Same(machInst);
            } else if (bits(machInst, 11) == 0) {
                return decodeNeonSc3Diff(machInst);
            } else if (bits(machInst, 20, 17) == 0x0) {
                return decodeNeonSc2RegMisc(machInst);
            } else if (bits(machInst, 20, 17) == 0x4) {
                return decodeCryptoTwoRegSHA(machInst);
            } else if (bits(machInst, 20, 17) == 0x8) {
                return decodeNeonScPwise(machInst);
            } else {
                return new Unknown64(machInst);
            }
        } else if (bits(machInst, 15) && bits(machInst, 10) == 1) {
            return decodeNeonSc3SameExtra(machInst);
        } else if (bits(machInst, 23, 22) == 0 &&
                   bits(machInst, 15) == 0) {
            if (bits(machInst, 10) == 1) {
                return decodeNeonScCopy(machInst);
            } else {
                return decodeCryptoThreeRegSHA(machInst);
            }
        } else {
            return new Unknown64(machInst);
        }
        return new FailUnimplemented("Unhandled Case6", machInst);
    }
}

namespace Aarch64
{
    template <typename DecoderFeatures>
    StaticInstPtr
    decodeFpAdvSIMD(ExtMachInst machInst)
    {

        if (bits(machInst, 28) == 0) {
            if (bits(machInst, 31) == 0) {
                return decodeAdvSIMD<DecoderFeatures>(machInst);
            } else {
                return new Unknown64(machInst);
            }
        } else if (bits(machInst, 30) == 0) {
            return decodeFp(machInst);
        } else if (bits(machInst, 31) == 0) {
            return decodeAdvSIMDScalar(machInst);
        } else {
            return new Unknown64(machInst);
        }
    }
}

namespace Aarch64
{
template StaticInstPtr decodeFpAdvSIMD<GenericDecoder>(ExtMachInst machInst);

}
namespace Aarch64
{
    template <typename DecoderFeatures>
    StaticInstPtr
    decodeNeon3Same(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 15, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t size_q = (size << 1) | q;
        uint8_t sz_q = size_q & 0x3;

        switch (opcode) {
          case 0x00:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UhaddDX, UhaddQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<ShaddDX, ShaddQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x01:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UqaddDX, UqaddQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SqaddDX, SqaddQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x02:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UrhaddDX, UrhaddQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SrhaddDX, SrhaddQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x03:
            switch (size) {
              case 0x0:
                if (u) {
                    if (q)
                        return new EorQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new EorDX<uint64_t>(machInst, vd, vn, vm);
                } else {
                    if (q)
                        return new AndQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new AndDX<uint64_t>(machInst, vd, vn, vm);
                }
              case 0x1:
                if (u) {
                    if (q)
                        return new BslQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new BslDX<uint64_t>(machInst, vd, vn, vm);
                } else {
                    if (q)
                        return new BicQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new BicDX<uint64_t>(machInst, vd, vn, vm);
                }
              case 0x2:
                if (u) {
                    if (q)
                        return new BitQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new BitDX<uint64_t>(machInst, vd, vn, vm);
                } else {
                    if (q)
                        return new OrrQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new OrrDX<uint64_t>(machInst, vd, vn, vm);
                }
              case 0x3:
                if (u) {
                    if (q)
                        return new BifQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new BifDX<uint64_t>(machInst, vd, vn, vm);
                } else {
                    if (q)
                        return new OrnQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new OrnDX<uint64_t>(machInst, vd, vn, vm);
                }
              default:
                GEM5_UNREACHABLE;
            }
          case 0x04:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UhsubDX, UhsubQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<ShsubDX, ShsubQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x05:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UqsubDX, UqsubQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SqsubDX, SqsubQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x06:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<CmhiDX, CmhiQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<CmgtDX, CmgtQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x07:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<CmhsDX, CmhsQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<CmgeDX, CmgeQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x08:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UshlDX, UshlQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SshlDX, SshlQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x09:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UqshlDX, UqshlQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SqshlDX, SqshlQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0a:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UrshlDX, UrshlQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SrshlDX, SrshlQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0b:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UqrshlDX, UqrshlQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SqrshlDX, SqrshlQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0c:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmaxDX, UmaxQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmaxDX, SmaxQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0d:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UminDX, UminQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SminDX, SminQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0e:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UabdDX, UabdQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SabdDX, SabdQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0f:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UabaDX, UabaQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SabaDX, SabaQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x10:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<SubDX, SubQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeXReg<AddDX, AddQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x11:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<CmeqDX, CmeqQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeXReg<CmtstDX, CmtstQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x12:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<MlsDX, MlsQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeSReg<MlaDX, MlaQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x13:
            if (size == 0x3 || (size != 0x0 && bits(machInst, 29)))
                return new Unknown64(machInst);
            if (u) {
                if (q)
                    return new PmulQX<uint8_t>(machInst, vd, vn, vm);
                else
                    return new PmulDX<uint8_t>(machInst, vd, vn, vm);
            } else {
                return decodeNeonUThreeSReg<MulDX, MulQX>(
                    q, size, machInst, vd, vn, vm);
            }
          case 0x14:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmaxpDX, UmaxpQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmaxpDX, SmaxpQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x15:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UminpDX, UminpQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SminpDX, SminpQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x16:
            if (size == 0x3 || size == 0x0)
                return new Unknown64(machInst);
            if (u) {
                if (q)
                    return decodeNeonSThreeHAndWReg<SqrdmulhQX>(
                        size, machInst, vd, vn, vm);
                else
                    return decodeNeonSThreeHAndWReg<SqrdmulhDX>(
                        size, machInst, vd, vn, vm);
            } else {
                if (q)
                    return decodeNeonSThreeHAndWReg<SqdmulhQX>(
                        size, machInst, vd, vn, vm);
                else
                    return decodeNeonSThreeHAndWReg<SqdmulhDX>(
                        size, machInst, vd, vn, vm);
            }
          case 0x17:
            if (u || size_q == 0x6)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeXReg<AddpDX, AddpQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x18:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FmaxnmpDX, FmaxnmpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FmaxnmDX, FmaxnmQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FminnmpDX, FminnmpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FminnmDX, FminnmQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          case 0x19:
            if (size < 0x2) {
                if (u || sz_q == 0x2)
                    return new Unknown64(machInst);
                else
                    return decodeNeonUThreeFpReg<FmlaDX, FmlaQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u || sz_q == 0x2)
                    return new Unknown64(machInst);
                else
                    return decodeNeonUThreeFpReg<FmlsDX, FmlsQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          case 0x1a:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FaddpDX, FaddpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FaddDX, FaddQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FabdDX, FabdQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FsubDX, FsubQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          case 0x1b:
            if (size < 0x2 && sz_q != 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FmulDX, FmulQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FmulxDX, FmulxQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                return new Unknown64(machInst);
            }
          case 0x1c:
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FcmgeDX, FcmgeQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FcmeqDX, FcmeqQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FcmgtDX, FcmgtQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return new Unknown64(machInst);
            }
          case 0x1d:
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FacgeDX, FacgeQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return new Unknown64(machInst);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FacgtDX, FacgtQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return new Unknown64(machInst);
            }
          case 0x1e:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FmaxpDX, FmaxpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FmaxDX, FmaxQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FminpDX, FminpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FminDX, FminQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          case 0x1f:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FdivDX, FdivQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FrecpsDX, FrecpsQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return new Unknown64(machInst);
                else
                    return decodeNeonUThreeFpReg<FrsqrtsDX, FrsqrtsQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    template <typename DecoderFeatures>
    StaticInstPtr
    decodeNeon3SameExtra(ExtMachInst machInst)
    {
        uint8_t q      = bits(machInst, 30);
        uint8_t size   = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 15, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x10:
            if (q)
                return decodeNeonSThreeHAndWReg<SqrdmlahQX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeHAndWReg<SqrdmlahDX>(
                    size, machInst, vd, vn, vm);
          case 0x11:
            if (q)
                return decodeNeonSThreeHAndWReg<SqrdmlshQX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeHAndWReg<SqrdmlshDX>(
                    size, machInst, vd, vn, vm);
          case 0x18:
          case 0x19:
          case 0x1a:
          case 0x1b:
            if (size == 0x1) {
               if (q)
                   return new FcmlaQX<uint16_t>(machInst, vd, vn, vm);
               else
                   return new FcmlaDX<uint16_t>(machInst, vd, vn, vm);
            } else
            return decodeNeonUThreeFpReg<FcmlaDX, FcmlaQX>(
                                q, size & 0x1, machInst, vd, vn, vm);

          case 0x1c:
          case 0x1e:
            if (size == 0x1) {
               if (q)
                   return new FcaddQX<uint16_t>(machInst, vd, vn, vm);
               else
                   return new FcaddDX<uint16_t>(machInst, vd, vn, vm);
            } else
                return decodeNeonUThreeFpReg<FcaddDX, FcaddQX>(
                                    q, size & 0x1, machInst, vd, vn, vm);

          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeon3Diff(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 15, 12);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x0:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UaddlX, Uaddl2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SaddlX, Saddl2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x1:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UaddwX, Uaddw2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SaddwX, Saddw2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x2:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UsublX, Usubl2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SsublX, Ssubl2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x3:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UsubwX, Usubw2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SsubwX, Ssubw2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x4:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<RaddhnX, Raddhn2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeSReg<AddhnX, Addhn2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x5:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UabalX, Uabal2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SabalX, Sabal2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x6:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<RsubhnX, Rsubhn2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeSReg<SubhnX, Subhn2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x7:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UabdlX, Uabdl2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SabdlX, Sabdl2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x8:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmlalX, Umlal2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmlalX, Smlal2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x9:
            if (u || (size == 0x0 || size == 0x3)) {
                return new Unknown64(machInst);
            } else {
                if (q) {
                    return decodeNeonSThreeHAndWReg<Sqdmlal2X>(
                        size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeHAndWReg<SqdmlalX>(
                        size, machInst, vd, vn, vm);
                }
            }
          case 0xa:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmlslX, Umlsl2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmlslX, Smlsl2X>(
                    q, size, machInst, vd, vn, vm);
          case 0xb:
            if (u || (size == 0x0 || size == 0x3)) {
                return new Unknown64(machInst);
            } else {
                if (q) {
                    return decodeNeonSThreeHAndWReg<Sqdmlsl2X>(
                        size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeHAndWReg<SqdmlslX>(
                        size, machInst, vd, vn, vm);
                }
            }
          case 0xc:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmullX, Umull2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmullX, Smull2X>(
                    q, size, machInst, vd, vn, vm);
          case 0xd:
            if (u || (size == 0x0 || size == 0x3)) {
                return new Unknown64(machInst);
            } else {
                if (q) {
                    return decodeNeonSThreeHAndWReg<Sqdmull2X>(
                        size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeHAndWReg<SqdmullX>(
                        size, machInst, vd, vn, vm);
                }
            }
          case 0xe:
            if (u || size != 0) {
                return new Unknown64(machInst);
            } else {
                if (q)
                    return new Pmull2X<uint8_t>(machInst, vd, vn, vm);
                else
                    return new PmullX<uint8_t>(machInst, vd, vn, vm);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeon2RegMisc(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 16, 12);

        RegIndex vd = (RegIndex)(uint8_t)bits(machInst, 4, 0);
        RegIndex vn = (RegIndex)(uint8_t)bits(machInst, 9, 5);

        uint8_t size_q = (size << 1) | q;
        uint8_t sz_q = size_q & 0x3;
        uint8_t op = (uint8_t)((bits(machInst, 12) << 1) |
                               bits(machInst, 29));
        uint8_t switchVal = opcode | ((u ? 1 : 0) << 5);

        switch (switchVal) {
          case 0x00:
            if (op + size >= 3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<Rev64DX, Rev64QX>(
                q, size, machInst, vd, vn);
          case 0x01:
            if (op + size >= 3)
                return new Unknown64(machInst);
            if (q)
                return new Rev16QX<uint8_t>(machInst, vd, vn);
            else
                return new Rev16DX<uint8_t>(machInst, vd, vn);
          case 0x02:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<SaddlpDX, SaddlpQX>(
                q, size, machInst, vd, vn);
          case 0x03:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscXReg<SuqaddDX, SuqaddQX>(
                q, size, machInst, vd, vn);
          case 0x04:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<ClsDX, ClsQX>(
                q, size, machInst, vd, vn);
          case 0x05:
            if (size != 0x0)
                return new Unknown64(machInst);
            if (q)
                return new CntQX<uint8_t>(machInst, vd, vn);
            else
                return new CntDX<uint8_t>(machInst, vd, vn);
          case 0x06:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<SadalpDX, SadalpQX>(
                q, size, machInst, vd, vn);
          case 0x07:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<SqabsDX, SqabsQX>(
                q, size, machInst, vd, vn);
          case 0x08:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmgtZeroDX, CmgtZeroQX>(
                q, size, machInst, vd, vn);
          case 0x09:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmeqZeroDX, CmeqZeroQX>(
                q, size, machInst, vd, vn);
          case 0x0a:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmltZeroDX, CmltZeroQX>(
                q, size, machInst, vd, vn);
          case 0x0b:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<AbsDX, AbsQX>(
                q, size, machInst, vd, vn);
          case 0x0c:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmgtZeroDX, FcmgtZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x0d:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmeqZeroDX, FcmeqZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x0e:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmltZeroDX, FcmltZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x0f:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FabsDX, FabsQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x12:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<XtnX, Xtn2X>(
                q, size, machInst, vd, vn);
          case 0x14:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<SqxtnX, Sqxtn2X>(
                q, size, machInst, vd, vn);
          case 0x16:
            if (size > 0x1)
                return new Unknown64(machInst);
            if (q) {
                if (size)
                    return new Fcvtn2X<uint32_t>(machInst, vd, vn);
                else
                    return new Fcvtn2X<uint16_t>(machInst, vd, vn);
            } else {
                if (size)
                    return new FcvtnX<uint32_t>(machInst, vd, vn);
                else
                    return new FcvtnX<uint16_t>(machInst, vd, vn);
            }
          case 0x17:
            if (size > 0x1)
                return new Unknown64(machInst);
            if (q) {
                if (size)
                    return new Fcvtl2X<uint32_t>(machInst, vd, vn);
                else
                    return new Fcvtl2X<uint16_t>(machInst, vd, vn);
            } else {
                if (size)
                    return new FcvtlX<uint32_t>(machInst, vd, vn);
                else
                    return new FcvtlX<uint16_t>(machInst, vd, vn);
            }
          case 0x18:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FrintnDX, FrintnQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FrintpDX, FrintpQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x19:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FrintmDX, FrintmQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FrintzDX, FrintzQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x1a:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FcvtnsDX, FcvtnsQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FcvtpsDX, FcvtpsQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x1b:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FcvtmsDX, FcvtmsQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FcvtzsIntDX, FcvtzsIntQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x1c:
            if (size < 0x2) {
                if (sz_q == 0x2)
                    return new Unknown64(machInst);
                return decodeNeonUTwoMiscFpReg<FcvtasDX, FcvtasQX>(
                    q, size & 0x1, machInst, vd, vn);
            } else {
                if (size & 0x1)
                    return new Unknown64(machInst);
                if (q)
                    return new UrecpeQX<uint32_t>(machInst, vd, vn);
                else
                    return new UrecpeDX<uint32_t>(machInst, vd, vn);
            }
          case 0x1d:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (q) {
                    if (size & 0x1)
                        return new ScvtfIntDQX<uint64_t>(machInst, vd, vn);
                    else
                        return new ScvtfIntSQX<uint32_t>(machInst, vd, vn);
                } else {
                    if (size & 0x1)
                        return new Unknown(machInst);
                    else
                        return new ScvtfIntDX<uint32_t>(machInst, vd, vn);
                }
            } else {
                return decodeNeonUTwoMiscFpReg<FrecpeDX, FrecpeQX>(
                    q, size & 0x1, machInst, vd, vn);
            }
          case 0x20:
            if (op + size >= 3)
                return new Unknown64(machInst);
            if (q) {
                if (size & 0x1)
                    return new Rev32QX<uint16_t>(machInst, vd, vn);
                else
                    return new Rev32QX<uint8_t>(machInst, vd, vn);
            } else {
                if (size & 0x1)
                    return new Rev32DX<uint16_t>(machInst, vd, vn);
                else
                    return new Rev32DX<uint8_t>(machInst, vd, vn);
            }
          case 0x22:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<UaddlpDX, UaddlpQX>(
                q, size, machInst, vd, vn);
          case 0x23:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscXReg<UsqaddDX, UsqaddQX>(
                q, size, machInst, vd, vn);
            return new Unknown64(machInst);
          case 0x24:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<ClzDX, ClzQX>(
                q, size, machInst, vd, vn);
          case 0x25:
            if (size == 0x0) {
                if (q)
                    return new MvnQX<uint64_t>(machInst, vd, vn);
                else
                    return new MvnDX<uint64_t>(machInst, vd, vn);
            } else if (size == 0x1) {
                if (q)
                    return new RbitQX<uint8_t>(machInst, vd, vn);
                else
                    return new RbitDX<uint8_t>(machInst, vd, vn);
            } else {
                return new Unknown64(machInst);
            }
          case 0x26:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<UadalpDX, UadalpQX>(
                q, size, machInst, vd, vn);
          case 0x27:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<SqnegDX, SqnegQX>(
                q, size, machInst, vd, vn);
          case 0x28:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmgeZeroDX, CmgeZeroQX>(
                q, size, machInst, vd, vn);
          case 0x29:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmleZeroDX, CmleZeroQX>(
                q, size, machInst, vd, vn);
          case 0x2b:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<NegDX, NegQX>(
                q, size, machInst, vd, vn);
          case 0x2c:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmgeZeroDX, FcmgeZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x2d:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmleZeroDX, FcmleZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x2f:
            if (size < 0x2 || size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FnegDX, FnegQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x32:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<SqxtunX, Sqxtun2X>(
                q, size, machInst, vd, vn);
          case 0x33:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<ShllX, Shll2X>(
                q, size, machInst, vd, vn);
          case 0x34:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<UqxtnX, Uqxtn2X>(
                q, size, machInst, vd, vn);
          case 0x36:
            if (size != 0x1)
                return new Unknown64(machInst);
            if (q)
                return new Fcvtxn2X<uint32_t>(machInst, vd, vn);
            else
                return new FcvtxnX<uint32_t>(machInst, vd, vn);
          case 0x38:
            if (size > 0x1 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FrintaDX, FrintaQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x39:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FrintxDX, FrintxQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FrintiDX, FrintiQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x3a:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FcvtnuDX, FcvtnuQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FcvtpuDX, FcvtpuQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x3b:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FcvtmuDX, FcvtmuQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FcvtzuIntDX, FcvtzuIntQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x3c:
            if (size < 0x2) {
                return decodeNeonUTwoMiscFpReg<FcvtauDX, FcvtauQX>(
                    q, size & 0x1, machInst, vd, vn);
            } else if (size == 0x2) {
                if (q)
                    return new UrsqrteQX<uint32_t>(machInst, vd, vn);
                else
                    return new UrsqrteDX<uint32_t>(machInst, vd, vn);
            } else {
                return new Unknown64(machInst);
            }
          case 0x3d:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<UcvtfIntDX, UcvtfIntQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FrsqrteDX, FrsqrteQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x3f:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FsqrtDX, FsqrtQX>(
                q, size & 0x1, machInst, vd, vn);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonAcrossLanes(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 16, 12);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t size_q = (size << 1) | q;
        uint8_t sz_q = size_q & 0x3;
        uint8_t switchVal = opcode | ((u ? 1 : 0) << 5);

        switch (switchVal) {
          case 0x03:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSAcrossLanesLongReg<SaddlvDX, SaddlvQX,
                                                 SaddlvBQX>(
                q, size, machInst, vd, vn);
          case 0x0a:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSAcrossLanesReg<SmaxvDX, SmaxvQX>(
                q, size, machInst, vd, vn);
          case 0x1a:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSAcrossLanesReg<SminvDX, SminvQX>(
                q, size, machInst, vd, vn);
          case 0x1b:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUAcrossLanesReg<AddvDX, AddvQX>(
                q, size, machInst, vd, vn);
          case 0x23:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUAcrossLanesLongReg<UaddlvDX, UaddlvQX,
                                                 UaddlvBQX>(
                q, size, machInst, vd, vn);
          case 0x2a:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUAcrossLanesReg<UmaxvDX, UmaxvQX>(
                q, size, machInst, vd, vn);
          case 0x2c:
            if (sz_q != 0x1)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (q)
                    return new FmaxnmvQX<uint32_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            } else {
                if (q)
                    return new FminnmvQX<uint32_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            }
          case 0x2f:
            if (sz_q != 0x1)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (q)
                    return new FmaxvQX<uint32_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            } else {
                if (q)
                    return new FminvQX<uint32_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            }
          case 0x3a:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUAcrossLanesReg<UminvDX, UminvQX>(
                q, size, machInst, vd, vn);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonCopy(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t op = bits(machInst, 29);
        uint8_t imm5 = bits(machInst, 20, 16);
        uint8_t imm4 = bits(machInst, 14, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t imm5_pos = findLsbSet(imm5);
        uint8_t index1 = 0, index2 = 0;

        if (op) {
            if (!q || (imm4 & mask(imm5_pos)))
                return new Unknown64(machInst);

            if (imm5_pos > 3)
                return new Unknown64(machInst);

            index1 = bits(imm5, 4, imm5_pos + 1);  // dst
            index2 = bits(imm4, 3, imm5_pos);  // src

            switch (imm5_pos) {
              case 0:
                return new InsElemX<uint8_t>(machInst, vd, vn, index1, index2);
              case 1:
                return new InsElemX<uint16_t>(machInst, vd, vn, index1, index2);
              case 2:
                return new InsElemX<uint32_t>(machInst, vd, vn, index1, index2);
              case 3:
                return new InsElemX<uint64_t>(machInst, vd, vn, index1, index2);
              default:
                return new Unknown64(machInst);
            }
        }

        switch (imm4) {
          case 0x0:
            if (imm5_pos > 3)
                return new Unknown64(machInst);

            index1 = bits(imm5, 4, imm5_pos + 1);
            switch (imm5_pos) {
              case 0:
                if (q)
                    return new DupElemQX<uint8_t>(machInst, vd, vn, index1);
                else
                    return new DupElemDX<uint8_t>(machInst, vd, vn, index1);
              case 1:
                if (q)
                    return new DupElemQX<uint16_t>(machInst, vd, vn, index1);
                else
                    return new DupElemDX<uint16_t>(machInst, vd, vn, index1);
              case 2:
                if (q)
                    return new DupElemQX<uint32_t>(machInst, vd, vn, index1);
                else
                    return new DupElemDX<uint32_t>(machInst, vd, vn, index1);
              case 3:
                if (q)
                    return new DupElemQX<uint64_t>(machInst, vd, vn, index1);
                else
                    return new Unknown64(machInst);
              default:
                return new Unknown64(machInst);
            }
          case 0x1:
            switch (imm5) {
              case 0x1:
                if (q)
                    return new DupGprWQX<uint8_t>(machInst, vd, vn);
                else
                    return new DupGprWDX<uint8_t>(machInst, vd, vn);
              case 0x2:
                if (q)
                    return new DupGprWQX<uint16_t>(machInst, vd, vn);
                else
                    return new DupGprWDX<uint16_t>(machInst, vd, vn);
              case 0x4:
                if (q)
                    return new DupGprWQX<uint32_t>(machInst, vd, vn);
                else
                    return new DupGprWDX<uint32_t>(machInst, vd, vn);
              case 0x8:
                if (q)
                    return new DupGprXQX<uint64_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
              default:
                return new Unknown64(machInst);
            }
          case 0x3:
            index1 = imm5 >> (imm5_pos + 1);
            switch (imm5_pos) {
              case 0:
                return new InsGprWX<uint8_t>(machInst, vd, vn, index1);
              case 1:
                return new InsGprWX<uint16_t>(machInst, vd, vn, index1);
              case 2:
                return new InsGprWX<uint32_t>(machInst, vd, vn, index1);
              case 3:
                return new InsGprXX<uint64_t>(machInst, vd, vn, index1);
              default:
                return new Unknown64(machInst);
            }
          case 0x5:
            if (imm5_pos > 3)
                return new Unknown64(machInst);

            index1 = bits(imm5, 4, imm5_pos + 1);
            switch (imm5_pos) {
              case 0:
                if (q)
                    return new SmovXX<int8_t>(machInst, vd, vn, index1);
                else
                    return new SmovWX<int8_t>(machInst, vd, vn, index1);
              case 1:
                if (q)
                    return new SmovXX<int16_t>(machInst, vd, vn, index1);
                else
                    return new SmovWX<int16_t>(machInst, vd, vn, index1);
              case 2:
                if (q)
                    return new SmovXX<int32_t>(machInst, vd, vn, index1);
                else
                    return new Unknown64(machInst);
              default:
                return new Unknown64(machInst);
            }
          case 0x7:
            index1 = imm5 >> (imm5_pos + 1);

            if ((q && imm5_pos != 3) || (!q && imm5_pos >= 3))
                return new Unknown64(machInst);

            switch (imm5_pos) {
              case 0:
                return new UmovWX<uint8_t>(machInst, vd, vn, index1);
              case 1:
                return new UmovWX<uint16_t>(machInst, vd, vn, index1);
              case 2:
                return new UmovWX<uint32_t>(machInst, vd, vn, index1);
              case 3:
                return new UmovXX<uint64_t>(machInst, vd, vn, index1);
              default:
                return new Unknown64(machInst);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    template <typename DecoderFeatures>
    StaticInstPtr
    decodeNeonIndexedElem(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t L = bits(machInst, 21);
        uint8_t M = bits(machInst, 20);
        uint8_t opcode = bits(machInst, 15, 12);
        uint8_t H = bits(machInst, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm_bf = (RegIndex) (uint8_t) bits(machInst, 19, 16);

        uint8_t index = 0;
        uint8_t index_fp = 0;
        uint8_t vmh = 0;
        uint8_t sz = size & 0x1;
        uint8_t sz_q = (sz << 1) | bits(machInst, 30);
        uint8_t sz_L = (sz << 1) | L;

        // Index and 2nd register operand for integer instructions
        if (size == 0x1) {
            index = (H << 2) | (L << 1) | M;
            // vmh = 0;
        } else if (size == 0x2) {
            index = (H << 1) | L;
            vmh = M;
        }
        RegIndex vm = (RegIndex) (uint8_t) (vmh << 4 | vm_bf);

        // Index and 2nd register operand for FP instructions
        vmh = M;
        if ((size & 0x1) == 0) {
            index_fp = (H << 1) | L;
        } else if (L == 0) {
            index_fp = H;
        }
        RegIndex vm_fp = (RegIndex) (uint8_t) (vmh << 4 | vm_bf);

        switch (opcode) {
          case 0x0:
            if (!u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeImmHAndWReg<MlaElemDX, MlaElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x1:
            if (!u && size >= 2 && sz_q != 0x2 && sz_L != 0x3)
                return decodeNeonUThreeImmFpReg<FmlaElemDX, FmlaElemQX>(
                    q, sz, machInst, vd, vn, vm_fp, index_fp);
            else if (u && (size == 1 || size == 2)){
                // FCMLA by element
                if (size == 0x2) {
                    index_fp = H;
                    if (q)
                        return new FcmlaElemQX<uint32_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                    else
                        return new FcmlaElemDX<uint32_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                } else {
                    index_fp = (H << 1) | L;
                    if (q)
                        return new FcmlaElemQX<uint16_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                    else
                        return new FcmlaElemDX<uint16_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                }

            } else
                return new Unknown64(machInst);
          case 0x2:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeImmHAndWReg<UmlalElemX, UmlalElem2X>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return decodeNeonSThreeImmHAndWReg<SmlalElemX, SmlalElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x3:
            if (u && (size == 1 || size == 2)){
                // FCMLA by element
                if (size == 0x2) {
                    index_fp = H;
                    if (q)
                        return new FcmlaElemQX<uint32_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                    else
                        return new FcmlaElemDX<uint32_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                } else {
                    index_fp = (H << 1) | L;
                    if (q)
                        return new FcmlaElemQX<uint16_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                    else
                        return new FcmlaElemDX<uint16_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                }
            } else if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmlalElemX,
                                                   SqdmlalElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x4:
            if (u && !(size == 0x0 || size == 0x3))
                return decodeNeonUThreeImmHAndWReg<MlsElemDX, MlsElemQX>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return new Unknown64(machInst);
          case 0x5:
            if (!u && size >= 0x2 && sz_L != 0x3 && sz_q != 0x2)
                return decodeNeonUThreeImmFpReg<FmlsElemDX, FmlsElemQX>(
                    q, sz, machInst, vd, vn, vm_fp, index_fp);
            else if (u && (size == 1 || size == 2)){
                // FCMLA by element
                if (size == 0x2) {
                    index_fp = H;
                    if (q)
                        return new FcmlaElemQX<uint32_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                    else
                        return new FcmlaElemDX<uint32_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                } else {
                    index_fp = (H << 1) | L;
                    if (q)
                        return new FcmlaElemQX<uint16_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                    else
                        return new FcmlaElemDX<uint16_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                }
            } else
                return new Unknown64(machInst);
          case 0x6:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeImmHAndWReg<UmlslElemX, UmlslElem2X>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return decodeNeonSThreeImmHAndWReg<SmlslElemX, SmlslElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x7:
             if (u && (size == 1 || size == 2)){
                // FCMLA by element
                if (size == 0x2) {
                    index_fp = H;
                    if (q)
                        return new FcmlaElemQX<uint32_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                    else
                        return new FcmlaElemDX<uint32_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                } else {
                    index_fp = (H << 1) | L;
                    if (q)
                        return new FcmlaElemQX<uint16_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                    else
                        return new FcmlaElemDX<uint16_t>(machInst, vd, vn,
                                                        vm_fp, index_fp);
                }
             } else if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmlslElemX,
                                                   SqdmlslElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x8:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeImmHAndWReg<MulElemDX, MulElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x9:
            if (size >= 2 && sz_q != 0x2 && sz_L != 0x3) {
                if (u)
                    return decodeNeonUThreeImmFpReg<FmulxElemDX, FmulxElemQX>(
                        q, sz, machInst, vd, vn, vm_fp, index_fp);
                else
                    return decodeNeonUThreeImmFpReg<FmulElemDX, FmulElemQX>(
                        q, sz, machInst, vd, vn, vm_fp, index_fp);
            } else {
                return new Unknown64(machInst);
            }
          case 0xa:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeImmHAndWReg<UmullElemX, UmullElem2X>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return decodeNeonSThreeImmHAndWReg<SmullElemX, SmullElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0xb:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmullElemX, SqdmullElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0xc:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmulhElemDX, SqdmulhElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          case 0xd:
            if (u)
                return decodeNeonSThreeImmHAndWReg<SqrdmlahElemDX,
                                                   SqrdmlahElemQX>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return decodeNeonSThreeImmHAndWReg<SqrdmulhElemDX,
                                                   SqrdmulhElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          case 0xf:
            return decodeNeonSThreeImmHAndWReg<SqrdmlshElemDX, SqrdmlshElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonModImm(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t op = bits(machInst, 29);
        uint8_t abcdefgh = (bits(machInst, 18, 16) << 5) |
                           bits(machInst, 9, 5);
        uint8_t cmode = bits(machInst, 15, 12);
        uint8_t o2 = bits(machInst, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);

        if (o2 == 0x1 || (op == 0x1 && cmode == 0xf && !q))
            return new Unknown64(machInst);

        bool immValid = true;
        const uint64_t bigImm = simd_modified_imm(op, cmode, abcdefgh,
                                                  immValid,
                                                  true /* isAarch64 */);
        if (!immValid) {
            return new Unknown(machInst);
        }

        if (op) {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new MvniQX<uint64_t>(machInst, vd, bigImm);
                    else
                        return new MvniDX<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new BicImmQX<uint64_t>(machInst, vd, bigImm);
                    else
                        return new BicImmDX<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    switch (bits(cmode, 1, 0)) {
                      case 0:
                      case 1:
                        if (q)
                            return new MvniQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MvniDX<uint64_t>(machInst, vd, bigImm);
                      case 2:
                        if (q)
                            return new MoviQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MoviDX<uint64_t>(machInst, vd, bigImm);
                      case 3:
                        if (q)
                            return new FmovQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MoviDX<uint64_t>(machInst, vd, bigImm);
                    }
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new MvniQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MvniDX<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new BicImmQX<uint64_t>(machInst, vd,
                                                          bigImm);
                        else
                            return new BicImmDX<uint64_t>(machInst, vd,
                                                          bigImm);
                    }
                }
            }
        } else {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new MoviQX<uint64_t>(machInst, vd, bigImm);
                    else
                        return new MoviDX<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new OrrImmQX<uint64_t>(machInst, vd, bigImm);
                    else
                        return new OrrImmDX<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    if (bits(cmode, 1, 0) == 0x3) {
                        if (q)
                            return new FmovQX<uint32_t>(machInst, vd, bigImm);
                        else
                            return new FmovDX<uint32_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new MoviQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MoviDX<uint64_t>(machInst, vd, bigImm);
                    }
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new MoviQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MoviDX<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new OrrImmQX<uint64_t>(machInst, vd,
                                                          bigImm);
                        else
                            return new OrrImmDX<uint64_t>(machInst, vd, bigImm);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }

    StaticInstPtr
    decodeNeonShiftByImm(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t immh = bits(machInst, 22, 19);
        uint8_t immb = bits(machInst, 18, 16);
        uint8_t opcode = bits(machInst, 15, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t immh3 = bits(machInst, 22);
        uint8_t immh3_q = (immh3 << 1) | q;
        uint8_t op_u = (bits(machInst, 12) << 1) | u;
        uint8_t size = findMsbSet(immh);
        int shiftAmt = 0;

        switch (opcode) {
          case 0x00:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftXReg<UshrDX, UshrQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SshrDX, SshrQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x02:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftXReg<UsraDX, UsraQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SsraDX, SsraQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x04:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftXReg<UrshrDX, UrshrQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SrshrDX, SrshrQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x06:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftXReg<UrsraDX, UrsraQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SrsraDX, SrsraQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x08:
            if (u && !(immh3_q == 0x2)) {
                shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
                return decodeNeonUTwoShiftXReg<SriDX, SriQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            } else {
                return new Unknown64(machInst);
            }
          case 0x0a:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return decodeNeonUTwoShiftXReg<SliDX, SliQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftXReg<ShlDX, ShlQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x0c:
            if (u && !(immh3_q == 0x2 || op_u == 0x0)) {
                shiftAmt = ((immh << 3) | immb) - (8 << size);
                return decodeNeonSTwoShiftXReg<SqshluDX, SqshluQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            } else {
                return new Unknown64(machInst);
            }
          case 0x0e:
            if (immh3_q == 0x2 || op_u == 0x0)
                return new Unknown64(machInst);
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return decodeNeonUTwoShiftXReg<UqshlImmDX, UqshlImmQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SqshlImmDX, SqshlImmQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x10:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonSTwoShiftSReg<SqshrunX, Sqshrun2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftSReg<ShrnX, Shrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x11:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonSTwoShiftSReg<SqrshrunX, Sqrshrun2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftSReg<RshrnX, Rshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x12:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftSReg<UqshrnX, Uqshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftSReg<SqshrnX, Sqshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x13:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftSReg<UqrshrnX, Uqrshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftSReg<SqrshrnX, Sqrshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x14:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return decodeNeonUTwoShiftSReg<UshllX, Ushll2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftSReg<SshllX, Sshll2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x1c:
            if (immh < 0x4 || immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u) {
                return decodeNeonUTwoShiftFpReg<UcvtfFixedDX, UcvtfFixedQX>(
                    q, size & 0x1, machInst, vd, vn, shiftAmt);
            } else {
                if (q) {
                    if (size & 0x1)
                        return new ScvtfFixedDQX<uint64_t>(machInst, vd, vn,
                                                           shiftAmt);
                    else
                        return new ScvtfFixedSQX<uint32_t>(machInst, vd, vn,
                                                           shiftAmt);
                } else {
                    if (size & 0x1)
                        return new Unknown(machInst);
                    else
                        return new ScvtfFixedDX<uint32_t>(machInst, vd, vn,
                                                          shiftAmt);
                }
            }
          case 0x1f:
            if (immh < 0x4 || immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftFpReg<FcvtzuFixedDX, FcvtzuFixedQX>(
                    q, size & 0x1, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftFpReg<FcvtzsFixedDX, FcvtzsFixedQX>(
                    q, size & 0x1, machInst, vd, vn, shiftAmt);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonTblTbx(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t switchVal = bits(machInst, 14, 12);

        switch (switchVal) {
          case 0x0:
            if (q)
                return new Tbl1QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbl1DX<uint8_t>(machInst, vd, vn, vm);
          case 0x1:
            if (q)
                return new Tbx1QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbx1DX<uint8_t>(machInst, vd, vn, vm);
          case 0x2:
            if (q)
                return new Tbl2QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbl2DX<uint8_t>(machInst, vd, vn, vm);
          case 0x3:
            if (q)
                return new Tbx2QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbx2DX<uint8_t>(machInst, vd, vn, vm);
          case 0x4:
            if (q)
                return new Tbl3QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbl3DX<uint8_t>(machInst, vd, vn, vm);
          case 0x5:
            if (q)
                return new Tbx3QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbx3DX<uint8_t>(machInst, vd, vn, vm);
          case 0x6:
            if (q)
                return new Tbl4QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbl4DX<uint8_t>(machInst, vd, vn, vm);
          case 0x7:
            if (q)
                return new Tbx4QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbx4DX<uint8_t>(machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }

        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeNeonZipUzpTrn(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 14, 12);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x1:
            return decodeNeonUThreeXReg<Uzp1DX, Uzp1QX>(
                q, size, machInst, vd, vn, vm);
          case 0x2:
            return decodeNeonUThreeXReg<Trn1DX, Trn1QX>(
                q, size, machInst, vd, vn, vm);
          case 0x3:
            return decodeNeonUThreeXReg<Zip1DX, Zip1QX>(
                q, size, machInst, vd, vn, vm);
          case 0x5:
            return decodeNeonUThreeXReg<Uzp2DX, Uzp2QX>(
                q, size, machInst, vd, vn, vm);
          case 0x6:
            return decodeNeonUThreeXReg<Trn2DX, Trn2QX>(
                q, size, machInst, vd, vn, vm);
          case 0x7:
            return decodeNeonUThreeXReg<Zip2DX, Zip2QX>(
                q, size, machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeNeonExt(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t op2 = bits(machInst, 23, 22);
        uint8_t imm4 = bits(machInst, 14, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        if (op2 != 0 || (q == 0x0 && bits(imm4, 3) == 0x1))
            return new Unknown64(machInst);

        uint8_t index = q ? imm4 : imm4 & 0x7;

        if (q) {
            return new ExtQX<uint8_t>(machInst, vd, vn, vm, index);
        } else {
            return new ExtDX<uint8_t>(machInst, vd, vn, vm, index);
        }
    }

    StaticInstPtr
    decodeNeonSc3Same(ExtMachInst machInst)
    {
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 15, 11);
        uint8_t s = bits(machInst, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x01:
            if (u)
                return decodeNeonUThreeUReg<UqaddScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeUReg<SqaddScX>(
                    size, machInst, vd, vn, vm);
          case 0x05:
            if (u)
                return decodeNeonUThreeUReg<UqsubScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeUReg<SqsubScX>(
                    size, machInst, vd, vn, vm);
          case 0x06:
            if (size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new CmhiDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new CmgtDX<int64_t>(machInst, vd, vn, vm);
          case 0x07:
            if (size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new CmhsDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new CmgeDX<int64_t>(machInst, vd, vn, vm);
          case 0x08:
            if (!s && size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new UshlDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new SshlDX<int64_t>(machInst, vd, vn, vm);
          case 0x09:
            if (!s && size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeUReg<UqshlScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeUReg<SqshlScX>(
                    size, machInst, vd, vn, vm);
          case 0x0a:
            if (!s && size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new UrshlDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new SrshlDX<int64_t>(machInst, vd, vn, vm);
          case 0x0b:
            if (!s && size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeUReg<UqrshlScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeUReg<SqrshlScX>(
                    size, machInst, vd, vn, vm);
          case 0x10:
            if (size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new SubDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new AddDX<uint64_t>(machInst, vd, vn, vm);
          case 0x11:
            if (size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new CmeqDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new CmtstDX<uint64_t>(machInst, vd, vn, vm);
          case 0x16:
            if (size == 0x3 || size == 0x0)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonSThreeHAndWReg<SqrdmulhScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeHAndWReg<SqdmulhScX>(
                    size, machInst, vd, vn, vm);
          case 0x1a:
            if (!u || size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeScFpReg<FabdScX>(
                    size & 0x1, machInst, vd, vn, vm);
          case 0x1b:
            if (u || size > 0x1)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeScFpReg<FmulxScX>(
                    size & 0x1, machInst, vd, vn, vm);
          case 0x1c:
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeScFpReg<FcmgeScX>(
                        size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeScFpReg<FcmeqScX>(
                        size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeScFpReg<FcmgtScX>(
                        size & 0x1, machInst, vd, vn, vm);
                else
                    return new Unknown64(machInst);
            }
          case 0x1d:
            if (!u)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUThreeScFpReg<FacgeScX>(
                    size & 0x1, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeScFpReg<FacgtScX>(
                    size & 0x1, machInst, vd, vn, vm);
          case 0x1f:
            if (u)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUThreeScFpReg<FrecpsScX>(
                    size & 0x1, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeScFpReg<FrsqrtsScX>(
                    size & 0x1, machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonSc3SameExtra(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 15, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x10:
            return decodeNeonSThreeHAndWReg<SqrdmlahScX>(
                size, machInst, vd, vn, vm);
          case 0x11:
            return decodeNeonSThreeHAndWReg<SqrdmlshScX>(
                size, machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonSc3Diff(ExtMachInst machInst)
    {
        if (bits(machInst, 29))
            return new Unknown64(machInst);

        uint8_t size = bits(machInst, 23, 22);
        if (size == 0x0 || size == 0x3)
            return new Unknown64(machInst);

        uint8_t opcode = bits(machInst, 15, 12);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x9:
            return decodeNeonSThreeHAndWReg<SqdmlalScX>(size, machInst, vd, vn, vm);
          case 0xb:
            return decodeNeonSThreeHAndWReg<SqdmlslScX>(size, machInst, vd, vn, vm);
          case 0xd:
            return decodeNeonSThreeHAndWReg<SqdmullScX>(size, machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonSc2RegMisc(ExtMachInst machInst)
    {
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 16, 12);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t switchVal = opcode | ((u ? 1 : 0) << 5);
        switch (switchVal) {
          case 0x03:
            return decodeNeonUTwoMiscUReg<SuqaddScX>(size, machInst, vd, vn);
          case 0x07:
            return decodeNeonSTwoMiscUReg<SqabsScX>(size, machInst, vd, vn);
          case 0x08:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmgtZeroDX<int64_t>(machInst, vd, vn);
          case 0x09:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmeqZeroDX<int64_t>(machInst, vd, vn);
          case 0x0a:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmltZeroDX<int64_t>(machInst, vd, vn);
          case 0x0b:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new AbsDX<int64_t>(machInst, vd, vn);
          case 0x0c:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmgtZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x0d:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmeqZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x0e:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmltZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x14:
            switch (size) {
              case 0x0:
                return new SqxtnScX<int8_t>(machInst, vd, vn);
              case 0x1:
                return new SqxtnScX<int16_t>(machInst, vd, vn);
              case 0x2:
                return new SqxtnScX<int32_t>(machInst, vd, vn);
              case 0x3:
                return new Unknown64(machInst);
              default:
                GEM5_UNREACHABLE;
            }
          case 0x1a:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtnsScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FcvtpsScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x1b:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtmsScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FcvtzsIntScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x1c:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtasScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return new Unknown64(machInst);
          case 0x1d:
            if (size < 0x2) {
                if (size & 0x1)
                    return new ScvtfIntScDX<uint64_t>(machInst, vd, vn);
                else
                    return new ScvtfIntScSX<uint32_t>(machInst, vd, vn);
            } else {
                return decodeNeonUTwoMiscScFpReg<FrecpeScX>(
                    size & 0x1, machInst, vd, vn);
            }
          case 0x1f:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FrecpxX>(
                    size & 0x1, machInst, vd, vn);
          case 0x23:
            return decodeNeonUTwoMiscUReg<UsqaddScX>(size, machInst, vd, vn);
          case 0x27:
            return decodeNeonSTwoMiscUReg<SqnegScX>(size, machInst, vd, vn);
          case 0x28:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmgeZeroDX<int64_t>(machInst, vd, vn);
          case 0x29:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmleZeroDX<int64_t>(machInst, vd, vn);
          case 0x2b:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new NegDX<int64_t>(machInst, vd, vn);
          case 0x2c:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmgeZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x2d:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmleZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x32:
            switch (size) {
              case 0x0:
                return new SqxtunScX<int8_t>(machInst, vd, vn);
              case 0x1:
                return new SqxtunScX<int16_t>(machInst, vd, vn);
              case 0x2:
                return new SqxtunScX<int32_t>(machInst, vd, vn);
              case 0x3:
                return new Unknown64(machInst);
              default:
                GEM5_UNREACHABLE;
            }
          case 0x34:
            switch (size) {
              case 0x0:
                return new UqxtnScX<uint8_t>(machInst, vd, vn);
              case 0x1:
                return new UqxtnScX<uint16_t>(machInst, vd, vn);
              case 0x2:
                return new UqxtnScX<uint32_t>(machInst, vd, vn);
              case 0x3:
                return new Unknown64(machInst);
              default:
                GEM5_UNREACHABLE;
            }
          case 0x36:
            if (size != 0x1) {
                return new Unknown64(machInst);
            } else {
                return new FcvtxnScX<uint32_t>(machInst, vd, vn);
            }
          case 0x3a:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtnuScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FcvtpuScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x3b:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtmuScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FcvtzuIntScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x3c:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtauScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return new Unknown64(machInst);
          case 0x3d:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<UcvtfIntScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FrsqrteScX>(
                    size & 0x1, machInst, vd, vn);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonScPwise(ExtMachInst machInst)
    {
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 16, 12);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        if (!u) {
            if (opcode == 0x1b && size == 0x3)
                return new AddpScQX<uint64_t>(machInst, vd, vn);
            else
                return new Unknown64(machInst);
        }

        uint8_t switchVal = (opcode << 0) | (size << 5);
        switch (switchVal) {
          case 0x0c:
          case 0x2c:
            return decodeNeonUTwoMiscPwiseScFpReg<FmaxnmpScDX, FmaxnmpScQX>(
                    size & 0x1, machInst, vd, vn);
          case 0x0d:
          case 0x2d:
            return decodeNeonUTwoMiscPwiseScFpReg<FaddpScDX, FaddpScQX>(
                    size & 0x1, machInst, vd, vn);
          case 0x0f:
          case 0x2f:
            return decodeNeonUTwoMiscPwiseScFpReg<FmaxpScDX, FmaxpScQX>(
                    size & 0x1, machInst, vd, vn);
          case 0x4c:
          case 0x6c:
            return decodeNeonUTwoMiscPwiseScFpReg<FminnmpScDX, FminnmpScQX>(
                    size & 0x1, machInst, vd, vn);
          case 0x4f:
          case 0x6f:
            return decodeNeonUTwoMiscPwiseScFpReg<FminpScDX, FminpScQX>(
                    size & 0x1, machInst, vd, vn);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonScCopy(ExtMachInst machInst)
    {
        if (bits(machInst, 14, 11) != 0 || bits(machInst, 29))
            return new Unknown64(machInst);

        uint8_t imm5 = bits(machInst, 20, 16);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t size = findLsbSet(imm5);
        if (size > 3)
            return new Unknown64(machInst);

        uint8_t index = bits(imm5, 4, size + 1);

        return decodeNeonUTwoShiftUReg<DupElemScX>(
            size, machInst, vd, vn, index);
    }

    StaticInstPtr
    decodeNeonScIndexedElem(ExtMachInst machInst)
    {
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t L = bits(machInst, 21);
        uint8_t M = bits(machInst, 20);
        uint8_t opcode = bits(machInst, 15, 12);
        uint8_t H = bits(machInst, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex vm_bf = (RegIndex) (uint8_t) bits(machInst, 19, 16);

        uint8_t index = 0;
        uint8_t index_fp = 0;
        uint8_t vmh = 0;
        uint8_t sz_L = bits(machInst, 22, 21);

        // Index and 2nd register operand for integer instructions
        if (size == 0x1) {
            index = (H << 2) | (L << 1) | M;
            // vmh = 0;
        } else if (size == 0x2) {
            index = (H << 1) | L;
            vmh = M;
        } else if (size == 0x3) {
            index = H;
            vmh = M;
        }
        RegIndex vm = (RegIndex) (uint8_t) (vmh << 4 | vm_bf);

        // Index and 2nd register operand for FP instructions
        vmh = M;
        if ((size & 0x1) == 0) {
            index_fp = (H << 1) | L;
        } else if (L == 0) {
            index_fp = H;
        }
        RegIndex vm_fp = (RegIndex) (uint8_t) (vmh << 4 | vm_bf);

        uint8_t u_opcode = opcode | u << 4;

        switch (u_opcode) {
          case 0x1:
            if (size < 2 || sz_L == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeImmScFpReg<FmlaElemScX>(
                    size & 0x1, machInst, vd, vn, vm_fp, index_fp);
          case 0x3:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmlalElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0x5:
            if (size < 2 || sz_L == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeImmScFpReg<FmlsElemScX>(
                    size & 0x1, machInst, vd, vn, vm_fp, index_fp);
          case 0x7:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmlslElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0x9:
            if (size < 2 || sz_L == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUThreeImmScFpReg<FmulElemScX>(
                    size & 0x1, machInst, vd, vn, vm_fp, index_fp);
          case 0xb:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmullElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0xc:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmulhElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0xd:
            return decodeNeonSThreeImmHAndWReg<SqrdmulhElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0x19:
            if (size < 2 || sz_L == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUThreeImmScFpReg<FmulxElemScX>(
                    size & 0x1, machInst, vd, vn, vm_fp, index_fp);

          case 0x1d:
            return decodeNeonSThreeImmHAndWReg<SqrdmlahElemScX>(
                    size, machInst, vd, vn, vm, index);

          case 0x1f:
            return decodeNeonSThreeImmHAndWReg<SqrdmlshElemScX>(
                    size, machInst, vd, vn, vm, index);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonScShiftByImm(ExtMachInst machInst)
    {
        bool u = bits(machInst, 29);
        uint8_t immh = bits(machInst, 22, 19);
        uint8_t immb = bits(machInst, 18, 16);
        uint8_t opcode = bits(machInst, 15, 11);

        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex vn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t immh3 = bits(machInst, 22);
        uint8_t size = findMsbSet(immh);
        int shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);

        if (immh == 0x0)
            return new Unknown64(machInst);

        switch (opcode) {
          case 0x00:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new UshrDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new SshrDX<int64_t>(machInst, vd, vn, shiftAmt);
          case 0x02:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new UsraDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new SsraDX<int64_t>(machInst, vd, vn, shiftAmt);
          case 0x04:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new UrshrDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new SrshrDX<int64_t>(machInst, vd, vn, shiftAmt);
          case 0x06:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new UrsraDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new SrsraDX<int64_t>(machInst, vd, vn, shiftAmt);
          case 0x08:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new SriDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new Unknown64(machInst);
          case 0x0a:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return new SliDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new ShlDX<uint64_t>(machInst, vd, vn, shiftAmt);
          case 0x0c:
            if (u) {
                shiftAmt = ((immh << 3) | immb) - (8 << size);
                return decodeNeonSTwoShiftUReg<SqshluScX>(
                    size, machInst, vd, vn, shiftAmt);
            } else {
                return new Unknown64(machInst);
            }
          case 0x0e:
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return decodeNeonUTwoShiftUReg<UqshlImmScX>(
                    size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftUReg<SqshlImmScX>(
                    size, machInst, vd, vn, shiftAmt);
          case 0x10:
            if (!u || immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            return decodeNeonSTwoShiftUSReg<SqshrunScX>(
                size, machInst, vd, vn, shiftAmt);
          case 0x11:
            if (!u || immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            return decodeNeonSTwoShiftUSReg<SqrshrunScX>(
                size, machInst, vd, vn, shiftAmt);
          case 0x12:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftUSReg<UqshrnScX>(
                    size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftUSReg<SqshrnScX>(
                    size, machInst, vd, vn, shiftAmt);
          case 0x13:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftUSReg<UqrshrnScX>(
                    size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftUSReg<SqrshrnScX>(
                    size, machInst, vd, vn, shiftAmt);
          case 0x1c:
            if (immh < 0x4)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u) {
                return decodeNeonUTwoShiftUFpReg<UcvtfFixedScX>(
                    size & 0x1, machInst, vd, vn, shiftAmt);
            } else {
                if (size & 0x1)
                    return new ScvtfFixedScDX<uint64_t>(machInst, vd, vn,
                                                        shiftAmt);
                else
                    return new ScvtfFixedScSX<uint32_t>(machInst, vd, vn,
                                                        shiftAmt);
            }
          case 0x1f:
            if (immh < 0x4)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftUFpReg<FcvtzuFixedScX>(
                    size & 0x1, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftUFpReg<FcvtzsFixedScX>(
                    size & 0x1, machInst, vd, vn, shiftAmt);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonMem(ExtMachInst machInst)
    {
        uint8_t dataSize = bits(machInst, 30) ? 128 : 64;
        bool multiple = bits(machInst, 24, 23) < 0x2;
        bool load = bits(machInst, 22);

        uint8_t numStructElems = 0;
        uint8_t numRegs = 0;

        if (multiple) {  // AdvSIMD load/store multiple structures
            uint8_t opcode = bits(machInst, 15, 12);
            uint8_t eSize = bits(machInst, 11, 10);
            bool wb = !(bits(machInst, 20, 16) == 0x0 && !bits(machInst, 23));

            switch (opcode) {
              case 0x0:  // LD/ST4 (4 regs)
                numStructElems = 4;
                numRegs = 4;
                break;
              case 0x2:  // LD/ST1 (4 regs)
                numStructElems = 1;
                numRegs = 4;
                break;
              case 0x4:  // LD/ST3 (3 regs)
                numStructElems = 3;
                numRegs = 3;
                break;
              case 0x6:  // LD/ST1 (3 regs)
                numStructElems = 1;
                numRegs = 3;
                break;
              case 0x7:  // LD/ST1 (1 reg)
                numStructElems = 1;
                numRegs = 1;
                break;
              case 0x8:  // LD/ST2 (2 regs)
                numStructElems = 2;
                numRegs = 2;
                break;
              case 0xa:  // LD/ST1 (2 regs)
                numStructElems = 1;
                numRegs = 2;
                break;
              default:
                return new Unknown64(machInst);
            }

            RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

            if (load) {
                return new VldMult64(machInst, rn, vd, rm, eSize, dataSize,
                                     numStructElems, numRegs, wb);
            } else {
                return new VstMult64(machInst, rn, vd, rm, eSize, dataSize,
                                     numStructElems, numRegs, wb);
            }
        } else {  // AdvSIMD load/store single structure
            uint8_t scale = bits(machInst, 15, 14);
            uint8_t numStructElems = (((uint8_t) bits(machInst, 13) << 1) |
                                      (uint8_t) bits(machInst, 21)) + 1;
            uint8_t index = 0;
            bool wb = !(bits(machInst, 20, 16) == 0x0 && !bits(machInst, 23));
            bool replicate = false;

            switch (scale) {
              case 0x0:
                index = ((uint8_t) bits(machInst, 30) << 3) |
                    ((uint8_t) bits(machInst, 12) << 2) |
                    (uint8_t) bits(machInst, 11, 10);
                break;
              case 0x1:
                index = ((uint8_t) bits(machInst, 30) << 2) |
                    ((uint8_t) bits(machInst, 12) << 1) |
                    (uint8_t) bits(machInst, 11);
                break;
              case 0x2:
                if (bits(machInst, 10) == 0x0) {
                    index = ((uint8_t) bits(machInst, 30) << 1) |
                        bits(machInst, 12);
                } else {
                    index = (uint8_t) bits(machInst, 30);
                    scale = 0x3;
                }
                break;
              case 0x3:
                scale = bits(machInst, 11, 10);
                replicate = true;
                break;
              default:
                return new Unknown64(machInst);
            }

            uint8_t eSize = scale;

            RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

            if (load) {
                return new VldSingle64(machInst, rn, vd, rm, eSize, dataSize,
                                       numStructElems, index, wb, replicate);
            } else {
                return new VstSingle64(machInst, rn, vd, rm, eSize, dataSize,
                                       numStructElems, index, wb, replicate);
            }
        }
    }
}

namespace Aarch64
{

    StaticInstPtr
    decodeSveInt(ExtMachInst machInst)
    {
        uint8_t b_29_24_21 = (bits(machInst, 29) << 2) |
                             (bits(machInst, 24) << 1) |
                             bits(machInst, 21);
        switch (b_29_24_21) {
          case 0x0:
            {
                if (bits(machInst, 14)) {
                    return decodeSveIntMulAdd(machInst);
                } else {
                    uint8_t b_15_13 = (bits(machInst, 15) << 1) |
                                      bits(machInst, 13);
                    switch (b_15_13) {
                      case 0x0:
                        if (bits(machInst, 30)) {
                            return decodeSveMultiplyAddUnpred(machInst);
                        } else {
                            return decodeSveIntArithBinPred(machInst);
                        }
                      case 0x1:
                        return decodeSveIntReduc(machInst);
                      case 0x2:
                        return decodeSveShiftByImmPred(machInst);
                      case 0x3:
                        return decodeSveIntArithUnaryPred(machInst);
                    }
                }
                break;
            }
          case 0x1:
            {
                uint8_t b_15_14 = bits(machInst, 15, 14);
                uint8_t b_13 = bits(machInst, 13);
                uint8_t b_12 = bits(machInst, 12);
                switch (b_15_14) {
                  case 0x0:
                    if (b_13) {
                        return decodeSveIntLogUnpred(machInst);
                    } else {
                        if (bits(machInst, 30)) {
                            return decodeSveMultiplyIndexed(machInst);
                        } else {
                            return decodeSveIntArithUnpred(machInst);
                        }
                    }
                  case 0x1:
                    if (b_13) {
                        return new Unknown64(machInst);
                    } else if (b_12) {
                        return decodeSveStackAlloc(machInst);
                    } else {
                        return decodeSveIndexGen(machInst);
                    }
                  case 0x2:
                    if (b_13) {
                        if (b_12) {
                            return decodeSveIntMiscUnpred(machInst);
                        } else {
                            return decodeSveCompVecAddr(machInst);
                        }
                    } else {
                        return decodeSveShiftByImmUnpred(machInst);
                    }
                  case 0x3:
                    return decodeSveElemCount(machInst);
                }
                break;
            }
          case 0x2:
            if (bits(machInst, 20)) {
                return decodeSveIntWideImmPred(machInst);
            } else {
                return decodeSveLogMaskImm(machInst);
            }
          case 0x3:
            {
                uint8_t b_15_14 = bits(machInst, 15, 14);
                uint8_t b_13 = bits(machInst, 13);
                switch (b_15_14) {
                  case 0x0:
                    if (b_13) {
                        return decodeSvePermUnpred(machInst);
                    } else {
                        return decodeSvePermExtract(machInst);
                    }
                  case 0x1:
                    if (b_13) {
                        return decodeSvePermIntlv(machInst);
                    } else {
                        return decodeSvePermPredicates(machInst);
                    }
                  case 0x2:
                    return decodeSvePermPred(machInst);
                  case 0x3:
                    return decodeSveSelVec(machInst);
                }
                break;
            }
          case 0x4:
            return decodeSveIntCmpVec(machInst);
          case 0x5:
            return decodeSveIntCmpUImm(machInst);
          case 0x6:
            if (bits(machInst, 14)) {
                return decodeSvePredGen(machInst);
            } else {
                return decodeSveIntCmpSImm(machInst);
            }
          case 0x7:
            {
                uint8_t b_15_14 = bits(machInst, 15, 14);
                switch (b_15_14) {
                  case 0x0:
                    return decodeSveIntCmpSca(machInst);
                  case 0x1:
                    return new Unknown64(machInst);
                  case 0x2:
                    return decodeSvePredCount(machInst);
                  case 0x3:
                    return decodeSveIntWideImmUnpred(machInst);
                }
            }
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveFp(ExtMachInst machInst)
    {
        uint8_t b_24_21 = (bits(machInst, 24) << 1) |
                          bits(machInst, 21);
        switch (b_24_21) {
          case 0x0:
            if (!bits(machInst, 15)) {
                return decodeSveFpCplxMulAddVec(machInst);
            } else if((bits(machInst, 20, 17) | bits(machInst, 14, 13)) == 0) {
                return decodeSveFpCplxAdd(machInst);
            }
            return new Unknown64(machInst);
          case 0x1:
            if (bits(machInst, 15, 12) == 1) {
                return decodeSveFpCplxMulAddIndexed(machInst);
            }
            switch (bits(machInst, 13, 11)) {
              case 0:
                return decodeSveFpMulAddIndexed(machInst);
              case 4:
                if (!bits(machInst, 10))
                    return decodeSveFpMulIndexed(machInst);
                [[fallthrough]];
              default:
                return new Unknown64(machInst);
            }
          case 0x2:
            {
                if (bits(machInst, 14)) {
                    return decodeSveFpCmpVec(machInst);
                } else {
                    uint8_t b_15_13 = (bits(machInst, 15) << 1) |
                                      bits(machInst, 13);
                    switch (b_15_13) {
                      case 0x0:
                        return decodeSveFpArithUnpred(machInst);
                      case 0x1:
                        {
                            uint8_t b_20_19 = (bits(machInst, 20) << 1) |
                                              bits(machInst, 19);
                            switch (b_20_19) {
                              case 0x0:
                                  return decodeSveFpFastReduc(machInst);
                              case 0x1:
                                  if (bits(machInst, 12)) {
                                      return decodeSveFpUnaryUnpred(machInst);
                                  } else {
                                      return new Unknown64(machInst);
                                  }
                              case 0x2:
                                  return decodeSveFpCmpZero(machInst);
                              case 0x3:
                                  return decodeSveFpAccumReduc(machInst);
                            }
                            break;
                        }
                      case 0x2:
                        return decodeSveFpArithPred(machInst);
                      case 0x3:
                        return decodeSveFpUnaryPred(machInst);
                    }
                }
                break;
            }
          case 0x3:
            return decodeSveFpFusedMulAdd(machInst);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveMem(ExtMachInst machInst)
    {
        uint8_t b_30_29 = bits(machInst, 30, 29);
        switch (b_30_29) {
          case 0x0:
            return decodeSveMemGather32(machInst);
          case 0x1:
            return decodeSveMemContigLoad(machInst);
          case 0x2:
            return decodeSveMemGather64(machInst);
          case 0x3:
            return decodeSveMemStore(machInst);
        }
        return new Unknown64(machInst);
    }

}  // namespace Aarch64

namespace Aarch64
{

    StaticInstPtr
    decodeSveIntArithBinPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        switch (bits(machInst, 20, 19)) {
          case 0x0:
            {
                uint8_t size = bits(machInst, 23, 22);
                uint8_t opc = bits(machInst, 18, 16);
                switch (opc) {
                  case 0x0:
                    return decodeSveBinDestrPredU<SveAddPred>(
                            size, machInst, zdn, zm, pg);
                  case 0x1:
                    return decodeSveBinDestrPredU<SveSubPred>(
                            size, machInst, zdn, zm, pg);
                  case 0x3:
                    return decodeSveBinDestrPredU<SveSubr>(
                            size, machInst, zdn, zm, pg);
                  default:
                    return new Unknown64(machInst);
                }
            }
          case 0x1:
            {
                uint8_t size = bits(machInst, 23, 22);
                uint8_t u = bits(machInst, 16);
                uint8_t opc = bits(machInst, 18, 17);
                switch (opc) {
                  case 0x0:
                    return decodeSveBinDestrPred<SveSmax, SveUmax>(
                            size, u, machInst, zdn, zm, pg);
                  case 0x1:
                    return decodeSveBinDestrPred<SveSmin, SveUmin>(
                            size, u, machInst, zdn, zm, pg);
                  case 0x2:
                    return decodeSveBinDestrPred<SveSabd, SveUabd>(
                            size, u, machInst, zdn, zm, pg);
                  default:
                    return new Unknown64(machInst);
                }
            }
          case 0x2:
            {
                uint8_t size = bits(machInst, 23, 22);
                uint8_t u = bits(machInst, 16);
                uint8_t opc = bits(machInst, 18, 17);
                switch (opc) {
                  case 0x0:
                    if (u == 0) {
                        return decodeSveBinDestrPredU<SveMul>(
                                size, machInst, zdn, zm, pg);
                    } else {
                        return new Unknown64(machInst);
                    }
                  case 0x1:
                    return decodeSveBinDestrPred<SveSmulh, SveUmulh>(
                            size, u, machInst, zdn, zm, pg);
                  case 0x2:
                    if (size == 0x2 || size == 0x3) {
                        return decodeSveBinDestrPred<SveSdiv, SveUdiv>(
                                size, u, machInst, zdn, zm, pg);
                    } else {
                        return new Unknown64(machInst);
                    }
                  case 0x3:
                    if (size == 0x2 || size == 0x3) {
                        return decodeSveBinDestrPred<SveSdivr, SveUdivr>(
                                size, u, machInst, zdn, zm, pg);
                    } else {
                        return new Unknown64(machInst);
                    }
                }
                break;
            }
          case 0x3:
            {
                uint8_t size = bits(machInst, 23, 22);
                uint8_t opc = bits(machInst, 18, 16);

                switch (opc) {
                  case 0x0:
                    return decodeSveBinDestrPredU<SveOrrPred>(
                            size, machInst, zdn, zm, pg);
                  case 0x1:
                    return decodeSveBinDestrPredU<SveEorPred>(
                            size, machInst, zdn, zm, pg);
                  case 0x2:
                    return decodeSveBinDestrPredU<SveAndPred>(
                            size, machInst, zdn, zm, pg);
                  case 0x3:
                    return decodeSveBinDestrPredU<SveBicPred>(
                            size, machInst, zdn, zm, pg);
                  default:
                    return new Unknown64(machInst);
                }
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveArithBinPred

    StaticInstPtr
    decodeSveIntReduc(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = bits(machInst, 23, 22);

        switch (bits(machInst, 20, 19)) {
          case 0x0:
            {
                uint8_t u = bits(machInst, 16);
                uint8_t opc = bits(machInst, 18, 17);
                if (opc != 0x0 || (!u && size == 0x3)) {
                    return new Unknown64(machInst);
                } else {
                    return decodeSveWideningReduc<SveSaddv, SveUaddv>(
                            size, u, machInst, vd, zn, pg);
                }
            }
          case 0x1:
            {
                uint8_t u = bits(machInst, 16);
                uint8_t opc = bits(machInst, 18, 17);
                switch (opc) {
                  case 0x0:
                    return decodeSveUnaryPred<SveSmaxv, SveUmaxv>(
                            size, u, machInst, vd, zn, pg);
                  case 0x1:
                    return decodeSveUnaryPred<SveSminv, SveUminv>(
                            size, u, machInst, vd, zn, pg);
                  default:
                    return new Unknown64(machInst);
                }
            }
          case 0x2:
            {
                uint8_t opc = bits(machInst, 18, 17);
                uint8_t merge = bits(machInst, 16);
                switch (opc) {
                  case 0x0:
                    if (merge) {
                        return decodeSveUnaryPredU<SveMovprfxPredM>(
                                size, machInst, vd /* zd */, zn, pg);
                    } else {
                        return decodeSveUnaryPredU<SveMovprfxPredZ>(
                                size, machInst, vd /* zd */, zn, pg);
                    }
                  default:
                    return new Unknown64(machInst);
                }
            }
          case 0x3:
            {
                uint8_t opc = bits(machInst, 18, 16);
                switch (opc) {
                  case 0x0:
                    return decodeSveUnaryPredU<SveOrv>(
                            size, machInst, vd, zn, pg);
                  case 0x1:
                    return decodeSveUnaryPredU<SveEorv>(
                            size, machInst, vd, zn, pg);
                  case 0x2:
                    return decodeSveUnaryPredU<SveAndv>(
                            size, machInst, vd, zn, pg);
                  default:
                    return new Unknown64(machInst);
                }
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntReduc

    StaticInstPtr
    decodeSveIntMulAdd(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = bits(machInst, 23, 22);
        uint8_t opc = (bits(machInst, 15) << 1) | bits(machInst, 13);
        switch (opc) {
          case 0x0:
            return decodeSveTerPredS<SveMla>(
                    size, machInst, zda, zn, zm, pg);
          case 0x1:
            return decodeSveTerPredS<SveMls>(
                    size, machInst, zda, zn, zm, pg);
          case 0x2:
            return decodeSveTerPredS<SveMad>(
                    size, machInst, zda /* zdn */, zn /* za */, zm, pg);
          case 0x3:
            return decodeSveTerPredS<SveMsb>(
                    size, machInst, zda /* zdn */, zn /* za */, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMulAdd

    StaticInstPtr
    decodeSveShiftByImmPred0(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t imm3 = (uint8_t) bits(machInst, 7, 5);

        uint8_t tsize = (bits(machInst, 23, 22) << 2) | bits(machInst, 9, 8);
        uint8_t esize = 0;
        uint8_t size = 0;

        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else if (tsize == 0x1) {
            esize = 8;
        } else if ((tsize & 0x0E) == 0x2) {
            esize = 16;
            size = 1;
        } else if ((tsize & 0x0C) == 0x4) {
            esize = 32;
            size = 2;
        } else if ((tsize & 0x08) == 0x8) {
            esize = 64;
            size = 3;
        }

        uint8_t opc = bits(machInst, 18, 16);
        switch (opc) {
            case 0x0:
                {
                    unsigned shiftAmt = 2 * esize - ((tsize << 3) | imm3);
                    return decodeSveBinImmPredU<SveAsrImmPred>(
                            size, machInst, zdn, shiftAmt, pg);
                }
            case 0x01:
                {
                    unsigned shiftAmt = 2 * esize - ((tsize << 3) | imm3);
                    return decodeSveBinImmPredU<SveLsrImmPred>(
                            size, machInst, zdn, shiftAmt, pg);
                }
            case 0x03:
                {
                    unsigned shiftAmt = ((tsize << 3) | imm3) - esize;
                    return decodeSveBinImmPredU<SveLslImmPred>(
                            size, machInst, zdn, shiftAmt, pg);
                }
            case 0x04:
                {
                    unsigned shiftAmt = 2 * esize - ((tsize << 3) | imm3);
                    return decodeSveBinImmPredS<SveAsrd>(
                            size, machInst, zdn, shiftAmt, pg);
                }
        }
        return new Unknown64(machInst);
    } // decodeSveShiftByImmPred0

    StaticInstPtr
    decodeSveShiftByVectorPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opc = bits(machInst, 18, 16);
        switch (opc) {
            case 0:
                return decodeSveBinDestrPredU<SveAsrPred>(
                        size, machInst, zdn, zm, pg);
            case 1:
                return decodeSveBinDestrPredU<SveLsrPred>(
                        size, machInst, zdn, zm, pg);
            case 3:
                return decodeSveBinDestrPredU<SveLslPred>(
                        size, machInst, zdn, zm, pg);
            case 4:
                return decodeSveBinDestrPredU<SveAsrr>(
                        size, machInst, zdn, zm, pg);
            case 5:
                return decodeSveBinDestrPredU<SveLsrr>(
                        size, machInst, zdn, zm, pg);
            case 7:
                return decodeSveBinDestrPredU<SveLslr>(
                        size, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    } // decodeSveShiftByVectorPred

    StaticInstPtr
    decodeSveShiftByWideElemsPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opc = bits(machInst, 18, 16);
        switch (opc) {
            case 0x0:
                return decodeSveBinDestrPredU<SveAsrWidePred>(
                        size, machInst, zdn, zm, pg);
            case 0x1:
                return decodeSveBinDestrPredU<SveLsrWidePred>(
                        size, machInst, zdn, zm, pg);
            case 0x3:
                return decodeSveBinDestrPredU<SveLslWidePred>(
                        size, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    } // decodeSveShiftByWideElemsPred

    StaticInstPtr
    decodeSveShiftByImmPred(ExtMachInst machInst)
    {
        uint8_t b20_19 = bits(machInst, 20, 19);
        uint8_t b23_22 = bits(machInst, 23, 22);

        if (b20_19 == 0x0) {
            return decodeSveShiftByImmPred0(machInst);
        } else if (b20_19 == 0x2) {
            return decodeSveShiftByVectorPred(machInst);
        } else if (b20_19 == 0x3 && b23_22 != 0x3) {
            return decodeSveShiftByWideElemsPred(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveShiftByImmPred

    StaticInstPtr
    decodeSveIntArithUnaryPred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        unsigned esize = bits(machInst, 23, 22);
        uint8_t opg = bits(machInst, 20, 19);
        uint8_t opc = bits(machInst, 18, 16);
        if (opg == 0x2) {
            bool unsig = static_cast<bool>(opc & 1);
            switch (opc) {
                case 0:
                case 1:
                    if (esize == 0) break;
                    if (unsig) {
                        return decodeSveUnaryExtendFromBPredU<SveUxtb>(
                                esize, machInst, zd, zn, pg);
                    } else {
                        return decodeSveUnaryExtendFromBPredU<SveSxtb>(
                                esize, machInst, zd, zn, pg);
                    }
                case 2:
                case 3:
                    if (esize < 2) break;
                    if (unsig) {
                        return decodeSveUnaryExtendFromHPredU<SveUxth>(
                                esize, machInst, zd, zn, pg);
                    } else {
                        return decodeSveUnaryExtendFromHPredU<SveSxth>(
                                esize, machInst, zd, zn, pg);
                    }
                case 4:
                case 5:
                    if (esize != 3) break;
                    if (unsig) {
                        return new SveUxtw<uint32_t, uint64_t>(
                                machInst, zd, zn, pg);
                    } else {
                        return new SveSxtw<uint32_t, uint64_t>(
                                machInst, zd, zn, pg);
                    }
                case 6:
                    return decodeSveUnaryPredS<SveAbs>(
                            esize, machInst, zd, zn, pg);
                case 7:
                    return decodeSveUnaryPredS<SveNeg>(
                            esize, machInst, zd, zn, pg);
            }
        } else if (opg == 0x3) {
            switch (opc) {
                case 0:
                    return decodeSveUnaryPredS<SveCls>(
                            esize, machInst, zd, zn, pg);
                case 1:
                    return decodeSveUnaryPredS<SveClz>(
                            esize, machInst, zd, zn, pg);
                case 2:
                    return decodeSveUnaryPredU<SveCnt>(
                            esize, machInst, zd, zn, pg);
                case 3:
                    return decodeSveUnaryPredU<SveCnot>(
                            esize, machInst, zd, zn, pg);
                case 4:
                    return decodeSveUnaryPredF<SveFabs>(
                            esize, machInst, zd, zn, pg);
                case 5:
                    return decodeSveUnaryPredF<SveFneg>(
                            esize, machInst, zd, zn, pg);
                case 6:
                    return decodeSveUnaryPredU<SveNot>(
                            esize, machInst, zd, zn, pg);
                    break;
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntArithUnaryPred

    StaticInstPtr
    decodeSveIntArithUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t opc = (uint8_t) bits(machInst, 12, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (opc) {
            case 0x0:
                return decodeSveBinUnpredU<SveAddUnpred>(size, machInst,
                        zd, zn, zm);
            case 0x1:
                return decodeSveBinUnpredU<SveSubUnpred>(size, machInst,
                        zd, zn, zm);
            case 0x4:
                return decodeSveBinUnpredS<SveSqadd>(size, machInst,
                        zd, zn, zm);
            case 0x5:
                return decodeSveBinUnpredU<SveUqadd>(size, machInst,
                        zd, zn, zm);
            case 0x6:
                return decodeSveBinUnpredS<SveSqsub>(size, machInst,
                        zd, zn, zm);
            case 0x7:
                return decodeSveBinUnpredU<SveUqsub>(size, machInst,
                        zd, zn, zm);
        }

        return new Unknown64(machInst);
    }  // decodeSveIntArithUnpred

    StaticInstPtr
    decodeSveIntLogUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc = (uint8_t) (bits(machInst, 23, 22) << 3
                | bits(machInst, 12, 10));

        switch (opc) {
            case 0x4:
                return new SveAndUnpred<uint64_t>(machInst, zd, zn, zm);
            case 0xc:
                return new SveOrrUnpred<uint64_t>(machInst, zd, zn, zm);
            case 0x14:
                return new SveEorUnpred<uint64_t>(machInst, zd, zn, zm);
            case 0x1c:
                return new SveBicUnpred<uint64_t>(machInst, zd, zn, zm);
        }

        return new Unknown64(machInst);
    }  // decodeSveIntLogUnpred

    StaticInstPtr
    decodeSveIndexGen(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);
        uint8_t grp = (uint8_t) bits(machInst, 11, 10);

        switch (grp) {
            case 0:
                { // INDEX (immediate)
                    int8_t imm5 = sext<5>(bits(machInst, 9, 5));
                    int8_t imm5b = sext<5>(bits(machInst, 20, 16));
                    switch (size) {
                        case 0:
                            return new SveIndexII<int8_t>(machInst,
                                    zd, imm5, imm5b);
                        case 1:
                            return new SveIndexII<int16_t>(machInst,
                                    zd, imm5, imm5b);
                        case 2:
                            return new SveIndexII<int32_t>(machInst,
                                    zd, imm5, imm5b);
                        case 3:
                            return new SveIndexII<int64_t>(machInst,
                                    zd, imm5, imm5b);
                    }
                    break;
                }
            case 1:
                { // INDEX (scalar, immediate)
                    int8_t imm5 = sext<5>(bits(machInst, 20, 16));
                    RegIndex zn = (RegIndex) (uint8_t) bits(
                            machInst, 9, 5);
                    switch (size) {
                        case 0:
                            return new SveIndexRI<int8_t>(machInst,
                                    zd, zn, imm5);
                        case 1:
                            return new SveIndexRI<int16_t>(machInst,
                                    zd, zn, imm5);
                        case 2:
                            return new SveIndexRI<int32_t>(machInst,
                                    zd, zn, imm5);
                        case 3:
                            return new SveIndexRI<int64_t>(machInst,
                                    zd, zn, imm5);
                    }
                    break;
                }
            case 2:
                { // INDEX (immediate, scalar)
                    int8_t imm5 = sext<5>(bits(machInst, 9, 5));
                    RegIndex zm = (RegIndex) (uint8_t) bits(
                            machInst, 20, 16);
                    switch (size) {
                        case 0:
                            return new SveIndexIR<int8_t>(machInst,
                                    zd, imm5, zm);
                        case 1:
                            return new SveIndexIR<int16_t>(machInst,
                                    zd, imm5, zm);
                        case 2:
                            return new SveIndexIR<int32_t>(machInst,
                                    zd, imm5, zm);
                        case 3:
                            return new SveIndexIR<int64_t>(machInst,
                                    zd, imm5, zm);
                    }
                    break;
                }
            case 3:
                { // INDEX (scalars)
                    RegIndex zn = (RegIndex) (uint8_t) bits(
                            machInst, 9, 5);
                    RegIndex zm = (RegIndex) (uint8_t) bits(
                            machInst, 20, 16);
                    switch (size) {
                        case 0:
                            return new SveIndexRR<int8_t>(machInst,
                                    zd, zn, zm);
                        case 1:
                            return new SveIndexRR<int16_t>(machInst,
                                    zd, zn, zm);
                        case 2:
                            return new SveIndexRR<int32_t>(machInst,
                                    zd, zn, zm);
                        case 3:
                            return new SveIndexRR<int64_t>(machInst,
                                    zd, zn, zm);
                    }
                }
        }
        return new Unknown64(machInst);
    }  // decodeSveIndexGen

    StaticInstPtr
    decodeSveStackAlloc(ExtMachInst machInst)
    {
        uint8_t b23_22 = bits(machInst, 23, 22);
        uint8_t b11 = bits(machInst, 11);
        if ((b23_22 & 0x2) == 0x0 && b11 == 0x0) {
            RegIndex rd = makeSP(
                (RegIndex) (uint8_t) bits(machInst, 4, 0));
            RegIndex rn = makeSP(
                (RegIndex) (uint8_t) bits(machInst, 20, 16));
            uint64_t imm = sext<6>(bits(machInst, 10, 5));
            if ((b23_22 & 0x1) == 0x0) {
                return new AddvlXImm(machInst, rd, rn, imm);
            } else {
                return new AddplXImm(machInst, rd, rn, imm);
            }
        } else if (b23_22 == 0x2 && b11 == 0x0) {
            RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            uint64_t imm = sext<6>(bits(machInst, 10, 5));
            if (bits(machInst, 20, 16) == 0x1f) {
                return new SveRdvl(machInst, rd, imm);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveStackAlloc

    StaticInstPtr
    decodeSveShiftByWideElemsUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opc = (uint8_t) bits(machInst, 11, 10);
        switch (opc) {
            case 0x0:
                return decodeSveBinUnpredU<SveAsrWideUnpred>(
                        size, machInst, zd, zn, zm);
            case 0x1:
                return decodeSveBinUnpredU<SveLsrWideUnpred>(
                        size, machInst, zd, zn, zm);
            case 0x3:
                return decodeSveBinUnpredU<SveLslWideUnpred>(
                        size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveShiftByWideElemsUnpred

    StaticInstPtr
    decodeSveShiftByImmUnpredB(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t imm3 = (uint8_t) bits(machInst, 18, 16);

        uint8_t tsize = (bits(machInst, 23, 22) << 2) | bits(machInst, 20, 19);
        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else if (tsize == 0x1) {
            esize = 8;
        } else if ((tsize & 0x0E) == 0x2) {
            esize = 16;
            size = 1;
        } else if ((tsize & 0x0C) == 0x4) {
            esize = 32;
            size = 2;
        } else if ((tsize & 0x08) == 0x8) {
            esize = 64;
            size = 3;
        }

        uint8_t opc = bits(machInst, 11, 10);
        switch (opc) {
            case 0x00:
                {
                    unsigned shiftAmt = 2 * esize - ((tsize << 3) | imm3);
                    return decodeSveBinImmUnpredU<SveAsrImmUnpred>(
                            size, machInst, zd, zn, shiftAmt);
                }
            case 0x01:
                {
                    unsigned shiftAmt = 2 * esize - ((tsize << 3) | imm3);
                    return decodeSveBinImmUnpredU<SveLsrImmUnpred>(
                            size, machInst, zd, zn, shiftAmt);
                }
            case 0x03:
                {
                    unsigned shiftAmt = ((tsize << 3) | imm3) - esize;
                    return decodeSveBinImmUnpredU<SveLslImmUnpred>(
                            size, machInst, zd, zn, shiftAmt);
                }
        }

        return new Unknown64(machInst);
    }  // decodeSveShiftByImmUnpredB

    StaticInstPtr
    decodeSveShiftByImmUnpred(ExtMachInst machInst)
    {
        if (bits(machInst, 12)) {
            return decodeSveShiftByImmUnpredB(machInst);
        } else {
            return decodeSveShiftByWideElemsUnpred(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveShiftByImmUnpred

    StaticInstPtr
    decodeSveCompVecAddr(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t mult = 1 << bits(machInst, 11, 10);

        uint8_t opc = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:
            return new SveAdr<uint64_t>(machInst, zd, zn, zm, mult,
                    SveAdr<uint64_t>::SveAdrOffsetUnpackedSigned);
          case 0x1:
            return new SveAdr<uint64_t>(machInst, zd, zn, zm, mult,
                    SveAdr<uint64_t>::SveAdrOffsetUnpackedUnsigned);
          case 0x2:
            return new SveAdr<uint32_t>(machInst, zd, zn, zm, mult,
                    SveAdr<uint32_t>::SveAdrOffsetPacked);
          case 0x3:
            return new SveAdr<uint64_t>(machInst, zd, zn, zm, mult,
                    SveAdr<uint64_t>::SveAdrOffsetPacked);
        }
        return new Unknown64(machInst);
    }  // decodeSveCompVecAddr

    StaticInstPtr
    decodeSveIntMiscUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t size = bits(machInst, 23, 22);
        uint8_t opc = bits(machInst, 11, 10);
        switch (opc) {
          case 0x0:
            // SVE floating-point trig select coefficient
            {
                if (size == 0) {
                    break;
                }
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst,
                                                              20, 16);
                return decodeSveBinUnpredF<SveFtssel>(
                    size, machInst, zd, zn, zm);
            }
          case 0x2:
            // SVE floating-point exponential accelerator
            if (size == 0) {
                break;
            }
            return decodeSveUnaryUnpredF<SveFexpa>(size, machInst, zd, zn);
          case 0x3:
            // SVE constructive prefix (unpredicated)
            if (size == 0x0 && bits(machInst, 20, 16) == 0x0) {
                return new SveMovprfxUnpred<uint64_t>(machInst, zd, zn);
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMiscUnpred

    StaticInstPtr
    decodeSveElemCount(ExtMachInst machInst)
    {
        uint8_t opc20 = (uint8_t) bits(machInst, 20);
        uint8_t b13_12 = (uint8_t) bits(machInst, 13, 12);
        uint8_t opc11 = (uint8_t) bits(machInst, 11);
        uint8_t opc10 = (uint8_t) bits(machInst, 10);
        uint8_t opc11_10 = (uint8_t) bits(machInst, 11, 10);
        if (b13_12 == 0) {
            uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
            uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
            RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            unsigned size = (unsigned) bits(machInst, 23, 22);
            if (opc20) {
                if (opc11 == 0) {
                    if (opc10) {
                        return decodeSveElemIntCountLU<SveDecv>(size,
                                machInst, zdn, pattern, imm4);
                    } else {
                        return decodeSveElemIntCountLU<SveIncv>(size,
                                machInst, zdn, pattern, imm4);
                    }
                }
            } else {
                if (opc11) {
                    if (opc10) {
                        return decodeSveElemIntCountLU<SveUqdecv>(size,
                                machInst, zdn, pattern, imm4);
                    } else {
                        return decodeSveElemIntCountLS<SveSqdecv>(size,
                                machInst, zdn, pattern, imm4);
                    }
                } else {
                    if (opc10) {
                        return decodeSveElemIntCountLU<SveUqincv>(size,
                                machInst, zdn, pattern, imm4);
                    } else {
                        return decodeSveElemIntCountLS<SveSqincv>(size,
                                machInst, zdn, pattern, imm4);
                    }
                }
            }
        } else if (b13_12 == 3) {
            uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
            uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
            RegIndex rdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            unsigned size = (unsigned) bits(machInst, 23, 22);
            switch (opc11_10) {
                case 0:
                    if (opc20) {
                        return decodeSveElemIntCountS<SveSqinc>(size,
                                machInst, rdn, pattern, imm4);
                    } else {
                        return decodeSveElemIntCountS<SveSqinc32>(size,
                                machInst, rdn, pattern, imm4);
                    }
                case 1:
                    if (opc20) {
                        return decodeSveElemIntCountU<SveUqinc>(size,
                                machInst, rdn, pattern, imm4);
                    } else {
                        return decodeSveElemIntCountU<SveUqinc32>(size,
                                machInst, rdn, pattern, imm4);
                    }
                case 2:
                    if (opc20) {
                        return decodeSveElemIntCountS<SveSqdec>(size,
                                machInst, rdn, pattern, imm4);
                    } else {
                        return decodeSveElemIntCountS<SveSqdec32>(size,
                                machInst, rdn, pattern, imm4);
                    }
                case 3:
                    if (opc20) {
                        return decodeSveElemIntCountU<SveUqdec>(size,
                                machInst, rdn, pattern, imm4);
                    } else {
                        return decodeSveElemIntCountU<SveUqdec32>(size,
                                machInst, rdn, pattern, imm4);
                    }
            }
        } else if (opc20 && b13_12 == 2 && !(opc11_10 & 0x2)) {
            uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
            uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
            RegIndex rdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            unsigned size = (unsigned) bits(machInst, 23, 22);
            if (opc11_10 & 0x1) {
                return decodeSveElemIntCountU<SveDec>(size, machInst,
                        rdn, pattern, imm4);
            } else {
                return decodeSveElemIntCountU<SveInc>(size, machInst,
                        rdn, pattern, imm4);
            }
        } else if (!opc20 && b13_12 == 2 && opc11_10 == 0) {
            uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
            uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
            RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            unsigned size = (unsigned) bits(machInst, 23, 22);
            return decodeSveElemIntCountU<SveCntx>(size, machInst,
                    rd, pattern, imm4);
        }
        return new Unknown64(machInst);
    }  // decodeSveElemCount

    StaticInstPtr
    decodeSveLogMaskImm(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        bool n = bits(machInst, 17);
        uint8_t immr = bits(machInst, 16, 11);
        uint8_t imms = bits(machInst, 10, 5);

        // Decode bitmask
        // len = MSB(n:NOT(imms)), len < 1 is undefined
        uint8_t len = 0;
        if (n) {
            len = 6;
        } else if (imms == 0x3f || imms == 0x3e) {
            return new Unknown64(machInst);
        } else {
            len = findMsbSet(imms ^ 0x3f);
        }
        // Generate r, s, and size
        uint64_t r = bits(immr, len - 1, 0);
        uint64_t s = bits(imms, len - 1, 0);
        uint8_t size = 1 << len;
        if (s == size - 1)
            return new Unknown64(machInst);
        // Generate the pattern with s 1s, rotated by r, with size bits
        uint64_t pattern = mask(s + 1);
        if (r) {
            pattern = (pattern >> r) | (pattern << (size - r));
            pattern &= mask(size);
        }
        // Replicate that to fill up the immediate
        for (unsigned i = 1; i < (64 / size); i *= 2)
            pattern |= (pattern << (i * size));
        uint64_t imm = pattern;

        if (bits(machInst, 19, 18) == 0x0) {
            if (bits(machInst, 23, 22) == 0x3) {
                return new SveDupm<uint64_t>(machInst, zd, imm);
            } else {
                switch (bits(machInst, 23, 22)) {
                  case 0x0:
                    return new SveOrrImm<uint64_t>(machInst, zd, imm);
                  case 0x1:
                    return new SveEorImm<uint64_t>(machInst, zd, imm);
                  case 0x2:
                    return new SveAndImm<uint64_t>(machInst, zd, imm);
                }
            }
        }

        return new Unknown64(machInst);
    }  // decodeSveLogMaskImm

    StaticInstPtr
    decodeSveIntWideImmPred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 19, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (bits(machInst, 15) == 0x0) {
            uint64_t imm = bits(machInst, 12, 5);
            uint8_t sh = bits(machInst, 13);
            uint8_t m = bits(machInst, 14);
            if (sh) {
                if (size == 0x0) {
                    return new Unknown64(machInst);
                }
                imm <<= 8;
            }
            if (m) {
                if (sh) {
                    return decodeSveWideImmPredU<SveCpyImmMerge>(
                        size, machInst, zd, sext<16>(imm), pg);
                } else {
                    return decodeSveWideImmPredU<SveCpyImmMerge>(
                        size, machInst, zd, sext<8>(imm), pg);
                }
            } else {
                if (sh) {
                    return decodeSveWideImmPredU<SveCpyImmZero>(
                        size, machInst, zd, sext<16>(imm), pg,
                        false /* isMerging */);
                } else {
                    return decodeSveWideImmPredU<SveCpyImmZero>(
                        size, machInst, zd, sext<8>(imm), pg,
                        false /* isMerging */);
                }
            }
        } else if (bits(machInst, 15, 13) == 0x6 && size != 0x0) {
            uint64_t imm = vfp_modified_imm(bits(machInst, 12, 5),
                decode_fp_data_type(size));
            return decodeSveWideImmPredF<SveFcpy>(
                        size, machInst, zd, imm, pg);
        }

        return new Unknown64(machInst);
    }  // decodeSveIntWideImmPred

    StaticInstPtr
    decodeSvePermExtract(ExtMachInst machInst)
    {
        uint8_t b23_22 = (unsigned) bits(machInst, 23, 22);
        if (!b23_22) {
            uint8_t position =
                bits(machInst, 20, 16) << 3 | bits(machInst, 12, 10);
            RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            return new SveExt<uint8_t>(machInst, zdn, zm, position);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermExtract

    StaticInstPtr
    decodeSvePermUnpred(ExtMachInst machInst)
    {
        uint8_t b12_10 = bits(machInst, 12, 10);
        if (b12_10 == 0x4) {
            unsigned size = (unsigned) bits(machInst, 23, 22);
            RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
            return decodeSveBinUnpredU<SveTbl>(size, machInst, zd, zn, zm);
        } else if (bits(machInst, 20, 16) == 0x0 && b12_10 == 0x6) {
            uint8_t size = bits(machInst, 23, 22);
            RegIndex rn = makeSP(
                    (RegIndex) (uint8_t) bits(machInst, 9, 5));
            RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            return decodeSveUnaryUnpredU<SveDupScalar>(size, machInst, zd, rn);
        } else if (bits(machInst, 20, 16) == 0x4 && b12_10 == 0x6) {
            uint8_t size = bits(machInst, 23, 22);
            RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            return decodeSveUnaryUnpredU<SveInsr>(size, machInst, zdn, rm);
        } else if (bits(machInst, 20, 16) == 0x14 && b12_10 == 0x6) {
            uint8_t size = bits(machInst, 23, 22);
            RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            return decodeSveUnaryUnpredU<SveInsrf>(size, machInst, zdn, vm);
        } else if (bits(machInst, 20, 16) == 0x18 && b12_10 == 0x6) {
            uint8_t size = bits(machInst, 23, 22);
            RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            return decodeSveUnaryUnpredU<SveRevv>(size, machInst, zd, zn);
        } else if (b12_10 == 0x0 && bits(machInst, 20, 16) != 0x0) {
            uint8_t imm =
                bits(machInst, 23, 22) << 5 | // imm3h
                bits(machInst, 20) << 4 |     // imm3l
                bits(machInst, 19, 16);       // tsz
            RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            if (imm & 0x1) {
                imm >>= 1;
                return new SveDupIdx<uint8_t>(machInst, zd, zn, imm);
            } else if (imm & 0x2) {
                imm >>= 2;
                return new SveDupIdx<uint16_t>(machInst, zd, zn, imm);
            } else if (imm & 0x4) {
                imm >>= 3;
                return new SveDupIdx<uint32_t>(machInst, zd, zn, imm);
            } else if (imm & 0x8) {
                imm >>= 4;
                return new SveDupIdx<uint64_t>(machInst, zd, zn, imm);
            } else if (imm & 0x10) {
                imm >>= 5;
                return new SveDupIdx<__uint128_t>(machInst, zd, zn, imm);
            }
            return new Unknown64(machInst);
        } else if (bits(machInst, 23, 22) != 0x0 &&
                   bits(machInst, 20, 18) == 0x4 && b12_10 == 0x6) {
            unsigned size = (unsigned) bits(machInst, 23, 22);
            RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            if (bits(machInst, 17)) {
                if (bits(machInst, 16)) {
                    return decodeSveUnpackU<SveUunpkhi>(size, machInst,
                                                        zd, zn);
                } else {
                    return decodeSveUnpackU<SveUunpklo>(size, machInst,
                                                        zd, zn);
                }
            } else {
                if (bits(machInst, 16)) {
                    return decodeSveUnpackS<SveSunpkhi>(size, machInst,
                                                        zd, zn);
                } else {
                    return decodeSveUnpackS<SveSunpklo>(size, machInst,
                                                        zd, zn);
                }
            }
        }
        return new Unknown64(machInst);
    }  // decodeSvePermUnpred

    StaticInstPtr
    decodeSvePermPredicates(ExtMachInst machInst)
    {
        if (bits(machInst, 20) == 0x0 && bits(machInst, 12, 11) != 0x3 &&
                bits(machInst, 9) == 0x0 && bits(machInst, 4) == 0x0) {
            RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

            uint8_t size = bits(machInst, 23, 22);

            uint8_t opc = bits(machInst, 12, 10);

            switch (opc) {
              case 0x0:
                return decodeSveBinUnpredU<SveZip1Pred>(size,
                        machInst, zd, zn, zm);
              case 0x1:
                return decodeSveBinUnpredU<SveZip2Pred>(size,
                        machInst, zd, zn, zm);
              case 0x2:
                return decodeSveBinUnpredU<SveUzp1Pred>(size,
                        machInst, zd, zn, zm);
              case 0x3:
                return decodeSveBinUnpredU<SveUzp2Pred>(size,
                        machInst, zd, zn, zm);
              case 0x4:
                return decodeSveBinUnpredU<SveTrn1Pred>(size,
                        machInst, zd, zn, zm);
              case 0x5:
                return decodeSveBinUnpredU<SveTrn2Pred>(size,
                        machInst, zd, zn, zm);
            }
        } else if (bits(machInst, 23, 22) == 0x0 &&
                bits(machInst, 20, 17) == 0x8 && bits(machInst, 12, 9) == 0x0
                && bits(machInst, 4) == 0x0) {
            RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
            RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
            if (bits(machInst, 16)) {
                return new SvePunpkhi<uint8_t, uint16_t>(machInst, pd, pn);
            } else {
                return new SvePunpklo<uint8_t, uint16_t>(machInst, pd, pn);
            }
        } else if (bits(machInst, 20, 16) == 0x14 &&
                bits(machInst, 12, 9) == 0x00 && bits(machInst, 4) == 0) {
            uint8_t size = bits(machInst, 23, 22);
            RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
            RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
            return decodeSveUnaryUnpredU<SveRevp>(size, machInst, pd, pn);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermPredicates

    StaticInstPtr
    decodeSvePermIntlv(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t size = bits(machInst, 23, 22);

        uint8_t opc = bits(machInst, 12, 10);

        switch (opc) {
          case 0x0:
            return decodeSveBinUnpredU<SveZip1>(size, machInst, zd, zn, zm);
          case 0x1:
            return decodeSveBinUnpredU<SveZip2>(size, machInst, zd, zn, zm);
          case 0x2:
            return decodeSveBinUnpredU<SveUzp1>(size, machInst, zd, zn, zm);
          case 0x3:
            return decodeSveBinUnpredU<SveUzp2>(size, machInst, zd, zn, zm);
          case 0x4:
            return decodeSveBinUnpredU<SveTrn1>(size, machInst, zd, zn, zm);
          case 0x5:
            return decodeSveBinUnpredU<SveTrn2>(size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermIntlv

    StaticInstPtr
    decodeSvePermPred(ExtMachInst machInst)
    {
        uint8_t b13 = bits(machInst, 13);
        uint8_t b23 = bits(machInst, 23);
        switch (bits(machInst, 20, 16)) {
          case 0x0:
            if (!b13) {
                uint8_t size = bits(machInst, 23, 22);
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex vn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                return decodeSveUnaryPredU<SveCpySimdFpScalar>(size,
                        machInst, zd, vn, pg);
            }
            break;
          case 0x1:
            if (!b13 && b23) {
                // sve_int_perm_compact
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                if (bits(machInst, 22)) {
                    return new SveCompact<uint64_t>(machInst, zd, zn, pg);
                } else {
                    return new SveCompact<uint32_t>(machInst, zd, zn, pg);
                }
            }
            break;
          case 0x8:
            if (b13) {
                uint8_t size = bits(machInst, 23, 22);
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex rn = makeSP(
                        (RegIndex)(uint8_t) bits(machInst, 9, 5));
                RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                return decodeSveUnaryPredU<SveCpyScalar>(size,
                        machInst, zd, rn, pg);
            }
            break;
          case 0xC:
            if (!b13) {
                uint8_t size = bits(machInst, 23, 22);
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex zdn = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                RegIndex zm = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                return decodeSveBinDestrPredU<SveSplice>(size, machInst,
                        zdn, zm, pg);
            }
            break;
        }
        switch (bits(machInst, 20, 17)) {
          case 0x0:
            if (b13) {
                uint8_t AB = bits(machInst, 16);
                uint8_t size = bits(machInst, 23, 22);
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                RegIndex rd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                if (!AB) {
                    return decodeSveUnaryPredU<SveLasta>(size,
                            machInst, rd, zn, pg);
                } else {
                    return decodeSveUnaryPredU<SveLastb>(size,
                            machInst, rd, zn, pg);
                }
            }
            break;
          case 0x1:
            if (!b13) {
                uint8_t AB = bits(machInst, 16);
                uint8_t size = bits(machInst, 23, 22);
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                RegIndex vd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                if (!AB) {
                    return decodeSveUnaryPredU<SveLastaf>(size,
                            machInst, vd, zn, pg);
                } else {
                    return decodeSveUnaryPredU<SveLastbf>(size,
                            machInst, vd, zn, pg);
                }
            }
            break;
          case 0x4:
            if (!b13) {
                uint8_t AB = bits(machInst, 16);
                uint8_t size = bits(machInst, 23, 22);
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex zm = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                RegIndex zdn = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                if (!AB) {
                    return decodeSveUnaryPredU<SveClastav>(size,
                            machInst, zdn, zm, pg);
                } else {
                    return decodeSveUnaryPredU<SveClastbv>(size,
                            machInst, zdn, zm, pg);
                }
            }
            break;
          case 0x5:
            if (!b13) {
                uint8_t AB = bits(machInst, 16);
                uint8_t size = bits(machInst, 23, 22);
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex zm = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                RegIndex zdn = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                if (!AB) {
                    return decodeSveUnaryPredU<SveClastaf>(size,
                            machInst, zdn, zm, pg);
                } else {
                    return decodeSveUnaryPredU<SveClastbf>(size,
                            machInst, zdn, zm, pg);
                }
            }
            break;
          case 0x8:
            if (b13) {
                uint8_t AB = bits(machInst, 16);
                uint8_t size = bits(machInst, 23, 22);
                RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                RegIndex zm = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                RegIndex rdn = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                if (!AB) {
                    return decodeSveUnaryPredU<SveClasta>(size,
                            machInst, rdn, zm, pg);
                } else {
                    return decodeSveUnaryPredU<SveClastb>(size,
                            machInst, rdn, zm, pg);
                }
            }
            break;
        }
        if (bits(machInst, 20, 18) == 0x1 && !b13) {
            unsigned size = (unsigned) bits(machInst, 23, 22);
            RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
            RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
            RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
            uint8_t opc17_16 = bits(machInst, 17, 16);
            switch (opc17_16) {
                case 0x00:
                    switch (size) {
                        case 1:
                            return new SveRevb<uint16_t>(machInst, zd, zn, pg);
                        case 2:
                            return new SveRevb<uint32_t>(machInst, zd, zn, pg);
                        case 3:
                            return new SveRevb<uint64_t>(machInst, zd, zn, pg);
                    }
                    break;
                case 0x01:
                    switch (size) {
                        case 2:
                            return new SveRevh<uint32_t>(machInst, zd, zn, pg);
                        case 3:
                            return new SveRevh<uint64_t>(machInst, zd, zn, pg);
                    }
                    break;
                case 0x02:
                    if (size == 3) {
                        return new SveRevw<uint64_t>(machInst, zd, zn, pg);
                    }
                    break;
                case 0x03:
                    return decodeSveUnaryPredU<SveRbit>(
                            size, machInst, zd, zn, pg);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSvePermPred

    StaticInstPtr
    decodeSveSelVec(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 13, 10);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t size = bits(machInst, 23, 22);

        return decodeSveBinConstrPredU<SveSel>(size,
            machInst, zd, zn, zm, pg, SvePredType::SELECT);
    }  // decodeSveSelVec

    StaticInstPtr
    decodeSveIntCmpVec(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        uint8_t b14 = bits(machInst, 14);
        uint8_t opc =
            bits(machInst, 15) << 2 |
            bits(machInst, 13) << 1 |
            bits(machInst, 4);
        RegIndex pd = (RegIndex) (uint8_t)bits(machInst, 3, 0);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        RegIndex zn = (RegIndex) (uint8_t)bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        if (b14 && size != 3) {
            // sve_int_cmp_1
            switch (opc) {
                case 0:
                    return decodeSveTerPredWS<SveCmpgew>(size,
                            machInst, pd, zn, zm, pg);
                case 1:
                    return decodeSveTerPredWS<SveCmpgtw>(size,
                            machInst, pd, zn, zm, pg);
                case 2:
                    return decodeSveTerPredWS<SveCmpltw>(size,
                            machInst, pd, zn, zm, pg);
                case 3:
                    return decodeSveTerPredWS<SveCmplew>(size,
                            machInst, pd, zn, zm, pg);
                case 4:
                    return decodeSveTerPredWU<SveCmphsw>(size,
                            machInst, pd, zn, zm, pg);
                case 5:
                    return decodeSveTerPredWU<SveCmphiw>(size,
                            machInst, pd, zn, zm, pg);
                case 6:
                    return decodeSveTerPredWU<SveCmplow>(size,
                            machInst, pd, zn, zm, pg);
                case 7:
                    return decodeSveTerPredWU<SveCmplsw>(size,
                            machInst, pd, zn, zm, pg);
            }
        } else if (!b14) {
            switch (opc) {
                case 0:
                    return decodeSveTerPredU<SveCmphs>(size,
                            machInst, pd, zn, zm, pg);
                case 1:
                    return decodeSveTerPredU<SveCmphi>(size,
                            machInst, pd, zn, zm, pg);
                case 2:
                    if (size != 3) {
                        return decodeSveTerPredWU<SveCmpeqw>(size,
                                machInst, pd, zn, zm, pg);
                    }
                    break;
                case 3:
                    if (size != 3) {
                        return decodeSveTerPredWU<SveCmpnew>(size,
                                machInst, pd, zn, zm, pg);
                    }
                    break;
                case 4:
                    return decodeSveTerPredS<SveCmpge>(size,
                            machInst, pd, zn, zm, pg);
                case 5:
                    return decodeSveTerPredS<SveCmpgt>(size,
                            machInst, pd, zn, zm, pg);
                case 6:
                    return decodeSveTerPredU<SveCmpeq>(size,
                            machInst, pd, zn, zm, pg);
                case 7:
                    return decodeSveTerPredU<SveCmpne>(size,
                            machInst, pd, zn, zm, pg);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpVec

    StaticInstPtr
    decodeSveIntCmpUImm(ExtMachInst machInst)
    {
        uint8_t cmp = bits(machInst, 13) << 1 | bits(machInst, 4);
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        int64_t imm = (int64_t) bits(machInst, 20, 14);
        uint8_t size = bits(machInst, 23, 22);
        switch (cmp) {
            case 0:
                return decodeSveTerImmPredU<SveCmphsi>(size,
                        machInst, pd, zn, imm, pg);
            case 1:
                return decodeSveTerImmPredU<SveCmphii>(size,
                        machInst, pd, zn, imm, pg);
            case 2:
                return decodeSveTerImmPredU<SveCmploi>(size,
                        machInst, pd, zn, imm, pg);
            case 3:
                return decodeSveTerImmPredU<SveCmplsi>(size,
                        machInst, pd, zn, imm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpUImm

    StaticInstPtr
    decodeSveIntCmpSImm(ExtMachInst machInst)
    {
        uint8_t opc = bits(machInst, 15) << 2 | bits(machInst, 13) << 1 |
            bits(machInst, 4);
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        int64_t imm = sext<5>(bits(machInst, 20, 16));
        uint8_t size = bits(machInst, 23, 22);
        switch (opc) {
            case 0:
                return decodeSveTerImmPredS<SveCmpgei>(size,
                        machInst, pd, zn, imm, pg);
            case 1:
                return decodeSveTerImmPredS<SveCmpgti>(size,
                        machInst, pd, zn, imm, pg);
            case 2:
                return decodeSveTerImmPredS<SveCmplti>(size,
                        machInst, pd, zn, imm, pg);
            case 3:
                return decodeSveTerImmPredS<SveCmplei>(size,
                        machInst, pd, zn, imm, pg);
            case 4:
                return decodeSveTerImmPredU<SveCmpeqi>(size,
                        machInst, pd, zn, imm, pg);
            case 5:
                return decodeSveTerImmPredU<SveCmpnei>(size,
                        machInst, pd, zn, imm, pg);
            default:
                return new Unknown64(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpSImm

    StaticInstPtr
    decodeSvePredLogicalOps(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        RegIndex pm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 13, 10);
        uint8_t opc = (bits(machInst, 23, 22) << 2) |
                      (bits(machInst, 9) << 1) |
                      bits(machInst, 4);
        switch (opc) {
          case 0x0:
            return new SvePredAnd<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x1:
            return new SvePredBic<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x2:
            return new SvePredEor<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x3:
            return new SvePredSel<uint8_t>(machInst, pd, pn, pm, pg, true);
          case 0x4:
            return new SvePredAnds<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x5:
            return new SvePredBics<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x6:
            return new SvePredEors<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x8:
            return new SvePredOrr<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x9:
            return new SvePredOrn<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xa:
            return new SvePredNor<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xb:
            return new SvePredNand<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xc:
            return new SvePredOrrs<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xd:
            return new SvePredOrns<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xe:
            return new SvePredNors<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xf:
            return new SvePredNands<uint8_t>(machInst, pd, pn, pm, pg);
        }

        return new Unknown64(machInst);
    }  // decodeSvePredLogicalOps

    StaticInstPtr
    decodeSvePropBreakFromPrevPartition(ExtMachInst machInst)
    {
        if (bits(machInst, 23) == 0x0 && bits(machInst, 9) == 0x0) {
            uint8_t opc = (bits(machInst, 22) << 1) | bits(machInst, 4);
            RegIndex pm = (RegIndex)(uint8_t) bits(machInst, 19, 16);
            RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 13, 10);
            RegIndex pn = (RegIndex)(uint8_t) bits(machInst, 8, 5);
            RegIndex pd = (RegIndex)(uint8_t) bits(machInst, 3, 0);
            switch (opc) {
              case 0x0:
                // BRKPA
                return new SveBrkpa(machInst, pd, pn, pm, pg);
              case 0x1:
                // BRKPB
                return new SveBrkpb(machInst, pd, pn, pm, pg);
              case 0x2:
                // BRKPAS
                return new SveBrkpas(machInst, pd, pn, pm, pg);
              case 0x3:
                // BRKPBS
                return new SveBrkpbs(machInst, pd, pn, pm, pg);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSvePropBreakFromPrevPartition

    StaticInstPtr
    decodeSvePartitionBreakCond(ExtMachInst machInst)
    {
        if (bits(machInst, 18, 16) == 0x0 && bits(machInst, 9) == 0x0) {
            bool flagset = bits(machInst, 22);
            bool merging = bits(machInst, 4);
            RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 13, 10);
            RegIndex pn = (RegIndex)(uint8_t) bits(machInst, 8, 5);
            RegIndex pd = (RegIndex)(uint8_t) bits(machInst, 3, 0);
            if (bits(machInst, 23)) {
                if (flagset) {
                    if (!merging) {
                        return new SveBrkbs(machInst, pd, pg, pn);
                    }
                } else {
                    if (merging) {
                        return new SveBrkbm(machInst, pd, pg, pn);
                    } else {
                        return new SveBrkbz(machInst, pd, pg, pn);
                    }
                }
            } else {
                if (flagset) {
                    if (!merging) {
                        return new SveBrkas(machInst, pd, pg, pn);
                    }
                } else {
                    if (merging) {
                        return new SveBrkam(machInst, pd, pg, pn);
                    } else {
                        return new SveBrkaz(machInst, pd, pg, pn);
                    }
                }
            }
            return new Unknown64(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSvePartitionBreakCond

    StaticInstPtr
    decodeSvePredTest(ExtMachInst machInst)
    {
        if (bits(machInst, 23, 22) == 0x1 &&
                bits(machInst, 18, 16) == 0x0 &&
                bits(machInst, 9) == 0x0) {
            RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
            RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 13, 10);
            return new SvePtest(machInst, pn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSvePredTest

    StaticInstPtr
    decodeSvePredIteration(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opc18_16 = bits(machInst, 18, 16);
        uint8_t opc10_9 = bits(machInst, 10, 9);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        RegIndex pdn = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        if (opc18_16 == 0x1 && opc10_9 == 0x2) {
            return decodeSveUnaryPredU<SvePnext>(size,
                    machInst, pdn, pdn, pg);
        } else if (size == 0x1 && opc18_16 == 0x0 && opc10_9 == 0) {
            return new SvePfirst<uint8_t>(machInst, pdn, pdn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSvePredIteration

    StaticInstPtr
    decodeSveInitPred(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        unsigned size = bits(machInst, 23, 22);
        uint8_t imm = bits(machInst, 9, 5);

        if (bits(machInst, 16) == 0x0) {
            return decodeSvePtrue<SvePtrue>(size, machInst, pd, imm);
        } else {
            return decodeSvePtrue<SvePtrues>(size, machInst, pd, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveInitPred

    StaticInstPtr
    decodeSveZeroPredReg(ExtMachInst machInst)
    {
        if (bits(machInst, 23, 22) == 0x0 && bits(machInst, 18, 16) == 0x0) {
            RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
            return new SvePfalse(machInst, pd);
        }
        return new Unknown64(machInst);
    }  // decodeSveZeroPredReg

    StaticInstPtr
    decodeSvePropBreakToNextPartition(ExtMachInst machInst)
    {
        if (bits(machInst, 23) == 0x0 &&
                bits(machInst, 18, 16) == 0x0 &&
                bits(machInst, 9) == 0x0 &&
                bits(machInst, 4) == 0x0) {
            RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 13, 10);
            RegIndex pn = (RegIndex)(uint8_t) bits(machInst, 8, 5);
            RegIndex pdm = (RegIndex)(uint8_t) bits(machInst, 3, 0);
            if (bits(machInst, 22) == 0x0) {
                return new SveBrkn(machInst, pdm, pn, pdm, pg);
            } else {
                return new SveBrkns(machInst, pdm, pn, pdm, pg);
            }
            return new Unknown64(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSvePropBreakToNextPartition

    StaticInstPtr
    decodeSveReadPredFromFFRPred(ExtMachInst machInst)
    {
        if (bits(machInst, 23)) {
            return new Unknown64(machInst);
        }
        RegIndex pd = (RegIndex)(uint8_t) bits(machInst, 3, 0);
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 8, 5);
        if (bits(machInst, 22)) {
            return new SveRdffrsPred(machInst, pd, pg);
        } else {
            return new SveRdffrPred(machInst, pd, pg);
        }
    }  // decodeSveReadPredFromFFRPred

    StaticInstPtr
    decodeSveReadPredFromFFRUnpred(ExtMachInst machInst)
    {
        if (bits(machInst, 23, 22) != 0) {
            return new Unknown64(machInst);
        }
        RegIndex pd = (RegIndex)(uint8_t) bits(machInst, 3, 0);
        return new SveRdffrUnpred(machInst, pd);
    }  // decodeSveReadPredFromFFRUnpred

    StaticInstPtr
    decodeSvePredGen(ExtMachInst machInst)
    {
        uint8_t b_20_15 = (bits(machInst, 20) << 1) | bits(machInst, 15);
        switch (b_20_15) {
          case 0x0:
            return decodeSvePredLogicalOps(machInst);
          case 0x1:
            return decodeSvePropBreakFromPrevPartition(machInst);
          case 0x2:
            if (bits(machInst, 19) == 0x0) {
                return decodeSvePartitionBreakCond(machInst);
            } else {
                return decodeSvePropBreakToNextPartition(machInst);
            }
          case 0x3:
            if (bits(machInst, 19) == 0x0) {
                if (bits(machInst, 4, 0) == 0x0) {
                    return decodeSvePredTest(machInst);
                } else {
                    break;
                }
            } else {
                switch (bits(machInst, 13, 12)) {
                  case 0x0:
                    if (bits(machInst, 11) == 0x0 &&
                            bits(machInst, 4) == 0x0) {
                        return decodeSvePredIteration(machInst);
                    } else {
                        break;
                    }
                  case 0x1:
                    break;
                  case 0x2:
                    if (bits(machInst, 11, 10) == 0x0 &&
                            bits(machInst, 4) == 0x0) {
                        return decodeSveInitPred(machInst);
                    } else if (bits(machInst, 11, 4) == 0x40) {
                        return decodeSveZeroPredReg(machInst);
                    }
                    break;
                  case 0x3:
                    if (bits(machInst, 11) == 0x0) {
                        if (bits(machInst, 16) == 0x0) {
                            return decodeSveReadPredFromFFRPred(machInst);
                        } else if (bits(machInst, 8, 4) == 0x0) {
                            return decodeSveReadPredFromFFRUnpred(machInst);
                        }
                    }
                    break;
                }
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSvePredGen

    StaticInstPtr
    decodeSvePredCount(ExtMachInst machInst)
    {
        uint8_t b19 = bits(machInst, 19);
        if (b19) {
            uint8_t b13_11 = bits(machInst, 13, 11);
            switch (b13_11) {
              case 0x0:
                {
                    if (bits(machInst, 10, 9) != 0x0) {
                        return new Unknown64(machInst);
                    }
                    RegIndex zdn = (RegIndex) (uint8_t)
                        bits(machInst, 4, 0);
                    RegIndex pg = (RegIndex) (uint8_t)
                        bits(machInst, 8, 5);
                    uint8_t esize = bits(machInst, 23, 22);
                    if (esize == 0x0) {
                        return new Unknown64(machInst);
                    }
                    uint8_t opc = bits(machInst, 18, 17);
                    if (opc == 0x0) {
                        uint8_t u = bits(machInst, 16);
                        if (u) {
                            return decodeSvePredCountVU<SveUqincpv>(esize,
                                    machInst, zdn, pg);
                        } else {
                            return decodeSvePredCountVS<SveSqincpv>(esize,
                                    machInst, zdn, pg);
                        }
                    } else if (opc == 0x1) {
                        uint8_t u = bits(machInst, 16);
                        if (u) {
                            return decodeSvePredCountVU<SveUqdecpv>(esize,
                                    machInst, zdn, pg);
                        } else {
                            return decodeSvePredCountVS<SveSqdecpv>(esize,
                                    machInst, zdn, pg);
                        }
                    } else if (opc == 0x2) {
                        uint8_t d = bits(machInst, 16);
                        if (d) {
                            return decodeSvePredCountVU<SveDecpv>(esize,
                                    machInst, zdn, pg);
                        } else {
                            return decodeSvePredCountVU<SveIncpv>(esize,
                                    machInst, zdn, pg);
                        }
                    }
                }
                break;
              case 0x1:
                {
                    RegIndex rdn = (RegIndex) (uint8_t)
                        bits(machInst, 4, 0);
                    RegIndex pg = (RegIndex) (uint8_t)
                        bits(machInst, 8, 5);
                    uint8_t esize = bits(machInst, 23, 22);
                    uint8_t opc = bits(machInst, 18, 17);
                    uint8_t opc2 = bits(machInst, 10, 9);
                    if (opc == 0x0) {
                        uint8_t u = bits(machInst, 16);
                        if (opc2 == 0x0) {
                            if (u) {
                                return decodeSvePredCountU<SveUqincp32>(esize,
                                        machInst, rdn, pg);
                            } else {
                                return decodeSvePredCountS<SveSqincp32>(esize,
                                        machInst, rdn, pg);
                            }
                        } else if (opc2 == 0x2) {
                            if (u) {
                                return decodeSvePredCountU<SveUqincp64>(esize,
                                        machInst, rdn, pg);
                            } else {
                                return decodeSvePredCountS<SveSqincp64>(esize,
                                        machInst, rdn, pg);
                            }
                        }
                    } else if (opc == 0x1) {
                        uint8_t u = bits(machInst, 16);
                        if (opc2 == 0x0) {
                            if (u) {
                                return decodeSvePredCountU<SveUqdecp32>(esize,
                                        machInst, rdn, pg);
                            } else {
                                return decodeSvePredCountS<SveSqdecp32>(esize,
                                        machInst, rdn, pg);
                            }
                        } else if (opc2 == 0x2) {
                            if (u) {
                                return decodeSvePredCountU<SveUqdecp64>(esize,
                                        machInst, rdn, pg);
                            } else {
                                return decodeSvePredCountS<SveSqdecp64>(esize,
                                        machInst, rdn, pg);
                            }
                        }
                    } else if (opc == 0x2) {
                        if (opc2 == 0x0) {
                            if (bits(machInst, 16)) {
                                return decodeSvePredCountU<SveDecp>(esize,
                                        machInst, rdn, pg);
                            } else {
                                return decodeSvePredCountU<SveIncp>(esize,
                                        machInst, rdn, pg);
                            }
                        }
                    }
                }
                break;
              case 0x2:
                if (bits(machInst, 23, 22) == 0x0 &&
                        bits(machInst, 10, 9) == 0x0 &&
                        bits(machInst, 4, 0) == 0x0) {
                    uint8_t opc = bits(machInst, 18, 16);
                    if (opc == 0x0) {
                        RegIndex pn = (RegIndex)(uint8_t)
                            bits(machInst, 8, 5);
                        return new SveWrffr(machInst, pn);
                    } else if (opc == 0x4 && bits(machInst, 8, 5) == 0x0) {
                        return new SveSetffr(machInst);
                    }
                }
                break;
            }
        } else {
            uint8_t opc = bits(machInst, 18, 16);
            if (opc == 0 && bits(machInst, 9) == 0) {
                RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
                RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 13,
                        10);
                uint8_t esize = bits(machInst, 23, 22);
                return decodeSveUnaryPredU<SveCntp>(esize,
                        machInst, rd, pn, pg);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSvePredCount

    StaticInstPtr
    decodeSveIntCmpSca(ExtMachInst machInst)
    {
        uint16_t b23_13_12_11_10_3_2_1_0 = (uint16_t)
            (bits(machInst, 23) << 8) | (bits(machInst, 13, 10) << 4) |
            bits(machInst, 3, 0);
        uint8_t b10 = (uint8_t) bits(machInst, 10);
        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        if (b23_13_12_11_10_3_2_1_0 == 0x180) {
            uint8_t s64b = bits(machInst, 22);
            uint8_t ne = bits(machInst, 4);
            if (ne) {
                if (s64b) {
                    return new SveCtermne<uint64_t>(machInst, rn, rm);
                } else {
                    return new SveCtermne<uint32_t>(machInst, rn, rm);
                }
            } else {
                if (s64b) {
                    return new SveCtermeq<uint64_t>(machInst, rn, rm);
                } else {
                    return new SveCtermeq<uint32_t>(machInst, rn, rm);
                }
            }
        } else if (b10) {
            RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
            uint8_t size = (uint8_t) bits(machInst, 23, 22);
            uint8_t s64b = (uint8_t) bits(machInst, 12);
            uint8_t opc = (uint8_t) bits(machInst, 11) << 1 |
                bits(machInst, 4);
            if (s64b) {
                switch (opc) {
                    case 0:
                        return decodeSveBinUnpredS<SveWhilelt64>(size,
                                machInst, pd, rn, rm);
                    case 1:
                        return decodeSveBinUnpredS<SveWhilele64>(size,
                                machInst, pd, rn, rm);
                    case 2:
                        return decodeSveBinUnpredU<SveWhilelo64>(size,
                                machInst, pd, rn, rm);
                    case 3:
                        return decodeSveBinUnpredU<SveWhilels64>(size,
                                machInst, pd, rn, rm);
                }
            } else {
                switch (opc) {
                    case 0:
                        return decodeSveBinUnpredS<SveWhilelt32>(size,
                                machInst, pd, rn, rm);
                    case 1:
                        return decodeSveBinUnpredS<SveWhilele32>(size,
                                machInst, pd, rn, rm);
                    case 2:
                        return decodeSveBinUnpredU<SveWhilelo32>(size,
                                machInst, pd, rn, rm);
                    case 3:
                        return decodeSveBinUnpredU<SveWhilels32>(size,
                                machInst, pd, rn, rm);
                }
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpSca

    StaticInstPtr
    decodeSveIntWideImmUnpred0(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = bits(machInst, 12, 5);
        uint8_t sh = bits(machInst, 13);
        uint8_t size = bits(machInst, 23, 22);

        if (sh) {
            if (size == 0x0) {
                return new Unknown64(machInst);
            }
            imm <<= 8;
        }

        switch (bits(machInst, 18, 16)) {
          case 0x0:
            return decodeSveWideImmUnpredU<SveAddImm>(
                size, machInst, zdn, imm);
          case 0x1:
            return decodeSveWideImmUnpredU<SveSubImm>(
                size, machInst, zdn, imm);
          case 0x3:
            return decodeSveWideImmUnpredU<SveSubrImm>(
                size, machInst, zdn, imm);
          case 0x4:
            return decodeSveWideImmUnpredS<SveSqaddImm>(
                size, machInst, zdn, imm);
          case 0x5:
            return decodeSveWideImmUnpredU<SveUqaddImm>(
                size, machInst, zdn, imm);
          case 0x6:
            return decodeSveWideImmUnpredS<SveSqsubImm>(
                size, machInst, zdn, imm);
          case 0x7:
            return decodeSveWideImmUnpredU<SveUqsubImm>(
                size, machInst, zdn, imm);
        }

        return new Unknown64(machInst);
    }  // decodeSveIntWideImmUnpred0

    StaticInstPtr
    decodeSveIntWideImmUnpred1(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = bits(machInst, 12, 5);
        uint8_t size = bits(machInst, 23, 22);

        switch (bits(machInst, 18, 16)) {
          case 0x0:
            return decodeSveWideImmUnpredS<SveSmaxImm>(
                size, machInst, zdn, sext<8>(imm));
          case 0x1:
            return decodeSveWideImmUnpredU<SveUmaxImm>(
                size, machInst, zdn, imm);
          case 0x2:
            return decodeSveWideImmUnpredS<SveSminImm>(
                size, machInst, zdn, sext<8>(imm));
          case 0x3:
            return decodeSveWideImmUnpredU<SveUminImm>(
                size, machInst, zdn, imm);
        }

        return new Unknown64(machInst);
    }  // decodeSveIntWideImmUnpred1

    StaticInstPtr
    decodeSveIntWideImmUnpred2(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = bits(machInst, 12, 5);
        uint8_t size = bits(machInst, 23, 22);

        if (bits(machInst, 18, 16) == 0x0) {
            return decodeSveWideImmUnpredU<SveMulImm>(
                size, machInst, zdn, sext<8>(imm));
        }

        return new Unknown64(machInst);
    }  // decodeSveIntWideImmUnpred2

    StaticInstPtr
    decodeSveIntWideImmUnpred3(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = bits(machInst, 12, 5);
        uint8_t sh = bits(machInst, 13);
        uint8_t size = bits(machInst, 23, 22);

        if (sh) {
            if (size == 0x0) {
                return new Unknown64(machInst);
            }
            imm <<= 8;
        }

        if (bits(machInst, 18, 17) == 0x0) {
            if (sh) {
                return decodeSveWideImmUnpredU<SveDupImm>(
                    size, machInst, zd, sext<16>(imm));
            } else {
                return decodeSveWideImmUnpredU<SveDupImm>(
                    size, machInst, zd, sext<8>(imm));
            }
        }

        return new Unknown64(machInst);
    }  // decodeSveIntWideImmUnpred3

    StaticInstPtr
    decodeSveIntWideImmUnpred4(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t size = bits(machInst, 23, 22);

        if (bits(machInst, 18, 17) == 0x0 && size != 0x0) {
            uint64_t imm = vfp_modified_imm(bits(machInst, 12, 5),
                decode_fp_data_type(size));
            return decodeSveWideImmUnpredF<SveFdup>(size, machInst, zd, imm);
        }

        return new Unknown64(machInst);
    }  // decodeSveIntWideImmUnpred4

    StaticInstPtr
    decodeSveIntWideImmUnpred(ExtMachInst machInst)
    {
        switch (bits(machInst, 20, 19)) {
          case 0x0:
            if (bits(machInst, 18, 16) != 0x2) {
                return decodeSveIntWideImmUnpred0(machInst);
            }
            break;
          case 0x1:
            if (bits(machInst, 13) == 0x0) {
                return decodeSveIntWideImmUnpred1(machInst);
            }
            break;
          case 0x2:
            if (bits(machInst, 13) == 0x0) {
                return decodeSveIntWideImmUnpred2(machInst);
            }
            break;
          case 0x3:
            if (bits(machInst, 16) == 0x0) {
                return decodeSveIntWideImmUnpred3(machInst);
            } else if (bits(machInst, 13) == 0x0) {
                return decodeSveIntWideImmUnpred4(machInst);
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveIntWideImmUnpred

    StaticInstPtr
    decodeSveMultiplyAddUnpred(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (bits(machInst, 12, 11) != 0 || !(size & 0x2)) {
            return new Unknown64(machInst);
        }

        uint8_t usig = (uint8_t) bits(machInst, 10);
        if (size & 0x1) {
            if (usig) {
                return new SveUdotv<uint16_t, uint64_t>(machInst,
                                                        zda, zn, zm);
            } else {
                return new SveSdotv<int16_t, int64_t>(machInst,
                                                        zda, zn, zm);
            }
        } else {
            if (usig) {
                return new SveUdotv<uint8_t, uint32_t>(machInst,
                                                        zda, zn, zm);
            } else {
                return new SveSdotv<int8_t, int32_t>(machInst,
                                                        zda, zn, zm);
            }
        }

        return new Unknown64(machInst);
    } // decodeSveMultiplyAddUnpred

    StaticInstPtr
    decodeSveMultiplyIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (bits(machInst, 12, 11) != 0 || !(size & 0x2)) {
            return new Unknown64(machInst);
        }

        uint8_t usig = (uint8_t) bits(machInst, 10);
        if (size & 0x1) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint8_t i1 = (uint8_t) bits(machInst, 20);
            if (usig) {
                return new SveUdoti<uint16_t, uint64_t>(machInst,
                                                        zda, zn, zm, i1);
            } else {
                return new SveSdoti<int16_t, int64_t>(machInst,
                                                        zda, zn, zm, i1);
            }
        } else {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t i2 = (uint8_t) bits(machInst, 20, 19);
            if (usig) {
                return new SveUdoti<uint8_t, uint32_t>(machInst,
                                                        zda, zn, zm, i2);
            } else {
                return new SveSdoti<int8_t, int32_t>(machInst,
                                                        zda, zn, zm, i2);
            }
        }
        return new Unknown64(machInst);
    } // decodeSveMultiplyIndexed

    StaticInstPtr
    decodeSveFpFastReduc(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = bits(machInst, 23, 22);

        if (size == 0x0) {
            return new Unknown64(machInst);
        }

        switch (bits(machInst, 18, 16)) {
          case 0x0:
            return decodeSveUnaryPredF<SveFaddv>(size, machInst, vd, zn, pg);
          case 0x4:
            return decodeSveUnaryPredF<SveFmaxnmv>(size, machInst, vd, zn, pg);
          case 0x5:
            return decodeSveUnaryPredF<SveFminnmv>(size, machInst, vd, zn, pg);
          case 0x6:
            return decodeSveUnaryPredF<SveFmaxv>(size, machInst, vd, zn, pg);
          case 0x7:
            return decodeSveUnaryPredF<SveFminv>(size, machInst, vd, zn, pg);
        }

        return new Unknown64(machInst);
    }  // decodeSveFpFastReduc

    StaticInstPtr
    decodeSveFpUnaryUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t size = (uint8_t) bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }
        uint8_t opc = (uint8_t) bits(machInst, 18, 16);

        switch (opc) {
          case 0x6:
            return decodeSveUnaryUnpredF<SveFrecpe>(
                    size, machInst, zd, zn);
          case 0x7:
            return decodeSveUnaryUnpredF<SveFrsqrte>(
                    size, machInst, zd, zn);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpUnaryUnpred

    StaticInstPtr
    decodeSveFpCmpZero(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }
        uint8_t opc = (bits(machInst, 17, 16) << 1) | bits(machInst, 4);

        switch (opc) {
          case 0x0:
            return decodeSveCmpImmF<SveFcmgeZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x1:
            return decodeSveCmpImmF<SveFcmgtZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x2:
            return decodeSveCmpImmF<SveFcmltZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x3:
            return decodeSveCmpImmF<SveFcmleZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x4:
            return decodeSveCmpImmF<SveFcmeqZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x6:
            return decodeSveCmpImmF<SveFcmneZero>(
                size, machInst, pd, zn, 0x0, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpCmpZero

    StaticInstPtr
    decodeSveFpAccumReduc(ExtMachInst machInst)
    {
        uint8_t opc = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);
        if (opc != 0 || size == 0) {
            return new Unknown64(machInst);
        }

        RegIndex vdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        return decodeSveUnaryPredF<SveFadda>(size, machInst, vdn, zm, pg);
    }  // decodeSveFpAccumReduc

    StaticInstPtr
    decodeSveFpArithUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t size = bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }
        uint8_t opc = (uint8_t) bits(machInst, 12, 10);

        switch (opc) {
          case 0x0:
            return decodeSveBinUnpredF<SveFaddUnpred>(
                    size, machInst, zd, zn, zm);
          case 0x1:
            return decodeSveBinUnpredF<SveFsubUnpred>(
                    size, machInst, zd, zn, zm);
          case 0x2:
            return decodeSveBinUnpredF<SveFmulUnpred>(
                    size, machInst, zd, zn, zm);
          case 0x3:
            return decodeSveBinUnpredF<SveFtsmul>(
                    size, machInst, zd, zn, zm);
          case 0x6:
            return decodeSveBinUnpredF<SveFrecps>(
                    size, machInst, zd, zn, zm);
          case 0x7:
            return decodeSveBinUnpredF<SveFrsqrts>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpArithUnpred

    StaticInstPtr
    decodeSveFpArithPred0(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = (uint8_t) bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }
        uint8_t opc = (uint8_t) bits(machInst, 19, 16);

        switch (opc) {
          case 0x0:
            return decodeSveBinDestrPredF<SveFaddPred>(
                    size, machInst, zdn, zm, pg);
          case 0x1:
            return decodeSveBinDestrPredF<SveFsubPred>(
                    size, machInst, zdn, zm, pg);
          case 0x2:
            return decodeSveBinDestrPredF<SveFmulPred>(
                    size, machInst, zdn, zm, pg);
          case 0x3:
            return decodeSveBinDestrPredF<SveFsubr>(
                    size, machInst, zdn, zm, pg);
          case 0x4:
            return decodeSveBinDestrPredF<SveFmaxnm>(
                    size, machInst, zdn, zm, pg);
          case 0x5:
            return decodeSveBinDestrPredF<SveFminnm>(
                    size, machInst, zdn, zm, pg);
          case 0x6:
            return decodeSveBinDestrPredF<SveFmax>(
                    size, machInst, zdn, zm, pg);
          case 0x7:
            return decodeSveBinDestrPredF<SveFmin>(
                    size, machInst, zdn, zm, pg);
          case 0x8:
            return decodeSveBinDestrPredF<SveFabd>(
                    size, machInst, zdn, zm, pg);
          case 0x9:
            return decodeSveBinDestrPredF<SveFscale>(
                    size, machInst, zdn, zm, pg);
          case 0xa:
            return decodeSveBinDestrPredF<SveFmulx>(
                    size, machInst, zdn, zm, pg);
          case 0xc:
            return decodeSveBinDestrPredF<SveFdivr>(
                    size, machInst, zdn, zm, pg);
          case 0xd:
            return decodeSveBinDestrPredF<SveFdiv>(
                    size, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpArithPred0

    StaticInstPtr
    decodeSveFpTrigMAddCoeff(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t imm = (uint8_t) bits(machInst, 18, 16);

        uint8_t size = (uint8_t) bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }

        return decodeSveTerImmUnpredF<SveFtmad>(size, machInst, zdn, zm, imm);
    }  // decodeSveFpTrigMAddCoeff

    StaticInstPtr
    decodeSveFpArithImmPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint64_t imm;

        uint8_t size = (uint8_t) bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }

        uint8_t opc = (uint8_t) bits(machInst, 18, 16);

        switch (opc) {
          case 0x0:
            imm = sveExpandFpImmAddSub((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFaddImm>(
                    size, machInst, zdn, imm, pg);
          case 0x1:
            imm = sveExpandFpImmAddSub((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFsubImm>(
                    size, machInst, zdn, imm, pg);
          case 0x2:
            imm = sveExpandFpImmMul((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFmulImm>(
                    size, machInst, zdn, imm, pg);
          case 0x3:
            imm = sveExpandFpImmAddSub((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFsubrImm>(
                    size, machInst, zdn, imm, pg);
          case 0x4:
            imm = sveExpandFpImmMaxMin((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFmaxnmImm>(
                    size, machInst, zdn, imm, pg);
          case 0x5:
            imm = sveExpandFpImmMaxMin((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFminnmImm>(
                    size, machInst, zdn, imm, pg);
          case 0x6:
            imm = sveExpandFpImmMaxMin((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFmaxImm>(
                    size, machInst, zdn, imm, pg);
          case 0x7:
            imm = sveExpandFpImmMaxMin((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFminImm>(
                    size, machInst, zdn, imm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpArithImmPred

    StaticInstPtr
    decodeSveFpArithPred(ExtMachInst machInst)
    {
        if (bits(machInst, 20) == 0) {
            return decodeSveFpArithPred0(machInst);
        } else if (bits(machInst, 19) == 0) {
            return decodeSveFpTrigMAddCoeff(machInst);
        } else {
            return decodeSveFpArithImmPred(machInst);
        }
    }  // decodeSveFpArithPred

    StaticInstPtr
    decodeSveFpUnaryPred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = (uint8_t) bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }

        uint8_t b20_19 = bits(machInst, 20, 19);
        switch (b20_19) {
          case 0x0:
            {
                if (bits(machInst, 18, 16) == 0x5) {
                    return new Unknown64(machInst);
                }
                // SVE floating-point round to integral value
                uint8_t opc = (uint8_t) bits(machInst, 18, 16);
                switch (opc) {
                  case 0x0:
                    return decodeSveUnaryPredF<SveFrintn>(
                        size, machInst, zd, zn, pg);
                  case 0x1:
                    return decodeSveUnaryPredF<SveFrintp>(
                        size, machInst, zd, zn, pg);
                  case 0x2:
                    return decodeSveUnaryPredF<SveFrintm>(
                        size, machInst, zd, zn, pg);
                  case 0x3:
                    return decodeSveUnaryPredF<SveFrintz>(
                        size, machInst, zd, zn, pg);
                  case 0x4:
                    return decodeSveUnaryPredF<SveFrinta>(
                        size, machInst, zd, zn, pg);
                  case 0x6:
                    return decodeSveUnaryPredF<SveFrintx>(
                        size, machInst, zd, zn, pg);
                  case 0x7:
                    return decodeSveUnaryPredF<SveFrinti>(
                        size, machInst, zd, zn, pg);
                }
            }
            break;
          case 0x1:
            {
                // SVE floating-point unary operations (predicated)
                uint8_t b18_16 = bits(machInst, 18, 16);
                switch (b18_16) {
                  case 0x0:
                    if (size == 0x2) {
                        return new SveFcvtNarrow<uint32_t, uint16_t>(
                            machInst, zd, zn, pg);
                    } else if (size == 0x3) {
                        return new SveFcvtNarrow<uint64_t, uint16_t>(
                            machInst, zd, zn, pg);
                    }
                    break;
                  case 0x1:
                    if (size == 0x2) {
                        return new SveFcvtWiden<uint16_t, uint32_t>(
                            machInst, zd, zn, pg);
                    } else if (size == 0x3) {
                        return new SveFcvtWiden<uint16_t, uint64_t>(
                            machInst, zd, zn, pg);
                    }
                    break;
                  case 0x2:
                    if (size == 0x3) {
                        return new SveFcvtNarrow<uint64_t, uint32_t>(
                            machInst, zd, zn, pg);
                    }
                    break;
                  case 0x3:
                    if (size == 0x3) {
                        return new SveFcvtWiden<uint32_t, uint64_t>(
                            machInst, zd, zn, pg);
                    }
                    break;
                  case 0x4:
                    if (size != 0x0) {
                        return decodeSveUnaryPredF<SveFrecpx>(
                            size, machInst, zd, zn, pg);
                    }
                    break;
                  case 0x5:
                    if (size != 0x0) {
                        return decodeSveUnaryPredF<SveFsqrt>(
                            size, machInst, zd, zn, pg);
                    }
                    break;
                }
            }
            break;
          case 0x2:
            {
                // SVE integer convert to floating-point
                uint8_t opc = (size << 3) | bits(machInst, 18, 16);
                switch (opc) {
                  case 0xa:
                    return new SveScvtfNarrow<uint16_t, uint16_t>(
                        machInst, zd, zn, pg);
                  case 0xb:
                    return new SveUcvtfNarrow<uint16_t, uint16_t>(
                        machInst, zd, zn, pg);
                  case 0xc:
                    return new SveScvtfNarrow<uint32_t, uint16_t>(
                        machInst, zd, zn, pg);
                  case 0xd:
                    return new SveUcvtfNarrow<uint32_t, uint16_t>(
                        machInst, zd, zn, pg);
                  case 0xe:
                    return new SveScvtfNarrow<uint64_t, uint16_t>(
                        machInst, zd, zn, pg);
                  case 0xf:
                    return new SveUcvtfNarrow<uint64_t, uint16_t>(
                        machInst, zd, zn, pg);
                  case 0x14:
                    return new SveScvtfNarrow<uint32_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0x15:
                    return new SveUcvtfNarrow<uint32_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0x18:
                    return new SveScvtfWiden<uint32_t, uint64_t>(
                        machInst, zd, zn, pg);
                  case 0x19:
                    return new SveUcvtfWiden<uint32_t, uint64_t>(
                        machInst, zd, zn, pg);
                  case 0x1c:
                    return new SveScvtfNarrow<uint64_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0x1d:
                    return new SveUcvtfNarrow<uint64_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0x1e:
                    return new SveScvtfNarrow<uint64_t, uint64_t>(
                        machInst, zd, zn, pg);
                  case 0x1f:
                    return new SveUcvtfNarrow<uint64_t, uint64_t>(
                        machInst, zd, zn, pg);
                }
            }
            break;
          case 0x3:
            {
                // SVE floating-point convert to integer
                uint8_t opc = (size << 3) | bits(machInst, 18, 16);
                switch (opc) {
                  case 0xa:
                    return new SveFcvtzsNarrow<uint16_t, uint16_t>(
                        machInst, zd, zn, pg);
                  case 0xb:
                    return new SveFcvtzuNarrow<uint16_t, uint16_t>(
                        machInst, zd, zn, pg);
                  case 0xc:
                    return new SveFcvtzsWiden<uint16_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0xd:
                    return new SveFcvtzuWiden<uint16_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0xe:
                    return new SveFcvtzsWiden<uint16_t, uint64_t>(
                        machInst, zd, zn, pg);
                  case 0xf:
                    return new SveFcvtzuWiden<uint16_t, uint64_t>(
                        machInst, zd, zn, pg);
                  case 0x14:
                    return new SveFcvtzsNarrow<uint32_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0x15:
                    return new SveFcvtzuNarrow<uint32_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0x18:
                    return new SveFcvtzsNarrow<uint64_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0x19:
                    return new SveFcvtzuNarrow<uint64_t, uint32_t>(
                        machInst, zd, zn, pg);
                  case 0x1c:
                    return new SveFcvtzsWiden<uint32_t, uint64_t>(
                        machInst, zd, zn, pg);
                  case 0x1d:
                    return new SveFcvtzuWiden<uint32_t, uint64_t>(
                        machInst, zd, zn, pg);
                  case 0x1e:
                    return new SveFcvtzsNarrow<uint64_t, uint64_t>(
                        machInst, zd, zn, pg);
                  case 0x1f:
                    return new SveFcvtzuNarrow<uint64_t, uint64_t>(
                        machInst, zd, zn, pg);
                }
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveFpUnaryPred

    StaticInstPtr
    decodeSveFpCmpVec(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }
        uint8_t opc = (bits(machInst, 15) << 2) |
                      (bits(machInst, 13) << 1) |
                      bits(machInst, 4);

        switch (opc) {
          case 0x0:
            return decodeSveCmpF<SveFcmge>(size, machInst, pd, zn, zm, pg);
          case 0x1:
            return decodeSveCmpF<SveFcmgt>(size, machInst, pd, zn, zm, pg);
          case 0x2:
            return decodeSveCmpF<SveFcmeq>(size, machInst, pd, zn, zm, pg);
          case 0x3:
            return decodeSveCmpF<SveFcmne>(size, machInst, pd, zn, zm, pg);
          case 0x4:
            return decodeSveCmpF<SveFcmuo>(size, machInst, pd, zn, zm, pg);
          case 0x5:
            return decodeSveCmpF<SveFacge>(size, machInst, pd, zn, zm, pg);
          case 0x7:
            return decodeSveCmpF<SveFacgt>(size, machInst, pd, zn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpCmpVec

    StaticInstPtr
    decodeSveFpFusedMulAdd(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }
        uint8_t opc = bits(machInst, 15, 13);

        switch (opc) {
          case 0x0:
            return decodeSveTerPredF<SveFmla>(
                    size, machInst, zda, zn, zm, pg);
          case 0x1:
            return decodeSveTerPredF<SveFmls>(
                    size, machInst, zda, zn, zm, pg);
          case 0x2:
            return decodeSveTerPredF<SveFnmla>(
                    size, machInst, zda, zn, zm, pg);
          case 0x3:
            return decodeSveTerPredF<SveFnmls>(
                    size, machInst, zda, zn, zm, pg);
          case 0x4:
            return decodeSveTerPredF<SveFmad>(
                    size, machInst, zda /* zdn */, zm /* za */, zn, pg);
          case 0x5:
            return decodeSveTerPredF<SveFmsb>(
                    size, machInst, zda /* zdn */, zm /* za */, zn, pg);
          case 0x6:
            return decodeSveTerPredF<SveFnmad>(
                    size, machInst, zda /* zdn */, zm /* za */, zn, pg);
          case 0x7:
            return decodeSveTerPredF<SveFnmsb>(
                    size, machInst, zda /* zdn */, zm /* za */, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpFusedMulAdd

    StaticInstPtr
    decodeSveFpCplxAdd(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        uint8_t rot = bits(machInst, 16) << 1 | 0x01;
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        switch (size) {
            case 1:
                return new SveFcadd<uint16_t>(machInst,
                        zdn, zdn, zm, pg, rot);
            case 2:
                return new SveFcadd<uint32_t>(machInst,
                        zdn, zdn, zm, pg, rot);
            case 3:
                return new SveFcadd<uint64_t>(machInst,
                        zdn, zdn, zm, pg, rot);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSveFpCplxMulAddVec(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }

        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t rot = bits(machInst, 14, 13);
        switch (size) {
            case 1:
                return new SveFcmlav<uint16_t>(machInst,
                        zda, zn, zm, pg, rot);
            case 2:
                return new SveFcmlav<uint32_t>(machInst,
                        zda, zn, zm, pg, rot);
            case 3:
                return new SveFcmlav<uint64_t>(machInst,
                        zda, zn, zm, pg, rot);
        }

        return new Unknown64(machInst);
    } // decodeSveFpCplxMulAddVec

    StaticInstPtr
    decodeSveFpCplxMulAddIndexed(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        if (size < 2) {
            return new Unknown64(machInst);
        }

        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm;
        uint8_t rot = bits(machInst, 11, 10);
        uint8_t imm;

        switch (size) {
            case 2:
                zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
                imm = bits(machInst, 20, 19);
                return new SveFcmlai<uint16_t>(machInst,
                        zda, zn, zm, rot, imm);
            case 3:
                zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
                imm = bits(machInst, 20);
                return new SveFcmlai<uint32_t>(machInst,
                        zda, zn, zm, rot, imm);
        }
        return new Unknown64(machInst);
    } // decodeSveFpCplxMulAddIndexed

    StaticInstPtr
    decodeSveFpMulIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t size = bits(machInst, 23, 22);
        switch (size) {
          case 0x0:
          case 0x1:
            return new SveFmulIdx<uint16_t>(
                machInst, zd, zn,
                (RegIndex) (uint8_t) bits(machInst, 18, 16),
                bits(machInst, 20, 19) | (bits(machInst, 22) << 2));
          case 0x2:
            return new SveFmulIdx<uint32_t>(
                machInst, zd, zn,
                (RegIndex) (uint8_t) bits(machInst, 18, 16),
                bits(machInst, 20, 19));
          case 0x3:
            return new SveFmulIdx<uint64_t>(
                machInst, zd, zn,
                (RegIndex) (uint8_t) bits(machInst, 19, 16),
                bits(machInst, 20));
          default:
            return new Unknown64(machInst);
        }

    } // decodeSveFpMulIndexed

    StaticInstPtr
    decodeSveFpMulAddIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        const uint8_t op = bits(machInst, 10);

        uint8_t size = bits(machInst, 23, 22);
        switch (size) {
          case 0x0:
          case 0x1:
            if (op) {
                return new SveFmlsIdx<uint16_t>(
                    machInst, zd, zn,
                    (RegIndex) (uint8_t) bits(machInst, 18, 16),
                    bits(machInst, 20, 19) | (bits(machInst, 22) << 2));
            } else {
                return new SveFmlaIdx<uint16_t>(
                    machInst, zd, zn,
                    (RegIndex) (uint8_t) bits(machInst, 18, 16),
                    bits(machInst, 20, 19) | (bits(machInst, 22) << 2));
            }
          case 0x2:
            if (op) {
                return new SveFmlsIdx<uint32_t>(
                    machInst, zd, zn,
                    (RegIndex) (uint8_t) bits(machInst, 18, 16),
                    bits(machInst, 20, 19));
            } else {
                return new SveFmlaIdx<uint32_t>(
                    machInst, zd, zn,
                    (RegIndex) (uint8_t) bits(machInst, 18, 16),
                    bits(machInst, 20, 19));
            }
          case 0x3:
            if (op) {
                return new SveFmlsIdx<uint64_t>(
                    machInst, zd, zn,
                    (RegIndex) (uint8_t) bits(machInst, 19, 16),
                    bits(machInst, 20));
            } else {
                return new SveFmlaIdx<uint64_t>(
                    machInst, zd, zn,
                    (RegIndex) (uint8_t) bits(machInst, 19, 16),
                    bits(machInst, 20));
            }
          default:
              return new Unknown64(machInst);
        }
    } // decodeSveFpMulAddIndexed

    StaticInstPtr
    decodeSveMemGather32(ExtMachInst machInst)
    {
        if (bits(machInst, 15)) {
            if (bits(machInst, 22)) {
                // SVE load and broadcast element
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rn = makeSP(
                        (RegIndex) (uint8_t) bits(machInst, 9, 5));
                uint64_t imm = bits(machInst, 21, 16);
                RegIndex pg = (RegIndex) (uint8_t)
                                 bits(machInst, 12, 10);
                uint8_t dtype = (bits(machInst, 24, 23) << 2) |
                                bits(machInst, 14, 13);
                return decodeSveContigLoadSIInsts<SveLoadAndRepl>(
                        dtype, machInst, zt, pg, rn, imm, false, true);
            } else {
                if (bits(machInst, 21)) {
                    // SVE 32-bit gather load (vector plus immediate)
                    RegIndex zt = (RegIndex) (uint8_t)
                                     bits(machInst, 4, 0);
                    RegIndex zn = (RegIndex) (uint8_t)
                                     bits(machInst, 9, 5);
                    uint64_t imm = bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)
                                     bits(machInst, 12, 10);
                    uint8_t dtype = (bits(machInst, 24, 23) << 1) |
                                    bits(machInst, 14);
                    uint8_t ff = bits(machInst, 13);
                    return decodeSveGatherLoadVIInsts(
                        dtype, machInst, zt, pg, zn, imm, true, ff);
                } else {
                    uint8_t b14_13 = bits(machInst, 14, 13);
                    if (b14_13 == 0x2 && bits(machInst, 4) == 0) {
                        // TODO: SVE contiguous prefetch (scalar plus scalar)
                        return new WarnUnimplemented("prf[bhwd]", machInst);
                    } else if (b14_13 == 0x3 && bits(machInst, 4) == 0) {
                        // TODO: SVE 32-bit gather prefetch (vector plus
                        // immediate)
                        return new WarnUnimplemented("prf[bhwd]", machInst);
                    }
                }
            }
        } else {
            uint8_t b24_23 = bits(machInst, 24, 23);
            if (b24_23 != 0x3 && bits(machInst, 21) == 0) {
                // SVE 32-bit gather load (scalar plus 32-bit unscaled offsets)
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rn = makeSP(
                        (RegIndex) (uint8_t) bits(machInst, 9, 5));
                RegIndex zm = (RegIndex) (uint8_t)
                         bits(machInst, 20, 16);
                RegIndex pg = (RegIndex) (uint8_t)
                         bits(machInst, 12, 10);
                uint8_t dtype = (bits(machInst, 24, 23) << 1) |
                                bits(machInst, 14);
                uint8_t xs = bits(machInst, 22);
                uint8_t ff = bits(machInst, 13);
                return decodeSveGatherLoadSVInsts(
                        dtype, machInst, zt, pg, rn, zm,
                        true, true, xs, false, ff);
            }
            switch (b24_23) {
              case 0x0:
                if (bits(machInst, 21) && bits(machInst, 4) == 0) {
                    // TODO: SVE 32-bit gather prefetch (vector plus immediate)
                    return new WarnUnimplemented("prf[bhwd]", machInst);
                }
                break;
              case 0x1:
                if (bits(machInst, 21)) {
                    // SVE 32-bit gather load halfwords (scalar plus 32-bit
                    // scaled offsets)
                    RegIndex zt = (RegIndex) (uint8_t)
                             bits(machInst, 4, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    RegIndex zm = (RegIndex) (uint8_t)
                             bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)
                             bits(machInst, 12, 10);
                    uint8_t xs = bits(machInst, 22);
                    uint8_t ff = bits(machInst, 13);
                    if (bits(machInst, 14)) {
                        return
                           new SveIndexedMemSV<uint32_t, uint16_t,
                                               SveGatherLoadSVMicroop,
                                               SveFirstFaultWritebackMicroop>(
                            ff ? "ldff1" : "ld1", machInst, MemReadOp, zt, pg,
                            rn, zm, true, xs, true, ff);
                    } else {
                        return
                           new SveIndexedMemSV<int32_t, int16_t,
                                               SveGatherLoadSVMicroop,
                                               SveFirstFaultWritebackMicroop>(
                            ff ? "ldff1" : "ld1", machInst, MemReadOp, zt, pg,
                            rn, zm, true, xs, true, ff);
                    }
                }
                break;
              case 0x2:
                if (bits(machInst, 21)) {
                    // SVE 32-bit gather load words (scalar plus 32-bit scaled
                    // offsets)
                    RegIndex zt = (RegIndex) (uint8_t)
                             bits(machInst, 4, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    RegIndex zm = (RegIndex) (uint8_t)
                             bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)
                             bits(machInst, 12, 10);
                    uint8_t xs = bits(machInst, 22);
                    uint8_t ff = bits(machInst, 13);
                    return new SveIndexedMemSV<uint32_t, uint32_t,
                                               SveGatherLoadSVMicroop,
                                               SveFirstFaultWritebackMicroop>(
                        ff ? "ldff1" : "ld1", machInst, MemReadOp, zt, pg, rn,
                        zm, true, xs, true, ff);
                }
                break;
              case 0x3:
                if (bits(machInst, 22) == 0 && bits(machInst, 14, 13) == 0x0 &&
                        bits(machInst, 4) == 0) {
                    // SVE load predicate register
                    RegIndex pt = (RegIndex) (uint8_t)
                        bits(machInst, 3, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    uint64_t imm = sext<9>((bits(machInst, 21, 16) << 3) |
                                           bits(machInst, 12, 10));
                    return new SveLdrPred(machInst, pt, rn, imm);
                } else if (bits(machInst, 22) == 0 &&
                           bits(machInst, 14, 13) == 0x2) {
                    // SVE load vector register
                    RegIndex zt = (RegIndex) (uint8_t)
                        bits(machInst, 4, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    uint64_t imm = sext<9>((bits(machInst, 21, 16) << 3) |
                                           bits(machInst, 12, 10));
                    return new SveLdrVec(machInst, zt, rn, imm);
                } else if (bits(machInst, 22) == 1 &&
                           bits(machInst, 4) == 0) {
                    // TODO: SVE contiguous prefetch (scalar plus immediate)
                    return new WarnUnimplemented("prf[bhwd]", machInst);
                }
                break;
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveMemGather32

    StaticInstPtr
    decodeSveLoadBcastQuadSS(ExtMachInst machInst)
    {
        uint8_t num = bits(machInst, 22, 21);
        if (num != 0x00) {
            return new Unknown64(machInst);
        }

        RegIndex zt = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex)(uint8_t) bits(machInst, 9, 5));
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex rm = (RegIndex)(uint8_t) bits(machInst, 20, 16);
        uint8_t msz = bits(machInst, 24, 23);
        switch (msz) {
            case 0:
                return new SveLd1RqSS<uint8_t, uint8_t>("ld1rqb",
                        machInst, zt, pg, rn, rm);
            case 1:
                return new SveLd1RqSS<uint16_t, uint16_t>("ld1rqh",
                        machInst, zt, pg, rn, rm);
            case 2:
                return new SveLd1RqSS<uint32_t, uint32_t>("ld1rqw",
                        machInst, zt, pg, rn, rm);
            case 3:
                return new SveLd1RqSS<uint64_t, uint64_t>("ld1rqd",
                        machInst, zt, pg, rn, rm);
        }

        return new Unknown64(machInst);
    }  // decodeSveLoadBcastQuadSS

    StaticInstPtr
    decodeSveLoadBcastQuadSI(ExtMachInst machInst)
    {
        uint8_t num = bits(machInst, 22, 21);
        if (num != 0x00) {
            return new Unknown64(machInst);
        }

        RegIndex zt = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex)(uint8_t) bits(machInst, 9, 5));
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        uint64_t imm = sext<4>(bits(machInst, 19, 16));
        uint8_t msz = bits(machInst, 24, 23);
        switch (msz) {
            case 0:
                return new SveLd1RqSI<uint8_t, uint8_t>("ld1rqb",
                        machInst, zt, pg, rn, imm);
            case 1:
                return new SveLd1RqSI<uint16_t, uint16_t>("ld1rqh",
                        machInst, zt, pg, rn, imm);
            case 2:
                return new SveLd1RqSI<uint32_t, uint32_t>("ld1rqw",
                        machInst, zt, pg, rn, imm);
            case 3:
                return new SveLd1RqSI<uint64_t, uint64_t>("ld1rqd",
                        machInst, zt, pg, rn, imm);
        }

        return new Unknown64(machInst);
    }  // decodeSveLoadBcastQuadSI

    StaticInstPtr
    decodeSveContigLoadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        if (rm == 0x1f) {
            return new Unknown64(machInst);
        }

        return decodeSveContigLoadSSInsts<SveContigLoadSS>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, rm, false);
    }  // decodeSveContigLoadSS

    StaticInstPtr
    decodeSveContigFFLoadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        return decodeSveContigLoadSSInsts<SveContigFFLoadSS>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, rm, true);
    }  // decodeSveContigFFLoadSS

    StaticInstPtr
    decodeSveContigLoadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        uint64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        return decodeSveContigLoadSIInsts<SveContigLoadSI>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, imm, false);
    }  // decodeSveContigLoadSI

    StaticInstPtr
    decodeSveContigNFLoadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        uint64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        return decodeSveContigLoadSIInsts<SveContigNFLoadSI>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, imm, true);
    }  // decodeSveContigNFLoadSI

    StaticInstPtr
    decodeSveContigNTLoadSS(ExtMachInst machInst)
    {
        return new Unknown64(machInst);
    }  // decodeSveContigNTLoadSS

    StaticInstPtr
    decodeSveLoadStructsSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP(
                (RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t num = bits(machInst, 22, 21);

        if (rm != 0x1f && num != 0) {
            num++;
            return decodeSveStructLoadSSInsts(msz, machInst,
                    zt, pg, rn, rm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveLoadStructsSS

    StaticInstPtr
    decodeSveContigNTLoadSI(ExtMachInst machInst)
    {
        return new Unknown64(machInst);
    }  // decodeSveContigNTLoadSI

    StaticInstPtr
    decodeSveLoadStructsSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP(
                (RegIndex) (uint8_t) bits(machInst, 9, 5));
        int64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t num = bits(machInst, 22, 21);

        if (num != 0) {
            num++;
            imm *= num;
            return decodeSveStructLoadSIInsts(msz, machInst,
                    zt, pg, rn, imm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveLoadStructsSI

    StaticInstPtr
    decodeSveMemContigLoad(ExtMachInst machInst)
    {
        switch (bits(machInst, 15, 13)) {
          case 0x0:
            return decodeSveLoadBcastQuadSS(machInst);
          case 0x1:
            if (bits(machInst, 20) == 0x0) {
                return decodeSveLoadBcastQuadSI(machInst);
            }
            break;
          case 0x2:
            return decodeSveContigLoadSS(machInst);
          case 0x3:
            return decodeSveContigFFLoadSS(machInst);
          case 0x5:
            if (bits(machInst, 20) == 0x0) {
                return decodeSveContigLoadSI(machInst);
            } else {
                return decodeSveContigNFLoadSI(machInst);
            }
          case 0x6:
            if (bits(machInst, 22, 21) == 0x0) {
                return decodeSveContigNTLoadSS(machInst);
            } else {
                return decodeSveLoadStructsSS(machInst);
            }
          case 0x7:
            if (bits(machInst, 20) == 0) {
                if (bits(machInst, 22, 21) == 0x0) {
                    return decodeSveContigNTLoadSI(machInst);
                } else {
                return decodeSveLoadStructsSI(machInst);
                }
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveMemContigLoad

    StaticInstPtr
    decodeSveMemGather64(ExtMachInst machInst)
    {
        switch ((bits(machInst, 21) << 1) | bits(machInst, 15)) {
          case 0x0:
            {
                // SVE 64-bit gather load (scalar plus unpacked 32-bit unscaled
                // offsets)
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rn = makeSP(
                        (RegIndex) (uint8_t) bits(machInst, 9, 5));
                RegIndex zm = (RegIndex) (uint8_t)
                         bits(machInst, 20, 16);
                RegIndex pg = (RegIndex) (uint8_t)
                         bits(machInst, 12, 10);
                uint8_t dtype = (bits(machInst, 24, 23) << 1) |
                                bits(machInst, 14);
                uint8_t xs = bits(machInst, 22);
                uint8_t ff = bits(machInst, 13);
                return decodeSveGatherLoadSVInsts(
                        dtype, machInst, zt, pg, rn, zm,
                        false, true, xs, false, ff);
            }
          case 0x1:
            if (bits(machInst, 22)) {
                // SVE 64-bit gather load (scalar plus 64-bit unscaled offsets)
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rn = makeSP(
                        (RegIndex) (uint8_t) bits(machInst, 9, 5));
                RegIndex zm = (RegIndex) (uint8_t)
                         bits(machInst, 20, 16);
                RegIndex pg = (RegIndex) (uint8_t)
                         bits(machInst, 12, 10);
                uint8_t dtype = (bits(machInst, 24, 23) << 1) |
                                bits(machInst, 14);
                uint8_t ff = bits(machInst, 13);
                return decodeSveGatherLoadSVInsts(
                        dtype, machInst, zt, pg, rn, zm,
                        false, false, false, false, ff);
            } else {
                if (bits(machInst, 14, 13) == 0x3 && bits(machInst, 4) == 0) {
                    // TODO: SVE 64-bit gather prefetch (vector plus immediate)
                    return new WarnUnimplemented("prf[bhwd]", machInst);
                }
            }
            break;
          case 0x2:
            if (bits(machInst, 24, 23) != 0x0) {
                //  SVE 64-bit gather load (scalar plus unpacked 32-bit scaled
                //  offsets)
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rn = makeSP(
                        (RegIndex) (uint8_t) bits(machInst, 9, 5));
                RegIndex zm = (RegIndex) (uint8_t)
                         bits(machInst, 20, 16);
                RegIndex pg = (RegIndex) (uint8_t)
                         bits(machInst, 12, 10);
                uint8_t dtype = (bits(machInst, 24, 23) << 1) |
                                bits(machInst, 14);
                uint8_t xs = bits(machInst, 22);
                uint8_t ff = bits(machInst, 13);
                return decodeSveGatherLoadSVInsts(
                        dtype, machInst, zt, pg, rn, zm,
                        false, true, xs, true, ff);
            } else if (bits(machInst, 4) == 0) {
                // TODO: SVE 64-bit gather prefetch (scalar plus unpacked
                // 32-bit scaled offsets)
                return new WarnUnimplemented("prf[bhwd]", machInst);
            }
            break;
          case 0x3:
            if (bits(machInst, 22) == 0) {
                // SVE 64-bit gather load (vector plus immediate)
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                uint64_t imm = bits(machInst, 20, 16);
                RegIndex pg = (RegIndex) (uint8_t)
                                 bits(machInst, 12, 10);
                uint8_t dtype = (bits(machInst, 24, 23) << 1) |
                                bits(machInst, 14);
                uint8_t ff = bits(machInst, 13);
                return decodeSveGatherLoadVIInsts(
                    dtype, machInst, zt, pg, zn, imm, false, ff);
            } else {
                if (bits(machInst, 24, 23) != 0x0) {
                    // SVE 64-bit gather load (scalar plus 64-bit scaled
                    // offsets)
                    RegIndex zt = (RegIndex) (uint8_t)
                             bits(machInst, 4, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    RegIndex zm = (RegIndex) (uint8_t)
                             bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)
                             bits(machInst, 12, 10);
                    uint8_t dtype = (bits(machInst, 24, 23) << 1) |
                                    bits(machInst, 14);
                    uint8_t ff = bits(machInst, 13);
                    return decodeSveGatherLoadSVInsts(
                            dtype, machInst, zt, pg, rn, zm,
                            false, false, false, true, ff);
                } else if (bits(machInst, 4) == 0) {
                    // TODO: SVE 64-bit gather prefetch (scalar plus 64-bit
                    // scaled offsets)
                    return new WarnUnimplemented("prf[bhwd]", machInst);
                }
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveMemGather64

    StaticInstPtr
    decodeSveContigStoreSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        if (rm == 0x1f) {
            return new Unknown64(machInst);
        }

        return decodeSveContigStoreSSInsts<SveContigStoreSS>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, rm);
    }  // decodeSveContigStoreSS

    StaticInstPtr
    decodeSveContigStoreSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        int8_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        return decodeSveContigStoreSIInsts<SveContigStoreSI>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, imm);
    }  // decodeSveContigStoreSI

    StaticInstPtr
    decodeSveContigNTStoreSS(ExtMachInst machInst)
    {
        return new Unknown64(machInst);
    }  // decodeSveContigNTStoreSS

    StaticInstPtr
    decodeSveContigNTStoreSI(ExtMachInst machInst)
    {
        return new Unknown64(machInst);
    }  // decodeSveContigNTStoreSI

    StaticInstPtr
    decodeSveStoreStructsSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP(
                (RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t num = bits(machInst, 22, 21);

        if (rm != 0x1f && num != 0) {
            num++;
            return decodeSveStructStoreSSInsts(msz, machInst,
                    zt, pg, rn, rm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveStoreStructsSS

    StaticInstPtr
    decodeSveStoreStructsSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP(
                (RegIndex) (uint8_t) bits(machInst, 9, 5));
        int64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t num = bits(machInst, 22, 21);

        if (num != 0) {
            num++;
            imm *= num;
            return decodeSveStructStoreSIInsts(msz, machInst,
                    zt, pg, rn, imm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveStoreStructsSI

    StaticInstPtr
    decodeSveMemStore(ExtMachInst machInst)
    {
        switch (bits(machInst, 15, 13)) {
          case 0x0:
            if (bits(machInst, 24, 22) == 0x6 && bits(machInst, 4) == 0x0) {
                RegIndex pt = (RegIndex) (uint8_t) bits(machInst, 3, 0);
                RegIndex rn = makeSP(
                    (RegIndex) (uint8_t) bits(machInst, 9, 5));
                int16_t imm = sext<9>((bits(machInst, 21, 16) << 3) |
                                      bits(machInst, 12, 10));
                return new SveStrPred(machInst, pt, rn, imm);
            }
            break;
          case 0x2:
            if (bits(machInst, 24, 22) == 0x6) {
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rn = makeSP(
                    (RegIndex) (uint8_t) bits(machInst, 9, 5));
                int16_t imm = sext<9>((bits(machInst, 21, 16) << 3) |
                                      bits(machInst, 12, 10));
                return new SveStrVec(machInst, zt, rn, imm);
            } else {
                return decodeSveContigStoreSS(machInst);
            }
            break;
          case 0x3:
            if (bits(machInst, 22, 21) == 0x0) {
                return decodeSveContigNTStoreSS(machInst);
            } else {
                return decodeSveStoreStructsSS(machInst);
            }
          case 0x4:
          case 0x6:
            {
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rn = makeSP(
                        (RegIndex) (uint8_t) bits(machInst, 9, 5));
                RegIndex zm = (RegIndex) (uint8_t)
                         bits(machInst, 20, 16);
                RegIndex pg = (RegIndex) (uint8_t)
                         bits(machInst, 12, 10);
                uint8_t msz = bits(machInst, 24, 23);
                uint8_t xs = bits(machInst, 22);

                switch (bits(machInst, 22, 21)) {
                  case 0x0:
                    // SVE 64-bit scatter store (scalar plus unpacked 32-bit
                    // unscaled offsets)
                    return decodeSveScatterStoreSVInsts(
                            msz, machInst, zt, pg, rn, zm,
                            false, true, xs, false);
                  case 0x1:
                    if (bits(machInst, 24, 23) != 0x0) {
                        // SVE 64-bit scatter store (scalar plus unpacked
                        // 32-bit scaled offsets)
                        return decodeSveScatterStoreSVInsts(
                                msz, machInst, zt, pg, rn, zm,
                                false, true, xs, true);
                    }
                    break;
                  case 0x2:
                    if (bits(machInst, 24, 23) != 0x3) {
                        // SVE 32-bit scatter store (scalar plus 32-bit
                        // unscaled offsets)
                        return decodeSveScatterStoreSVInsts(
                                msz, machInst, zt, pg, rn, zm,
                                true, true, xs, false);
                    }
                    break;
                  case 0x3:
                    // SVE 32-bit scatter store (scalar plus 32-bit scaled
                    // offsets)
                    return decodeSveScatterStoreSVInsts(
                            msz, machInst, zt, pg, rn, zm,
                            true, true, xs, true);
                }
            }
            break;
          case 0x5:
            switch (bits(machInst, 22, 21)) {
              case 0x0:
                {
                    // SVE 64-bit scatter store (scalar plus 64-bit unscaled
                    // offsets)
                    RegIndex zt = (RegIndex) (uint8_t)
                            bits(machInst, 4, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    RegIndex zm = (RegIndex) (uint8_t)
                            bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)
                            bits(machInst, 12, 10);
                    uint8_t msz = bits(machInst, 24, 23);

                    return decodeSveScatterStoreSVInsts(
                            msz, machInst, zt, pg, rn, zm,
                            false, false, false, false);
                }
              case 0x1:
                if (bits(machInst, 24, 23) != 0x0) {
                    // SVE 64-bit scatter store (scalar plus 64-bit scaled
                    // offsets)
                    RegIndex zt = (RegIndex) (uint8_t)
                            bits(machInst, 4, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    RegIndex zm = (RegIndex) (uint8_t)
                            bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)
                            bits(machInst, 12, 10);
                    uint8_t msz = bits(machInst, 24, 23);

                    return decodeSveScatterStoreSVInsts(
                            msz, machInst, zt, pg, rn, zm,
                            false, false, false, true);
                }
                break;
              case 0x2:
                {
                    // SVE 64-bit scatter store (vector plus immediate)
                    RegIndex zt = (RegIndex) (uint8_t)
                            bits(machInst, 4, 0);
                    RegIndex zn = (RegIndex) (uint8_t)
                            bits(machInst, 9, 5);
                    uint64_t imm = bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)
                            bits(machInst, 12, 10);
                    uint8_t msz = bits(machInst, 24, 23);

                    return decodeSveScatterStoreVIInsts(
                        msz, machInst, zt, pg, zn, imm, false);
                }
              case 0x3:
                if (bits(machInst, 24, 23) != 0x3) {
                    // SVE 32-bit scatter store (vector plus immediate)
                    RegIndex zt = (RegIndex) (uint8_t)
                            bits(machInst, 4, 0);
                    RegIndex zn = (RegIndex) (uint8_t)
                            bits(machInst, 9, 5);
                    uint64_t imm = bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)
                            bits(machInst, 12, 10);
                    uint8_t msz = bits(machInst, 24, 23);

                    return decodeSveScatterStoreVIInsts(
                        msz, machInst, zt, pg, zn, imm, true);
                }
                break;
            }
            break;
          case 0x7:
            if (bits(machInst, 20) == 0x0) {
                return decodeSveContigStoreSI(machInst);
            } else if (bits(machInst, 22, 21) == 0x0) {
                return decodeSveContigNTStoreSI(machInst);
            } else {
                return decodeSveStoreStructsSI(machInst);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveMemStore

}  // namespace Aarch64

    StaticInstPtr
    decodeNeonMem(ExtMachInst machInst)
    {
        const uint32_t b = bits(machInst, 11, 8);
        const bool single = bits(machInst, 23);
        const bool singleAll = single && (bits(b, 3, 2) == 3);
        const bool load = bits(machInst, 21);
        unsigned width = 0;
        if (single) {
            width = bits(b, 1, 0) + 1;
        } else {
            switch (bits(b, 3, 1)) {
              case 0x0: width = 4;
                break;
              case 0x1: width = (b & 0x1) ? 2 : 1;
                break;
              case 0x2: width = 3;
                break;
              case 0x3: width = 1;
                break;
              case 0x4: width = 2;
                break;
              case 0x5:
                if ((b & 0x1) == 0) {
                    width = 1;
                    break;
                }
                [[fallthrough]];
              default:
                return new Unknown(machInst);
            }
        }
        assert(width > 0 && width <= 4);
        const RegIndex rm = (RegIndex)(uint32_t)bits(machInst, 3, 0);
        const RegIndex rn = (RegIndex)(uint32_t)bits(machInst, 19, 16);
        const RegIndex vd = (RegIndex)(uint32_t)(bits(machInst, 15, 12) |
                                                 bits(machInst, 22) << 4);
        const uint32_t type = bits(machInst, 11, 8);
        uint32_t size = 0;
        uint32_t align = 0;
        unsigned inc = 1;
        unsigned regs = 1;
        unsigned lane = 0;
        if (single) {
            if (singleAll) {
                size = bits(machInst, 7, 6);
                bool t = bits(machInst, 5);
                align = size | MMU::AllowUnaligned;
                if (width == 1) {
                    regs = t ? 2 : 1;
                    inc = 1;
                } else {
                    regs = width;
                    inc = t ? 2 : 1;
                }
                switch (width) {
                  case 1:
                  case 2:
                    if (bits(machInst, 4))
                        align = size + width - 1;
                    break;
                  case 3:
                    break;
                  case 4:
                    if (size == 3) {
                        if (bits(machInst, 4) == 0)
                            return new Unknown(machInst);
                        size = 2;
                        align = 0x4;
                    } else if (size == 2) {
                        if (bits(machInst, 4))
                            align = 0x3;
                    } else {
                        if (bits(machInst, 4))
                            align = size + 2;
                    }
                    break;
                }
            } else {
                size = bits(machInst, 11, 10);
                align = size | MMU::AllowUnaligned;
                regs = width;
                unsigned indexAlign = bits(machInst, 7, 4);
                // If width is 1, inc is always 1. That's overridden later.
                switch (size) {
                  case 0:
                    inc = 1;
                    lane = bits(indexAlign, 3, 1);
                    break;
                  case 1:
                    inc = bits(indexAlign, 1) ? 2 : 1;
                    lane = bits(indexAlign, 3, 2);
                    break;
                  case 2:
                    inc = bits(indexAlign, 2) ? 2 : 1;
                    lane = bits(indexAlign, 3);
                    break;
                }
                // Override inc for width of 1.
                if (width == 1) {
                    inc = 1;
                }
                switch (width) {
                  case 1:
                    switch (size) {
                      case 0:
                        break;
                      case 1:
                        if (bits(indexAlign, 0))
                            align = 1;
                        break;
                      case 2:
                        if (bits(indexAlign, 1, 0))
                            align = 2;
                        break;
                    }
                    break;
                  case 2:
                    if (bits(indexAlign, 0))
                        align = size + 1;
                    break;
                  case 3:
                    break;
                  case 4:
                    switch (size) {
                      case 0:
                      case 1:
                        if (bits(indexAlign, 0))
                            align = size + 2;
                        break;
                      case 2:
                        if (bits(indexAlign, 0))
                            align = bits(indexAlign, 1, 0) + 2;
                        break;
                    }
                    break;
                }
            }
            if (size == 0x3) {
                return new Unknown(machInst);
            }
        } else {
            size = bits(machInst, 7, 6);
            align = bits(machInst, 5, 4);
            if (align == 0) {
                // @align wasn't specified, so alignment can be turned off.
                align = size | MMU::AllowUnaligned;
            } else {
                align = align + 2;
            }
            switch (width) {
              case 1:
                switch (type) {
                  case 0x7: regs = 1;
                    break;
                  case 0xa: regs = 2;
                    break;
                  case 0x6: regs = 3;
                    break;
                  case 0x2: regs = 4;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 2:
                // Regs doesn't behave exactly as it does in the manual
                // because they loop over regs registers twice and we break
                // it down in the macroop.
                switch (type) {
                  case 0x8: regs = 2; inc = 1;
                    break;
                  case 0x9: regs = 2; inc = 2;
                    break;
                  case 0x3: regs = 4; inc = 2;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 3:
                regs = 3;
                switch (type) {
                  case 0x4: inc = 1;
                    break;
                  case 0x5: inc = 2;;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 4:
                regs = 4;
                switch (type) {
                  case 0: inc = 1;
                    break;
                  case 1: inc = 2;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
            }
        }
        if (load) {
            // Load instructions.
            if (single) {
                return new VldSingle(machInst, singleAll, width, rn, vd,
                                     regs, inc, size, align, rm, lane);
            } else {
                return new VldMult(machInst, width, rn, vd,
                                   regs, inc, size, align, rm);
            }
        } else {
            // Store instructions.
            if (single) {
                if (singleAll) {
                    return new Unknown(machInst);
                } else {
                    return new VstSingle(machInst, false, width, rn, vd,
                                         regs, inc, size, align, rm, lane);
                }
            } else {
                return new VstMult(machInst, width, rn, vd,
                                   regs, inc, size, align, rm);
            }
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeAdvancedSIMD(ExtMachInst machInst)
    {
        uint8_t op_code = (bits(machInst, 25) << 1)
                          | bits(machInst, 21);
        RegIndex vd = (RegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        RegIndex vn = (RegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        RegIndex vm = (RegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        bool q = bits (machInst, 6);
        switch (op_code) {
          case 0x0:
          {
            // VCADD
            bool s = bits (machInst, 20);
            if (s) {
               if (q)
                   return new VcaddQ<uint32_t>(machInst, vd, vn, vm);
               else
                   return new VcaddD<uint32_t>(machInst, vd, vn, vm);
            } else {
               if (q)
                   return new VcaddQ<uint16_t>(machInst, vd, vn, vm);
               else
                   return new VcaddD<uint16_t>(machInst, vd, vn, vm);
            }
          }
          case 0x1:
          {
            // VCMLA
            bool s = bits (machInst, 20);
            if (s) {
               if (q)
                   return new VcmlaQ<uint32_t>(machInst, vd, vn, vm);
               else
                   return new VcmlaD<uint32_t>(machInst, vd, vn, vm);
            } else {
               if (q)
                   return new VcmlaQ<uint16_t>(machInst, vd, vn, vm);
               else
                   return new VcmlaD<uint16_t>(machInst, vd, vn, vm);
            }
          }
          case 0x2:
          case 0x3:
          {
            // VCMLA by element
            bool s = bits (machInst, 23);
            if (s) {
               uint8_t index_fp = 0;
               if (q)
                   return new VcmlaElemQ<uint32_t>(machInst, vd, vn, vm,
                                                   index_fp);
               else
                   return new VcmlaElemD<uint32_t>(machInst, vd, vn, vm,
                                                   index_fp);
            } else {
               vm = (RegIndex)(uint8_t)(2* bits(machInst, 3, 0));
               uint8_t index_fp = bits(machInst, 5);
               if (q)
                   return new VcmlaElemQ<uint16_t>(machInst, vd, vn, vm,
                                                   index_fp);
               else
                   return new VcmlaElemD<uint16_t>(machInst, vd, vn, vm,
                                                   index_fp);
            }
          }
          default:
            return new Unknown64(machInst);
        }
    }
    
    static StaticInstPtr
    decodeNeonThreeRegistersSameLength(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t opc = bits(machInst, 11, 8);
        const bool o1 = bits(machInst, 4);
        const uint32_t size = bits(machInst, 21, 20);
        const RegIndex vd =
            (RegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const RegIndex vn =
            (RegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const RegIndex vm =
            (RegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const bool q = bits(machInst, 6);
        if (q && ((vd & 0x1) || (vn & 0x1) || (vm & 0x1)))
            return new Unknown(machInst);
        switch (opc) {
          case 0x0:
            if (o1) {
                if (u) {
                    return decodeNeonUThreeReg<VqaddUD, VqaddUQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<VqaddSD, VqaddSQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (size == 3)
                    return new Unknown(machInst);
                return decodeNeonUSThreeReg<VhaddD, VhaddQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x1:
            if (!o1) {
                return decodeNeonUSThreeReg<VrhaddD, VrhaddQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                if (u) {
                    switch (size) {
                      case 0:
                        if (q) {
                            return new VeorQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VeorD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 1:
                        if (q) {
                            return new VbslQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbslD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 2:
                        if (q) {
                            return new VbitQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbitD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 3:
                        if (q) {
                            return new VbifQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbifD<uint64_t>(machInst, vd, vn, vm);
                        }
                      default:
                        GEM5_UNREACHABLE;
                    }
                } else {
                    switch (size) {
                      case 0:
                        if (q) {
                            return new VandQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VandD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 1:
                        if (q) {
                            return new VbicQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbicD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 2:
                        if (vn == vm) {
                            if (q) {
                                return new VmovQ<uint64_t>(
                                        machInst, vd, vn, vm);
                            } else {
                                return new VmovD<uint64_t>(
                                        machInst, vd, vn, vm);
                            }
                        } else {
                            if (q) {
                                return new VorrQ<uint64_t>(
                                        machInst, vd, vn, vm);
                            } else {
                                return new VorrD<uint64_t>(
                                        machInst, vd, vn, vm);
                            }
                        }
                      case 3:
                        if (q) {
                            return new VornQ<uint64_t>(
                                    machInst, vd, vn, vm);
                        } else {
                            return new VornD<uint64_t>(
                                    machInst, vd, vn, vm);
                        }
                      default:
                        GEM5_UNREACHABLE;
                    }
                }
            }
          case 0x2:
            if (o1) {
                if (u) {
                    return decodeNeonUThreeReg<VqsubUD, VqsubUQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<VqsubSD, VqsubSQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (size == 3)
                    return new Unknown(machInst);
                return decodeNeonUSThreeReg<VhsubD, VhsubQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x3:
            if (o1) {
                return decodeNeonUSThreeReg<VcgeD, VcgeQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VcgtD, VcgtQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x4:
            if (o1) {
                if (u) {
                    return decodeNeonUThreeReg<VqshlUD, VqshlUQ>(
                            q, size, machInst, vd, vm, vn);
                } else {
                    return decodeNeonSThreeReg<VqshlSD, VqshlSQ>(
                            q, size, machInst, vd, vm, vn);
                }
            } else {
                return decodeNeonUSThreeReg<VshlD, VshlQ>(
                        q, u, size, machInst, vd, vm, vn);
            }
          case 0x5:
            if (o1) {
                if (u) {
                    return decodeNeonUThreeReg<VqrshlUD, VqrshlUQ>(
                            q, size, machInst, vd, vm, vn);
                } else {
                    return decodeNeonSThreeReg<VqrshlSD, VqrshlSQ>(
                            q, size, machInst, vd, vm, vn);
                }
            } else {
                return decodeNeonUSThreeReg<VrshlD, VrshlQ>(
                        q, u, size, machInst, vd, vm, vn);
            }
          case 0x6:
            if (o1) {
                return decodeNeonUSThreeReg<VminD, VminQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VmaxD, VmaxQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x7:
            if (o1) {
                return decodeNeonUSThreeReg<VabaD, VabaQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                if (bits(machInst, 23) == 1) {
                    if (q) {
                        return new Unknown(machInst);
                    } else {
                        return decodeNeonUSThreeUSReg<Vabdl>(
                                u, size, machInst, vd, vn, vm);
                    }
                } else {
                    return decodeNeonUSThreeReg<VabdD, VabdQ>(
                            q, u, size, machInst, vd, vn, vm);
                }
            }
          case 0x8:
            if (o1) {
                if (u) {
                    return decodeNeonUThreeReg<VceqD, VceqQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUThreeReg<VtstD, VtstQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonUThreeReg<NVsubD, NVsubQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUThreeReg<NVaddD, NVaddQ>(
                            q, size, machInst, vd, vn, vm);
                }
            }
          case 0x9:
            if (o1) {
                if (u) {
                    return decodeNeonUThreeReg<NVmulpD, NVmulpQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<NVmulD, NVmulQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonUSThreeReg<NVmlsD, NVmlsQ>(
                            q, u, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUSThreeReg<NVmlaD, NVmlaQ>(
                            q, u, size, machInst, vd, vn, vm);
                }
            }
          case 0xa:
            if (q)
                return new Unknown(machInst);
            if (o1) {
                return decodeNeonUSThreeUSReg<VpminD>(
                        u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeUSReg<VpmaxD>(
                        u, size, machInst, vd, vn, vm);
            }
          case 0xb:
            if (o1) {
                if (u) {
                    return decodeNeonSThreeSReg<VqrdmlahD, VqrdmlahQ>(
                            q, size, machInst, vd, vn, vm);
                } else if (q) {
                    return new Unknown(machInst);
                } else {
                    return decodeNeonUThreeUSReg<NVpaddD>(
                            size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonSThreeSReg<VqrdmulhD, VqrdmulhQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeSReg<VqdmulhD, VqdmulhQ>(
                            q, size, machInst, vd, vn, vm);
                }
            }
          case 0xc:
            if (o1) {
                if (u) {
                    return decodeNeonSThreeSReg<VqrdmlshD, VqrdmlshQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new NVfmaQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVfmaDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new NVfmsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVfmsDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            } else {
                if (u) {
                    switch (size) {
                      case 0x0:
                        return new SHA256H(machInst, vd, vn, vm);
                      case 0x1:
                        return new SHA256H2(machInst, vd, vn, vm);
                      case 0x2:
                        return new SHA256SU1(machInst, vd, vn, vm);
                      case 0x3:
                        return new Unknown(machInst);
                      default:
                        GEM5_UNREACHABLE;
                    }
                } else {
                    switch (size) {
                      case 0x0:
                        return new SHA1C(machInst, vd, vn, vm);
                      case 0x1:
                        return new SHA1P(machInst, vd, vn, vm);
                      case 0x2:
                        return new SHA1M(machInst, vd, vn, vm);
                      case 0x3:
                        return new SHA1SU0(machInst, vd, vn, vm);
                      default:
                        GEM5_UNREACHABLE;
                    }
                }
            }
            return new Unknown(machInst);
          case 0xd:
            if (o1) {
                if (u) {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new NVmulQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmulDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        return new Unknown(machInst);
                    }
                } else {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new NVmlaQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmlaDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new NVmlsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmlsDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            } else {
                if (u) {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VpaddQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VpaddDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VabdQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VabdDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VaddQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VaddDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VsubQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VsubDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            }
          case 0xe:
            if (o1) {
                if (u) {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VacgeQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VacgeDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VacgtQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VacgtDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    return new Unknown(machInst);
                }
            } else {
                if (u) {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VcgeQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VcgeDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VcgtQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VcgtDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VceqQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VceqDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        return new Unknown(machInst);
                    }
                }
            }
          case 0xf:
            if (o1) {
                if (u) {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VmaxnmQFp<uint32_t>(
                                machInst, vd, vn, vm);
                        } else {
                            return new VmaxnmDFp<uint32_t>(
                                machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VminnmQFp<uint32_t>(
                                machInst, vd, vn, vm);
                        } else {
                            return new VminnmDFp<uint32_t>(
                                machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VrecpsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VrecpsDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VrsqrtsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VrsqrtsDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            } else {
                if (u) {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VpmaxQFp<uint32_t>(
                                machInst, vd, vn, vm);
                        } else {
                            return new VpmaxDFp<uint32_t>(
                                machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VpminQFp<uint32_t>(
                                machInst, vd, vn, vm);
                        } else {
                            return new VpminDFp<uint32_t>(
                                machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(size, 1) == 0) {
                        if (q) {
                            return new VmaxQFp<uint32_t>(
                                machInst, vd, vn, vm);
                        } else {
                            return new VmaxDFp<uint32_t>(
                                machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VminQFp<uint32_t>(
                                machInst, vd, vn, vm);
                        } else {
                            return new VminDFp<uint32_t>(
                                machInst, vd, vn, vm);
                        }
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonOneRegModImm(ExtMachInst machInst)
    {
        const RegIndex vd =
            (RegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const bool q = bits(machInst, 6);
        const bool op = bits(machInst, 5);
        const uint8_t cmode = bits(machInst, 11, 8);
        const uint8_t imm = ((THUMB ? bits(machInst, 28) :
                                      bits(machInst, 24)) << 7) |
                            (bits(machInst, 18, 16) << 4) |
                            (bits(machInst, 3, 0) << 0);
        // Check for invalid immediate encodings and return an unknown op
        // if it happens
        bool immValid = true;
        const uint64_t bigImm = simd_modified_imm(op, cmode, imm, immValid);
        if (!immValid) {
            return new Unknown(machInst);
        }
        if (op) {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new NVbiciQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVbiciD<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    switch (bits(cmode, 1, 0)) {
                      case 0:
                      case 1:
                        if (q)
                            return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                      case 2:
                        if (q)
                            return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                      case 3:
                        if (q)
                            return new Unknown(machInst);
                        else
                            return new Unknown(machInst);
                    }
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new NVbiciQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVbiciD<uint64_t>(machInst, vd, bigImm);
                    }
                }
            }
        } else {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new NVorriQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVorriD<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    if (q)
                        return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new NVorriQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVorriD<uint64_t>(machInst, vd, bigImm);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegAndShift(ExtMachInst machInst)
    {
        const uint32_t opc = bits(machInst, 11, 8);
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const bool q = bits(machInst, 6);
        const bool l = bits(machInst, 7);
        const RegIndex vd =
            (RegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const RegIndex vm =
            (RegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        unsigned imm6 = bits(machInst, 21, 16);
        unsigned imm = ((l ? 1 : 0) << 6) | imm6;
        unsigned size = 3;
        unsigned lShiftAmt = 0;
        unsigned bitSel;
        for (bitSel = 1 << 6; true; bitSel >>= 1) {
            if (bitSel & imm)
                break;
            else if (!size)
                return new Unknown(machInst);
            size--;
        }
        lShiftAmt = imm6 & ~bitSel;
        unsigned rShiftAmt = 0;
        if (opc != 0xe && opc != 0xf) {
            if (size > 2)
                rShiftAmt = 64 - imm6;
            else
                rShiftAmt = 2 * (8 << size) - imm6;
        }
        switch (opc) {
          case 0x0:
            return decodeNeonUSTwoShiftReg<NVshrD, NVshrQ>(
                    q, u, size, machInst, vd, vm, rShiftAmt);
          case 0x1:
            return decodeNeonUSTwoShiftReg<NVsraD, NVsraQ>(
                    q, u, size, machInst, vd, vm, rShiftAmt);
          case 0x2:
            return decodeNeonUSTwoShiftReg<NVrshrD, NVrshrQ>(
                    q, u, size, machInst, vd, vm, rShiftAmt);
          case 0x3:
            return decodeNeonUSTwoShiftReg<NVrsraD, NVrsraQ>(
                    q, u, size, machInst, vd, vm, rShiftAmt);
          case 0x4:
            if (u) {
                return decodeNeonUTwoShiftReg<NVsriD, NVsriQ>(
                        q, size, machInst, vd, vm, rShiftAmt);
            } else {
                return new Unknown(machInst);
            }
          case 0x5:
            if (u) {
                return decodeNeonUTwoShiftReg<NVsliD, NVsliQ>(
                        q, size, machInst, vd, vm, lShiftAmt);
            } else {
                return decodeNeonUTwoShiftReg<NVshlD, NVshlQ>(
                        q, size, machInst, vd, vm, lShiftAmt);
            }
          case 0x6:
          case 0x7:
            if (u) {
                if (opc == 0x6) {
                    return decodeNeonSTwoShiftReg<NVqshlusD, NVqshlusQ>(
                            q, size, machInst, vd, vm, lShiftAmt);
                } else {
                    return decodeNeonUTwoShiftReg<NVqshluD, NVqshluQ>(
                            q, size, machInst, vd, vm, lShiftAmt);
                }
            } else {
                return decodeNeonSTwoShiftReg<NVqshlD, NVqshlQ>(
                        q, size, machInst, vd, vm, lShiftAmt);
            }
          case 0x8:
            if (l) {
                return new Unknown(machInst);
            } else if (u) {
                return decodeNeonSTwoShiftSReg<NVqshruns, NVqrshruns>(
                        q, size, machInst, vd, vm, rShiftAmt);
            } else {
                return decodeNeonUTwoShiftSReg<NVshrn, NVrshrn>(
                        q, size, machInst, vd, vm, rShiftAmt);
            }
          case 0x9:
            if (l) {
                return new Unknown(machInst);
            } else if (u) {
                return decodeNeonUTwoShiftSReg<NVqshrun, NVqrshrun>(
                        q, size, machInst, vd, vm, rShiftAmt);
            } else {
                return decodeNeonSTwoShiftSReg<NVqshrn, NVqrshrn>(
                        q, size, machInst, vd, vm, rShiftAmt);
            }
          case 0xa:
            if (l || q) {
                return new Unknown(machInst);
            } else {
                return decodeNeonUSTwoShiftSReg<NVmovl, NVshll>(
                        lShiftAmt, u, size, machInst, vd, vm, lShiftAmt);
            }
          case 0xe:
            if (l) {
                return new Unknown(machInst);
            } else {
                if (bits(imm6, 5) == 0)
                    return new Unknown(machInst);
                if (u) {
                    if (q) {
                        return new NVcvtu2fpQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvtu2fpD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                } else {
                    if (q) {
                        return new NVcvts2fpQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvts2fpD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                }
            }
          case 0xf:
            if (l) {
                return new Unknown(machInst);
            } else {
                if (bits(imm6, 5) == 0)
                    return new Unknown(machInst);
                if (u) {
                    if (q) {
                        return new NVcvt2ufxQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvt2ufxD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                } else {
                    if (q) {
                        return new NVcvt2sfxQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvt2sfxD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonThreeRegDiffLengths(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t opc = bits(machInst, 11, 8);
        const RegIndex vd =
            (RegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const RegIndex vn =
            (RegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const RegIndex vm =
            (RegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const unsigned size = bits(machInst, 21, 20);
        switch (opc) {
          case 0x0:
            return decodeNeonUSThreeUSReg<Vaddl>(
                    u, size, machInst, vd, vn, vm);
          case 0x1:
            return decodeNeonUSThreeUSReg<Vaddw>(
                    u, size, machInst, vd, vn, vm);
          case 0x2:
            return decodeNeonUSThreeUSReg<Vsubl>(
                    u, size, machInst, vd, vn, vm);
          case 0x3:
            return decodeNeonUSThreeUSReg<Vsubw>(
                    u, size, machInst, vd, vn, vm);
          case 0x4:
            if (u) {
                return decodeNeonUThreeUSReg<Vraddhn>(
                        size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUThreeUSReg<Vaddhn>(
                        size, machInst, vd, vn, vm);
            }
          case 0x5:
            return decodeNeonUSThreeUSReg<Vabal>(
                    u, size, machInst, vd, vn, vm);
          case 0x6:
            if (u) {
                return decodeNeonUThreeUSReg<Vrsubhn>(
                        size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUThreeUSReg<Vsubhn>(
                        size, machInst, vd, vn, vm);
            }
          case 0x7:
            if (bits(machInst, 23)) {
                return decodeNeonUSThreeUSReg<Vabdl>(
                        u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VabdD, VabdQ>(
                        bits(machInst, 6), u, size, machInst, vd, vn, vm);
            }
          case 0x8:
            return decodeNeonUSThreeUSReg<Vmlal>(
                    u, size, machInst, vd, vn, vm);
          case 0xa:
            return decodeNeonUSThreeUSReg<Vmlsl>(
                    u, size, machInst, vd, vn, vm);
          case 0x9:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmlal>(
                        size, machInst, vd, vn, vm);
            }
          case 0xb:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmlsl>(
                        size, machInst, vd, vn, vm);
            }
          case 0xc:
            return decodeNeonUSThreeUSReg<Vmull>(
                    u, size, machInst, vd, vn, vm);
          case 0xd:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmull>(
                        size, machInst, vd, vn, vm);
            }
          case 0xe:
            return decodeNeonUThreeUSReg<Vmullp>(
                    size, machInst, vd, vn, vm);
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegScalar(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t opc = bits(machInst, 11, 8);
        const unsigned size = bits(machInst, 21, 20);
        const RegIndex vd =
            (RegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const RegIndex vn =
            (RegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const RegIndex vm = (size == 2) ?
            (RegIndex)(2 * bits(machInst, 3, 0)) :
            (RegIndex)(2 * bits(machInst, 2, 0));
        const unsigned index = (size == 2) ? (unsigned)bits(machInst, 5) :
            (bits(machInst, 3) | (bits(machInst, 5) << 1));
        switch (opc) {
          case 0x0:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmlasQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlasQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmlasD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlasD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x1:
            if (u)
                return new VmlasQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmlasDFp<float>(machInst, vd, vn, vm, index);
          case 0x4:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmlssQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlssQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmlssD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlssD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x5:
            if (u)
                return new VmlssQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmlssDFp<float>(machInst, vd, vn, vm, index);
          case 0x2:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmlals<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlals<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmlals<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlals<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x6:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmlsls<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlsls<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmlsls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlsls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x3:
            if (u) {
                return new Unknown(machInst);
            } else {
                switch (size) {
                  case 1:
                    return new Vqdmlals<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vqdmlals<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x7:
            if (u) {
                return new Unknown(machInst);
            } else {
                switch (size) {
                  case 1:
                    return new Vqdmlsls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vqdmlsls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x8:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmulsQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmulsQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmulsD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmulsD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x9:
            if (u)
                return new VmulsQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmulsDFp<float>(machInst, vd, vn, vm, index);
          case 0xa:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmulls<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmulls<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmulls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmulls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0xb:
            if (u) {
                return new Unknown(machInst);
            } else {
                if (u) {
                    switch (size) {
                      case 1:
                        return new Vqdmulls<uint16_t>(
                                machInst, vd, vn, vm, index);
                      case 2:
                        return new Vqdmulls<uint32_t>(
                                machInst, vd, vn, vm, index);
                      default:
                        return new Unknown(machInst);
                    }
                } else {
                    switch (size) {
                      case 1:
                        return new Vqdmulls<int16_t>(
                                machInst, vd, vn, vm, index);
                      case 2:
                        return new Vqdmulls<int32_t>(
                                machInst, vd, vn, vm, index);
                      default:
                        return new Unknown(machInst);
                    }
                }
            }
          case 0xc:
            if (u) {
                switch (size) {
                  case 1:
                    return new VqdmulhsQ<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqdmulhsQ<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VqdmulhsD<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqdmulhsD<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0xd:
            if (u) {
                switch (size) {
                  case 1:
                    return new VqrdmulhsQ<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmulhsQ<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VqrdmulhsD<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmulhsD<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0xe:
            if (u) {
                switch (size) {
                  case 1:
                    return new VqrdmlahsQ<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmlahsQ<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VqrdmlahsD<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmlahsD<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0xf:
            if (u) {
                switch (size) {
                  case 1:
                    return new VqrdmlshsQ<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmlshsQ<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VqrdmlshsD<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmlshsD<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegMisc(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 17, 16);
        const uint32_t b = bits(machInst, 10, 6);
        const bool q = bits(machInst, 6);
        const RegIndex vd =
            (RegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const RegIndex vm =
            (RegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const unsigned size = bits(machInst, 19, 18);
        switch (opc1) {
          case 0x0:
            switch (bits(b, 4, 1)) {
              case 0x0:
                switch (size) {
                  case 0:
                    if (q) {
                        return new NVrev64Q<uint8_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint8_t>(machInst, vd, vm);
                    }
                  case 1:
                    if (q) {
                        return new NVrev64Q<uint16_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint16_t>(machInst, vd, vm);
                    }
                  case 2:
                    if (q) {
                        return new NVrev64Q<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint32_t>(machInst, vd, vm);
                    }
                  default:
                    return new Unknown(machInst);
                }
              case 0x1:
                switch (size) {
                  case 0:
                    if (q) {
                        return new NVrev32Q<uint8_t>(machInst, vd, vm);
                    } else {
                        return new NVrev32D<uint8_t>(machInst, vd, vm);
                    }
                  case 1:
                    if (q) {
                        return new NVrev32Q<uint16_t>(machInst, vd, vm);
                    } else {
                        return new NVrev32D<uint16_t>(machInst, vd, vm);
                    }
                  default:
                    return new Unknown(machInst);
                }
              case 0x2:
                if (size != 0) {
                    return new Unknown(machInst);
                } else if (q) {
                    return new NVrev16Q<uint8_t>(machInst, vd, vm);
                } else {
                    return new NVrev16D<uint8_t>(machInst, vd, vm);
                }
              case 0x4:
                return decodeNeonSTwoMiscSReg<NVpaddlD, NVpaddlQ>(
                        q, size, machInst, vd, vm);
              case 0x5:
                return decodeNeonUTwoMiscSReg<NVpaddlD, NVpaddlQ>(
                        q, size, machInst, vd, vm);
              case 0x6:
                if (q == 0) {
                    return new AESE(machInst, vd, vd, vm);
                } else {
                    return new AESD(machInst, vd, vd, vm);
                }
              case 0x7:
                if (q == 0) {
                    return new AESMC(machInst, vd, vm);
                } else {
                    return new AESIMC(machInst, vd, vm);
                }
              case 0x8:
                return decodeNeonSTwoMiscReg<NVclsD, NVclsQ>(
                        q, size, machInst, vd, vm);
              case 0x9:
                return decodeNeonSTwoMiscReg<NVclzD, NVclzQ>(
                        q, size, machInst, vd, vm);
              case 0xa:
                return decodeNeonUTwoMiscReg<NVcntD, NVcntQ>(
                        q, size, machInst, vd, vm);
              case 0xb:
                if (q)
                    return new NVmvnQ<uint64_t>(machInst, vd, vm);
                else
                    return new NVmvnD<uint64_t>(machInst, vd, vm);
              case 0xc:
                return decodeNeonSTwoMiscSReg<NVpadalD, NVpadalQ>(
                        q, size, machInst, vd, vm);
              case 0xd:
                return decodeNeonUTwoMiscSReg<NVpadalD, NVpadalQ>(
                        q, size, machInst, vd, vm);
              case 0xe:
                return decodeNeonSTwoMiscReg<NVqabsD, NVqabsQ>(
                        q, size, machInst, vd, vm);
              case 0xf:
                return decodeNeonSTwoMiscReg<NVqnegD, NVqnegQ>(
                        q, size, machInst, vd, vm);
              default:
                return new Unknown(machInst);
            }
          case 0x1:
            switch (bits(b, 3, 1)) {
              case 0x0:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcgtQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcgtDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcgtD, NVcgtQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x1:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcgeQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcgeDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcgeD, NVcgeQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x2:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVceqQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVceqDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVceqD, NVceqQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x3:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcleQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcleDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcleD, NVcleQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x4:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcltQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcltDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcltD, NVcltQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x5:
                if (q) {
                    return new SHA1H(machInst, vd, vm);
                } else {
                    return new Unknown(machInst);
                }
              case 0x6:
                if (bits(machInst, 10)) {
                    if (q)
                        return new NVabsQFp<float>(machInst, vd, vm);
                    else
                        return new NVabsDFp<float>(machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscReg<NVabsD, NVabsQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x7:
                if (bits(machInst, 10)) {
                    if (q)
                        return new NVnegQFp<float>(machInst, vd, vm);
                    else
                        return new NVnegDFp<float>(machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscReg<NVnegD, NVnegQ>(
                            q, size, machInst, vd, vm);
                }
              default:
                return new Unknown64(machInst);
            }
          case 0x2:
            switch (bits(b, 4, 1)) {
              case 0x0:
                if (q)
                    return new NVswpQ<uint64_t>(machInst, vd, vm);
                else
                    return new NVswpD<uint64_t>(machInst, vd, vm);
              case 0x1:
                return decodeNeonUTwoMiscSReg<NVtrnD, NVtrnQ>(
                        q, size, machInst, vd, vm);
              case 0x2:
                return decodeNeonUTwoMiscReg<NVuzpD, NVuzpQ>(
                        q, size, machInst, vd, vm);
              case 0x3:
                return decodeNeonUTwoMiscReg<NVzipD, NVzipQ>(
                        q, size, machInst, vd, vm);
              case 0x4:
                if (b == 0x8) {
                    return decodeNeonUTwoMiscUSReg<NVmovn>(
                            size, machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscUSReg<NVqmovuns>(
                            size, machInst, vd, vm);
                }
              case 0x5:
                if (q) {
                    return decodeNeonUTwoMiscUSReg<NVqmovun>(
                            size, machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscUSReg<NVqmovn>(
                            size, machInst, vd, vm);
                }
              case 0x6:
                if (b == 0xc) {
                    return decodeNeonSTwoShiftUSReg<NVshll>(
                            size, machInst, vd, vm, 8 << size);
                } else {
                    return new Unknown(machInst);
                }
              case 0x7:
                if (q) {
                    return new SHA256SU0(machInst, vd, vm);
                } else {
                    return new SHA1SU1(machInst, vd, vm);
                }
              case 0xc:
              case 0xe:
                if (b == 0x18) {
                    if (size != 1 || (vm % 2))
                        return new Unknown(machInst);
                    return new NVcvts2h<uint16_t>(machInst, vd, vm);
                } else if (b == 0x1c) {
                    if (size != 1 || (vd % 2))
                        return new Unknown(machInst);
                    return new NVcvth2s<uint16_t>(machInst, vd, vm);
                } else {
                    return new Unknown(machInst);
                }
              default:
                return new Unknown(machInst);
            }
          case 0x3:
            if (bits(b, 4, 3) == 0x3) {
                if ((q && (vd % 2 || vm % 2)) || size != 2) {
                    return new Unknown(machInst);
                } else {
                    if (bits(b, 2)) {
                        if (bits(b, 1)) {
                            if (q) {
                                return new NVcvt2ufxQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvt2ufxD<float>(
                                        machInst, vd, vm, 0);
                            }
                        } else {
                            if (q) {
                                return new NVcvt2sfxQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvt2sfxD<float>(
                                        machInst, vd, vm, 0);
                            }
                        }
                    } else {
                        if (bits(b, 1)) {
                            if (q) {
                                return new NVcvtu2fpQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvtu2fpD<float>(
                                        machInst, vd, vm, 0);
                            }
                        } else {
                            if (q) {
                                return new NVcvts2fpQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvts2fpD<float>(
                                        machInst, vd, vm, 0);
                            }
                        }
                    }
                }
            } else if ((b & 0x1a) == 0x10) {
                if (bits(b, 2)) {
                    if (q) {
                        return new NVrecpeQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVrecpeDFp<float>(machInst, vd, vm);
                    }
                } else {
                    if (q) {
                        return new NVrecpeQ<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrecpeD<uint32_t>(machInst, vd, vm);
                    }
                }
            } else if ((b & 0x1a) == 0x12) {
                if (bits(b, 2)) {
                    if (q) {
                        return new NVrsqrteQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVrsqrteDFp<float>(machInst, vd, vm);
                    }
                } else {
                    if (q) {
                        return new NVrsqrteQ<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrsqrteD<uint32_t>(machInst, vd, vm);
                    }
                }
            } else {
                return new Unknown(machInst);
            }
        }
        return new Unknown(machInst);
    }
    StaticInstPtr
    decodeNeonData(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 23, 19);
        const uint32_t q = bits(machInst, 11, 8);
        const uint32_t c = bits(machInst, 7, 4);
        if (bits(a, 4) == 0) {
            return decodeNeonThreeRegistersSameLength(machInst);
        } else if ((c & 0x9) == 1) {
            if ((a & 0x7) == 0) {
                return decodeNeonOneRegModImm(machInst);
            } else {
                return decodeNeonTwoRegAndShift(machInst);
            }
        } else if ((c & 0x9) == 9) {
            return decodeNeonTwoRegAndShift(machInst);
        } else if (bits(a, 2, 1) != 0x3) {
            if ((c & 0x5) == 0) {
                return decodeNeonThreeRegDiffLengths(machInst);
            } else if ((c & 0x5) == 4) {
                return decodeNeonTwoRegScalar(machInst);
            }
        } else if ((a & 0x16) == 0x16) {
            const RegIndex vd =
                (RegIndex)(2 * (bits(machInst, 15, 12) |
                                   (bits(machInst, 22) << 4)));
            const RegIndex vn =
                (RegIndex)(2 * (bits(machInst, 19, 16) |
                                   (bits(machInst, 7) << 4)));
            const RegIndex vm =
                (RegIndex)(2 * (bits(machInst, 3, 0) |
                                   (bits(machInst, 5) << 4)));
            if (!u) {
                if (bits(c, 0) == 0) {
                    unsigned imm4 = bits(machInst, 11, 8);
                    bool q = bits(machInst, 6);
                    if (imm4 >= 16 && !q)
                        return new Unknown(machInst);
                    if (q) {
                        return new NVextQ<uint8_t>(machInst, vd, vn, vm, imm4);
                    } else {
                        return new NVextD<uint8_t>(machInst, vd, vn, vm, imm4);
                    }
                }
            } else if (bits(q, 3) == 0 && bits(c, 0) == 0) {
                return decodeNeonTwoRegMisc(machInst);
            } else if (bits(q, 3, 2) == 0x2 && bits(c, 0) == 0) {
                unsigned length = bits(machInst, 9, 8) + 1;
                if ((uint32_t)vn / 2 + length > 32)
                    return new Unknown(machInst);
                if (bits(machInst, 6) == 0) {
                    switch (length) {
                      case 1:
                        return new NVtbl1(machInst, vd, vn, vm);
                      case 2:
                        return new NVtbl2(machInst, vd, vn, vm);
                      case 3:
                        return new NVtbl3(machInst, vd, vn, vm);
                      case 4:
                        return new NVtbl4(machInst, vd, vn, vm);
                    }
                } else {
                    switch (length) {
                      case 1:
                        return new NVtbx1(machInst, vd, vn, vm);
                      case 2:
                        return new NVtbx2(machInst, vd, vn, vm);
                      case 3:
                        return new NVtbx3(machInst, vd, vn, vm);
                      case 4:
                        return new NVtbx4(machInst, vd, vn, vm);
                    }
                }
            } else if (q == 0xc && (c & 0x9) == 0) {
                unsigned imm4 = bits(machInst, 19, 16);
                if (bits(imm4, 2, 0) == 0)
                    return new Unknown(machInst);
                unsigned size = 0;
                while ((imm4 & 0x1) == 0) {
                    size++;
                    imm4 >>= 1;
                }
                unsigned index = imm4 >> 1;
                const bool q = bits(machInst, 6);
                return decodeNeonUTwoShiftSReg<NVdupD, NVdupQ>(
                        q, size, machInst, vd, vm, index);
            }
        }
        return new Unknown(machInst);
    }
    
    bool
    wrongVLdmStmRegs(RegIndex start_reg, uint8_t count, bool single)
    {
        if (single) {
            const auto regs = count;
            if (regs == 0 || start_reg + regs > NumFloatV7ArchRegs)
                return true;
        } else {
            const auto regs = count/2;
            if (regs == 0 || start_reg + regs > NumFloatV7ArchRegs ||
                regs > 16)
                return true;
        }
        return false;
    }
    StaticInstPtr
    decodeExtensionRegLoadStore(ExtMachInst machInst)
    {
        const uint32_t opcode = bits(machInst, 24, 20);
        const uint32_t offset = bits(machInst, 7, 0);
        const bool single = (bits(machInst, 8) == 0);
        const RegIndex rn = (RegIndex)(uint32_t)bits(machInst, 19, 16);
        RegIndex vd = decodeFpVd(machInst, single ? 0x2 : 0x3, false);
        switch (bits(opcode, 4, 3)) {
          case 0x0:
            if (bits(opcode, 4, 1) == 0x2 &&
                    !(machInst.thumb == 1 && bits(machInst, 28) == 1) &&
                    !(machInst.thumb == 0 && machInst.condCode == 0xf)) {
                if ((bits(machInst, 7, 4) & 0xd) != 1) {
                    break;
                }
                const RegIndex rt =
                    (RegIndex)(uint32_t)bits(machInst, 15, 12);
                const RegIndex rt2 =
                    (RegIndex)(uint32_t)bits(machInst, 19, 16);
                const bool op = bits(machInst, 20);
                uint32_t vm;
                if (single) {
                    vm = (bits(machInst, 3, 0) << 1) | bits(machInst, 5);
                } else {
                    vm = (bits(machInst, 3, 0) << 1) |
                         (bits(machInst, 5) << 5);
                }
                if (op) {
                    return new Vmov2Core2Reg(machInst, rt, rt2,
                                             (RegIndex)vm);
                } else {
                    return new Vmov2Reg2Core(machInst, (RegIndex)vm,
                                             rt, rt2);
                }
            }
            break;
          case 0x1:
            {
                if (wrongVLdmStmRegs(vd, offset, single)) {
                    break;
                }
                switch (bits(opcode, 1, 0)) {
                  case 0x0:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, false, false, offset);
                  case 0x1:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, false, true, offset);
                  case 0x2:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, true, false, offset);
                  case 0x3:
                    // If rn == sp, then this is called vpop.
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, true, true, offset);
                  default:
                    GEM5_UNREACHABLE;
                }
            }
          case 0x2:
            if (bits(opcode, 1, 0) == 0x2) {
                if (wrongVLdmStmRegs(vd, offset, single)) {
                    break;
                } else {
                    // If rn == sp, then this is called vpush.
                    return new VLdmStm(machInst, rn, vd, single,
                                       false, true, false, offset);
                }
            } else if (bits(opcode, 1, 0) == 0x3) {
                if (wrongVLdmStmRegs(vd, offset, single)) {
                    break;
                } else {
                    return new VLdmStm(machInst, rn, vd, single,
                                       false, true, true, offset);
                }
            }
            [[fallthrough]];
          case 0x3:
            const bool up = (bits(machInst, 23) == 1);
            const uint32_t imm = bits(machInst, 7, 0) << 2;
            if (bits(opcode, 1, 0) == 0x0) {
                if (single) {
                    if (up) {
                        return new VSTR_STORE_IMM_PN_AY_WN_SN_UN_SZ4(machInst, vd, rn, up, imm);
                    } else {
                        return new VSTR_STORE_IMM_PN_AN_WN_SN_UN_SZ4(machInst, vd, rn, up, imm);
                    }
                } else {
                    if (up) {
                        return new VSTR_STORE_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, vd, vd + 1,
                                               rn, up, imm);
                    } else {
                        return new VSTR_STORE_IMMD_PN_AN_WN_SN_UN_SZ4(machInst, vd, vd + 1,
                                              rn, up, imm);
                    }
                }
            } else if (bits(opcode, 1, 0) == 0x1) {
                if (single) {
                    if (up) {
                        return new VLDR_LOAD_IMM_PN_AY_WN_SN_UN_SZ4(machInst, vd, rn, up, imm);
                    } else {
                        return new VLDR_LOAD_IMM_PN_AN_WN_SN_UN_SZ4(machInst, vd, rn, up, imm);
                    }
                } else {
                    if (up) {
                        return new VLDR_LOAD_IMMD_PN_AY_WN_SN_UN_SZ4(machInst, vd, vd + 1,
                                               rn, up, imm);
                    } else {
                        return new VLDR_LOAD_IMMD_PN_AN_WN_SN_UN_SZ4(machInst, vd, vd + 1,
                                              rn, up, imm);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    
    RegIndex decodeFpVd(ExtMachInst machInst, uint32_t size, bool isInt)
    {
        if (!isInt and size == 3) {
            return (RegIndex)((bits(machInst, 22) << 5) |
                               (bits(machInst, 15, 12) << 1));
        } else {
            return (RegIndex)(bits(machInst, 22) |
                              (bits(machInst, 15, 12) << 1));
        }
    }
    RegIndex decodeFpVm(ExtMachInst machInst, uint32_t size, bool isInt)
    {
        if (!isInt and size == 3) {
            return (RegIndex)((bits(machInst, 5) << 5) |
                               (bits(machInst, 3, 0) << 1));
        } else {
            return (RegIndex)(bits(machInst, 5) |
                              (bits(machInst, 3, 0) << 1));
        }
    }
    RegIndex decodeFpVn(ExtMachInst machInst, uint32_t size)
    {
        if (size == 3) {
            return (RegIndex)((bits(machInst, 7) << 5) |
                            (bits(machInst, 19, 16) << 1));
        } else {
            return (RegIndex)(bits(machInst, 7) |
                            (bits(machInst, 19, 16) << 1));
        }
    }
    StaticInstPtr
    decodeFloatingPointDataProcessing(ExtMachInst machInst) {
        const uint32_t op0 = bits(machInst, 23, 20);
        const uint32_t op1 = bits(machInst, 19, 16);
        const uint32_t op2 = bits(machInst, 9, 8);
        const uint32_t op3 = bits(machInst, 6);
        const uint32_t rm = bits(machInst, 17, 16);
        const uint32_t size = bits(machInst, 9, 8);
        RegIndex vd = decodeFpVd(machInst, size, false);
        RegIndex vm = decodeFpVm(machInst, size, false);
        RegIndex vdInt = decodeFpVd(machInst, size, true);
        RegIndex vn = decodeFpVn(machInst, size);
        if (bits(machInst, 31, 24) == 0xFE && !bits(machInst, 4)) {
            if (bits(op0, 3) == 0 && op2 != 0 && !op3){
                ConditionCode cond;
                switch(bits(machInst, 21, 20)) {
                case 0x0: cond = COND_EQ; break;
                case 0x1: cond = COND_VS; break;
                case 0x2: cond = COND_GE; break;
                case 0x3: cond = COND_GT; break;
                default: panic("unreachable");
                }
                if (size == 3) {
                    return new VselD(machInst, vd, vn, vm, cond);
                } else {
                    return new VselS(machInst, vd, vn, vm, cond);
                }
            } else if (bits(op0, 3) == 1 && bits(op0, 1, 0) == 0 && op2 != 0) {
                const bool op = bits(machInst, 6);
                if (op) {
                    if (size == 1) {
                        return new FailUnimplemented("vminnm.f16", machInst);
                    }
                    return decodeNeonSizeSingleDouble<VminnmS, VminnmD>(
                        size, machInst, vd, vn, vm);
                } else {
                    if (size == 1) {
                        return new FailUnimplemented("vmaxnm.f16", machInst);
                    }
                    return decodeNeonSizeSingleDouble<VmaxnmS, VmaxnmD>(
                        size, machInst, vd, vn, vm);
                }
            } else if (bits(op0, 3) && bits(op0, 1, 0) == 3 &&
                        bits(op1, 3) && op2 != 0 && op3)
                    {
                const uint32_t o1 = bits(machInst, 18);
                if (o1 == 0) {
                    if (size == 3) {
                        switch(rm) {
                            case 0x0:
                            return decodeVfpRegRegOp<VRIntAD>(machInst, vd, vm,
                                                                true);
                            case 0x1:
                            return decodeVfpRegRegOp<VRIntND>(machInst, vd, vm,
                                                                true);
                            case 0x2:
                            return decodeVfpRegRegOp<VRIntPD>(machInst, vd, vm,
                                                                true);
                            case 0x3:
                            return decodeVfpRegRegOp<VRIntMD>(machInst, vd, vm,
                                                                true);
                            default: return new Unknown(machInst);
                        }
                    } else {
                        switch(rm) {
                            case 0x0:
                            return decodeVfpRegRegOp<VRIntAS>(machInst, vd, vm,
                                                                false);
                            case 0x1:
                            return decodeVfpRegRegOp<VRIntNS>(machInst, vd, vm,
                                                                false);
                            case 0x2:
                            return decodeVfpRegRegOp<VRIntPS>(machInst, vd, vm,
                                                                false);
                            case 0x3:
                            return decodeVfpRegRegOp<VRIntMS>(machInst, vd, vm,
                                                                false);
                            default: return new Unknown(machInst);
                        }
                    }
                } else {
                    const bool op = bits(machInst, 7);
                    switch(rm) {
                    case 0x0:
                        switch(size) {
                        case 0x0:
                            return new Unknown(machInst);
                        case 0x1:
                            return new FailUnimplemented(
                                "vcvta.u32.f16", machInst);
                        case 0x2:
                            if (op) {
                                return new VcvtaFpSIntS(machInst, vdInt, vm);
                            } else {
                                return new VcvtaFpUIntS(machInst, vdInt, vm);
                            }
                        case 0x3:
                            if (op) {
                                return new VcvtaFpSIntD(machInst, vdInt, vm);
                            } else {
                                return new VcvtaFpUIntD(machInst, vdInt, vm);
                            }
                        default: return new Unknown(machInst);
                        }
                    case 0x1:
                        switch(size) {
                        case 0x0:
                            return new Unknown(machInst);
                        case 0x1:
                            return new FailUnimplemented(
                                "vcvtn.u32.f16", machInst);
                        case 0x2:
                            if (op) {
                                return new VcvtnFpSIntS(machInst, vdInt, vm);
                            } else {
                                return new VcvtnFpUIntS(machInst, vdInt, vm);
                            }
                        case 0x3:
                            if (op) {
                                return new VcvtnFpSIntD(machInst, vdInt, vm);
                            } else {
                                return new VcvtnFpUIntD(machInst, vdInt, vm);
                            }
                        default: return new Unknown(machInst);
                        }
                    case 0x2:
                        switch(size) {
                        case 0x0:
                            return new Unknown(machInst);
                        case 0x1:
                            return new FailUnimplemented(
                                "vcvtp.u32.f16", machInst);
                        case 0x2:
                            if (op) {
                                return new VcvtpFpSIntS(machInst, vdInt, vm);
                            } else {
                                return new VcvtpFpUIntS(machInst, vdInt, vm);
                            }
                        case 0x3:
                            if (op) {
                                return new VcvtpFpSIntD(machInst, vdInt, vm);
                            } else {
                                return new VcvtpFpUIntD(machInst, vdInt, vm);
                            }
                        default: return new Unknown(machInst);
                        }
                    case 0x3:
                        switch(size) {
                        case 0x0:
                            return new Unknown(machInst);
                        case 0x1:
                            return new FailUnimplemented(
                                "vcvtm.u32.f16", machInst);
                        case 0x2:
                            if (op) {
                                return new VcvtmFpSIntS(machInst, vdInt, vm);
                            } else {
                                return new VcvtmFpUIntS(machInst, vdInt, vm);
                            }
                        case 0x3:
                            if (op) {
                                return new VcvtmFpSIntD(machInst, vdInt, vm);
                            } else {
                                return new VcvtmFpUIntD(machInst, vdInt, vm);
                            }
                        default: return new Unknown(machInst);
                        }
                    default: return new Unknown(machInst);
                    }
                }
            } else {
                return new Unknown(machInst);
            }
        } else {
            return new Unknown(machInst);
        }
    }
    StaticInstPtr
    decodeShortFpTransfer(ExtMachInst machInst)
    {
        if ((machInst.thumb == 1 && bits(machInst, 28) == 1) ||
            (machInst.thumb == 0 && machInst.condCode == 0xf)) {
                return decodeFloatingPointDataProcessing(machInst);
        }
        const uint32_t l = bits(machInst, 20);
        const uint32_t c = bits(machInst, 8);
        const uint32_t a = bits(machInst, 23, 21);
        const uint32_t q = bits(machInst, 6, 5);
        if (l == 0 && c == 0) {
            if (a == 0) {
                const uint32_t vn = (bits(machInst, 19, 16) << 1) |
                                    bits(machInst, 7);
                const RegIndex rt =
                    (RegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 20) == 1) {
                    return new VmovRegCoreW(machInst, rt, (RegIndex)vn);
                } else {
                    return new VmovCoreRegW(machInst, (RegIndex)vn, rt);
                }
            } else if (a == 0x7) {
                const RegIndex rt =
                    (RegIndex)(uint32_t)bits(machInst, 15, 12);
                uint32_t reg = bits(machInst, 19, 16);
                uint32_t specReg;
                switch (reg) {
                  case 0:
                    specReg = MISCREG_FPSID;
                    break;
                  case 1:
                    specReg = MISCREG_FPSCR;
                    break;
                  case 6:
                    specReg = MISCREG_MVFR1;
                    break;
                  case 7:
                    specReg = MISCREG_MVFR0;
                    break;
                  case 8:
                    specReg = MISCREG_FPEXC;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                if (specReg == MISCREG_FPSCR) {
                    return new VmsrFpscr(machInst, (RegIndex)specReg, rt);
                } else {
                    uint32_t iss = mcrMrcIssBuild(0, bits(machInst, 3, 0), rt,
                        reg, a, bits(machInst, 7, 5));
                    return new Vmsr(machInst, (RegIndex)specReg, rt, iss);
                }
            }
        } else if (l == 0 && c == 1) {
            if (bits(a, 2) == 0) {
                uint32_t vd = (bits(machInst, 7) << 5) |
                              (bits(machInst, 19, 16) << 1);
                // Handle accessing each single precision half of the vector.
                vd += bits(machInst, 21);
                const RegIndex rt =
                    (RegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 22) == 1) {
                    return new VmovCoreRegB(machInst, (RegIndex)vd,
                                            rt, bits(machInst, 6, 5));
                } else if (bits(machInst, 5) == 1) {
                    return new VmovCoreRegH(machInst, (RegIndex)vd,
                                            rt, bits(machInst, 6));
                } else if (bits(machInst, 6) == 0) {
                    return new VmovCoreRegW(machInst, (RegIndex)vd, rt);
                } else {
                    return new Unknown(machInst);
                }
            } else if (bits(q, 1) == 0) {
                bool q = bits(machInst, 21);
                unsigned be = (bits(machInst, 22) << 1) | (bits(machInst, 5));
                RegIndex vd = (RegIndex)(2 * (uint32_t)
                    (bits(machInst, 19, 16) | (bits(machInst, 7) << 4)));
                RegIndex rt = (RegIndex)(uint32_t)
                    bits(machInst, 15, 12);
                if (q) {
                    switch (be) {
                      case 0:
                        return new NVdupQGpr<uint32_t>(machInst, vd, rt);
                      case 1:
                        return new NVdupQGpr<uint16_t>(machInst, vd, rt);
                      case 2:
                        return new NVdupQGpr<uint8_t>(machInst, vd, rt);
                      case 3:
                        return new Unknown(machInst);
                    }
                } else {
                    switch (be) {
                      case 0:
                        return new NVdupDGpr<uint32_t>(machInst, vd, rt);
                      case 1:
                        return new NVdupDGpr<uint16_t>(machInst, vd, rt);
                      case 2:
                        return new NVdupDGpr<uint8_t>(machInst, vd, rt);
                      case 3:
                        return new Unknown(machInst);
                    }
                }
            }
        } else if (l == 1 && c == 0) {
            if (a == 0) {
                const uint32_t vn = (bits(machInst, 19, 16) << 1) |
                                    bits(machInst, 7);
                const RegIndex rt =
                    (RegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 20) == 1) {
                    return new VmovRegCoreW(machInst, rt, (RegIndex)vn);
                } else {
                    return new VmovCoreRegW(machInst, (RegIndex)vn, rt);
                }
            } else if (a == 7) {
                const RegIndex rt =
                    (RegIndex)(uint32_t)bits(machInst, 15, 12);
                uint32_t reg = bits(machInst, 19, 16);
                uint32_t specReg;
                switch (reg) {
                  case 0:
                    specReg = MISCREG_FPSID;
                    break;
                  case 1:
                    specReg = MISCREG_FPSCR;
                    break;
                  case 6:
                    specReg = MISCREG_MVFR1;
                    break;
                  case 7:
                    specReg = MISCREG_MVFR0;
                    break;
                  case 8:
                    specReg = MISCREG_FPEXC;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                if (rt == 0xf) {
                    if (specReg == MISCREG_FPSCR) {
                        return new VmrsApsrFpscr(machInst);
                    } else {
                        return new Unknown(machInst);
                    }
                } else if (specReg == MISCREG_FPSCR) {
                    return new VmrsFpscr(machInst, rt, (RegIndex)specReg);
                } else {
                    uint32_t iss = mcrMrcIssBuild(l, bits(machInst, 3, 0), rt,
                        reg, a, bits(machInst, 7, 5));
                    return new Vmrs(machInst, rt, (RegIndex)specReg, iss);
                }
            }
        } else {
            uint32_t vd = (bits(machInst, 7) << 5) |
                          (bits(machInst, 19, 16) << 1);
            // Handle indexing into each single precision half of the vector.
            vd += bits(machInst, 21);
            uint32_t index;
            const RegIndex rt =
                (RegIndex)(uint32_t)bits(machInst, 15, 12);
            const bool u = (bits(machInst, 23) == 1);
            if (bits(machInst, 22) == 1) {
                index = bits(machInst, 6, 5);
                if (u) {
                    return new VmovRegCoreUB(machInst, rt,
                                             (RegIndex)vd, index);
                } else {
                    return new VmovRegCoreSB(machInst, rt,
                                             (RegIndex)vd, index);
                }
            } else if (bits(machInst, 5) == 1) {
                index = bits(machInst, 6);
                if (u) {
                    return new VmovRegCoreUH(machInst, rt,
                                             (RegIndex)vd, index);
                } else {
                    return new VmovRegCoreSH(machInst, rt,
                                             (RegIndex)vd, index);
                }
            } else if (bits(machInst, 6) == 0 && !u) {
                return new VmovRegCoreW(machInst, rt, (RegIndex)vd);
            } else {
                return new Unknown(machInst);
            }
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeVfpData(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 20);
        const uint32_t opc2 = bits(machInst, 19, 16);
        const uint32_t opc3 = bits(machInst, 7, 6);
        //const uint32_t opc4 = bits(machInst, 3, 0);
        const bool single = (bits(machInst, 8) == 0);
        // Used to select between vcmp and vcmpe.
        const bool e = (bits(machInst, 7) == 1);
        RegIndex vd;
        RegIndex vm;
        RegIndex vn;
        if (single) {
            vd = (RegIndex)(bits(machInst, 22) |
                    (bits(machInst, 15, 12) << 1));
            vm = (RegIndex)(bits(machInst, 5) |
                    (bits(machInst, 3, 0) << 1));
            vn = (RegIndex)(bits(machInst, 7) |
                    (bits(machInst, 19, 16) << 1));
        } else {
            vd = (RegIndex)((bits(machInst, 22) << 5) |
                    (bits(machInst, 15, 12) << 1));
            vm = (RegIndex)((bits(machInst, 5) << 5) |
                    (bits(machInst, 3, 0) << 1));
            vn = (RegIndex)((bits(machInst, 7) << 5) |
                    (bits(machInst, 19, 16) << 1));
        }
        switch (opc1 & 0xb /* 1011 */) {
          case 0x0:
            if (bits(machInst, 6) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VmlaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmlaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VmlsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmlsD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x1:
            if (bits(machInst, 6) == 1) {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmlaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmlaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmlsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmlsD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x2:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VmulS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmulD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmulS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmulD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x3:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VaddS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VaddD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VsubS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VsubD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x8:
            if (machInst.condCode == 0xF) {
                const bool op = bits(machInst, 6);
                const uint32_t size = bits(machInst, 9, 8);
                if (op) {
                    if (size == 1) {
                        return new FailUnimplemented("vminnm.f16", machInst);
                    }
                    return decodeNeonSizeSingleDouble<VminnmS, VminnmD>(
                        size, machInst, vd, vn, vm);
                } else {
                    if (size == 1) {
                        return new FailUnimplemented("vmaxnm.f16", machInst);
                    }
                    return decodeNeonSizeSingleDouble<VmaxnmS, VmaxnmD>(
                        size, machInst, vd, vn, vm);
                }
            }
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VdivS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VdivD>(
                            machInst, vd, vn, vm, true);
                }
            }
            break;
          case 0x9:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VfnmaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VfnmaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VfnmsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VfnmsD>(
                            machInst, vd, vn, vm, true);
                }
            }
            break;
          case 0xa:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VfmaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VfmaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VfmsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VfmsD>(
                            machInst, vd, vn, vm, true);
                }
            }
            break;
          case 0xb:
            if ((opc3 & 0x1) == 0) {
                const uint32_t baseImm =
                    bits(machInst, 3, 0) | (bits(machInst, 19, 16) << 4);
                if (single) {
                    uint32_t imm = vfp_modified_imm(baseImm, FpDataType::Fp32);
                    return decodeVfpRegImmOp<VmovImmS>(
                            machInst, vd, imm, false);
                } else {
                    uint64_t imm = vfp_modified_imm(baseImm, FpDataType::Fp64);
                    return decodeVfpRegImmOp<VmovImmD>(
                            machInst, vd, imm, true);
                }
            }
            switch (opc2) {
              case 0x0:
                if (opc3 == 1) {
                    if (single) {
                        return decodeVfpRegRegOp<VmovRegS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VmovRegD>(
                                machInst, vd, vm, true);
                    }
                } else {
                    if (single) {
                        return decodeVfpRegRegOp<VabsS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VabsD>(
                                machInst, vd, vm, true);
                    }
                }
              case 0x1:
                if (opc3 == 1) {
                    if (single) {
                        return decodeVfpRegRegOp<VnegS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VnegD>(
                                machInst, vd, vm, true);
                    }
                } else {
                    if (single) {
                        return decodeVfpRegRegOp<VsqrtS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VsqrtD>(
                                machInst, vd, vm, true);
                    }
                }
              case 0x2:
              case 0x3:
                {
                    const bool toHalf = bits(machInst, 16);
                    const bool top = bits(machInst, 7);
                    if (top) {
                        if (toHalf) {
                            return new VcvtFpSFpHT(machInst, vd, vm);
                        } else {
                            return new VcvtFpHTFpS(machInst, vd, vm);
                        }
                    } else {
                        if (toHalf) {
                            return new VcvtFpSFpHB(machInst, vd, vm);
                        } else {
                            return new VcvtFpHBFpS(machInst, vd, vm);
                        }
                    }
                }
              case 0x4:
                if (single) {
                    if (e) {
                        return new VcmpeS(machInst, vd, vm);
                    } else {
                        return new VcmpS(machInst, vd, vm);
                    }
                } else {
                    if (e) {
                        return new VcmpeD(machInst, vd, vm);
                    } else {
                        return new VcmpD(machInst, vd, vm);
                    }
                }
              case 0x5:
                if (single) {
                    if (e) {
                        return new VcmpeZeroS(machInst, vd, 0);
                    } else {
                        return new VcmpZeroS(machInst, vd, 0);
                    }
                } else {
                    if (e) {
                        return new VcmpeZeroD(machInst, vd, 0);
                    } else {
                        return new VcmpZeroD(machInst, vd, 0);
                    }
                }
              case 0x7:
                if (opc3 == 0x3) {
                    if (single) {
                        vd = (RegIndex)((bits(machInst, 22) << 5) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSFpD(machInst, vd, vm);
                    } else {
                        vd = (RegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpDFpS(machInst, vd, vm);
                    }
                }
                break;
              case 0x8:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtUIntFpS(machInst, vd, vm);
                    } else {
                        vm = (RegIndex)(bits(machInst, 5) |
                                (bits(machInst, 3, 0) << 1));
                        return new VcvtUIntFpD(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtSIntFpS(machInst, vd, vm);
                    } else {
                        vm = (RegIndex)(bits(machInst, 5) |
                                (bits(machInst, 3, 0) << 1));
                        return new VcvtSIntFpD(machInst, vd, vm);
                    }
                }
              case 0x9:
                if (bits(machInst, 31, 28) != 0xF
                    && bits(machInst, 27, 23) == 0x1D) {
                    vd = (RegIndex)(bits(machInst, 22) |
                         (bits(machInst, 15, 12) << 1));
                    return new VjcvtSFixedFpD(machInst, vd, vm);
                }
                break;
              case 0xa:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtSHFixedFpS(machInst, vd, vd, size);
                        } else {
                            return new VcvtSFixedFpS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtSHFixedFpD(machInst, vd, vd, size);
                        } else {
                            return new VcvtSFixedFpD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xb:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtUHFixedFpS(machInst, vd, vd, size);
                        } else {
                            return new VcvtUFixedFpS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtUHFixedFpD(machInst, vd, vd, size);
                        } else {
                            return new VcvtUFixedFpD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xc:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtFpUIntSR(machInst, vd, vm);
                    } else {
                        vd = (RegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpUIntDR(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtFpUIntS(machInst, vd, vm);
                    } else {
                        vd = (RegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpUIntD(machInst, vd, vm);
                    }
                }
              case 0xd:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtFpSIntSR(machInst, vd, vm);
                    } else {
                        vd = (RegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSIntDR(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtFpSIntS(machInst, vd, vm);
                    } else {
                        vd = (RegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSIntD(machInst, vd, vm);
                    }
                }
              case 0xe:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtFpSHFixedS(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpSFixedS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtFpSHFixedD(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpSFixedD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xf:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtFpUHFixedS(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpUFixedS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtFpUHFixedD(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpUFixedD(machInst, vd, vd, size);
                        }
                    }
                }
            }
            break;
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeMcrMrc14(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 21);
        const uint32_t crn = bits(machInst, 19, 16);
        const uint32_t opc2 = bits(machInst, 7, 5);
        const uint32_t crm = bits(machInst, 3, 0);
        const MiscRegIndex miscReg = decodeCP14Reg(crn, opc1, crm, opc2);
        const RegIndex rt = (RegIndex)(uint32_t)bits(machInst, 15, 12);
        const bool isRead = bits(machInst, 20);
        switch (miscReg) {
          case MISCREG_NOP:
            return new NopInst(machInst);
          case MISCREG_UNKNOWN:
            return new FailUnimplemented(isRead ? "mrc unknown" : "mcr unknown",
                    machInst,
                    csprintf("miscreg crn:%d opc1:%d crm:%d opc2:%d %s unknown",
                    crn, opc1, crm, opc2, isRead ? "read" : "write"));
          default:
            uint32_t iss = mcrMrcIssBuild(isRead, crm, rt, crn, opc1, opc2);
            if (isRead) {
                return new Mrc14(machInst, rt, miscReg, iss);
            } else {
                return new Mcr14(machInst, miscReg, rt, iss);
            }
        }
    }
    
    StaticInstPtr
    decodeMcrMrc15(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 21);
        const uint32_t crn = bits(machInst, 19, 16);
        const uint32_t opc2 = bits(machInst, 7, 5);
        const uint32_t crm = bits(machInst, 3, 0);
        const MiscRegIndex misc_reg = decodeCP15Reg(crn, opc1, crm, opc2);
        const RegIndex rt = (RegIndex)(uint32_t)bits(machInst, 15, 12);
        const bool is_read = bits(machInst, 20);
        uint32_t iss = mcrMrcIssBuild(is_read, crm, rt, crn, opc1, opc2);
        switch (misc_reg) {
          case MISCREG_NOP:
            return new McrMrcMiscInst(is_read ? "mrc nop" : "mcr nop",
                                      machInst, iss, MISCREG_NOP);
          case MISCREG_UNKNOWN:
            return new FailUnimplemented(is_read ? "mrc unkown" : "mcr unkown",
                    machInst,
                    csprintf("miscreg crn:%d opc1:%d crm:%d opc2:%d %s unknown",
                    crn, opc1, crm, opc2, is_read ? "read" : "write"));
          case MISCREG_IMPDEF_UNIMPL:
            if (lookUpMiscReg[misc_reg].info[MISCREG_WARN_NOT_FAIL]) {
                auto mnemonic =
                    csprintf("miscreg crn:%d opc1:%d crm:%d opc2:%d %s",
                             crn, opc1, crm, opc2, is_read ? "read" : "write");
                return new WarnUnimplemented(
                    is_read ? "mrc implementation defined" :
                              "mcr implementation defined",
                    machInst, mnemonic + " treated as NOP");
            } else {
                return new McrMrcImplDefined(
                    is_read ? "mrc implementation defined" :
                             "mcr implementation defined",
                    machInst, iss, MISCREG_IMPDEF_UNIMPL);
            }
          case MISCREG_CP15ISB:
            return new Isb(machInst, iss);
          case MISCREG_CP15DSB:
            return new Dsb(machInst, iss);
          case MISCREG_CP15DMB:
            return new Dmb(machInst, iss);
          case MISCREG_DCIMVAC:
            return new McrDcimvac(machInst, misc_reg, rt, iss);
          case MISCREG_DCCMVAC:
            return new McrDccmvac(machInst, misc_reg, rt, iss);
          case MISCREG_DCCMVAU:
            return new McrDccmvau(machInst, misc_reg, rt, iss);
          case MISCREG_DCCIMVAC:
            return new McrDccimvac(machInst, misc_reg, rt, iss);
          case MISCREG_TLBIALL:
          case MISCREG_TLBIALLIS:
          case MISCREG_ITLBIALL:
          case MISCREG_DTLBIALL:
          case MISCREG_TLBIMVA:
          case MISCREG_TLBIMVAL:
          case MISCREG_TLBIMVAIS:
          case MISCREG_TLBIMVALIS:
          case MISCREG_TLBIASID:
          case MISCREG_TLBIASIDIS:
          case MISCREG_TLBIMVAA:
          case MISCREG_TLBIMVAAL:
          case MISCREG_TLBIMVAAIS:
          case MISCREG_TLBIMVAALIS:
          case MISCREG_TLBIMVAH:
          case MISCREG_TLBIMVALH:
          case MISCREG_TLBIMVAHIS:
          case MISCREG_TLBIMVALHIS:
          case MISCREG_TLBIIPAS2:
          case MISCREG_TLBIIPAS2L:
          case MISCREG_TLBIIPAS2IS:
          case MISCREG_TLBIIPAS2LIS:
          case MISCREG_ITLBIMVA:
          case MISCREG_DTLBIMVA:
          case MISCREG_ITLBIASID:
          case MISCREG_DTLBIASID:
          case MISCREG_TLBIALLNSNH:
          case MISCREG_TLBIALLNSNHIS:
          case MISCREG_TLBIALLH:
          case MISCREG_TLBIALLHIS:
            return new Tlbi(machInst, misc_reg, rt, iss);
          default:
            auto& miscreg_info = lookUpMiscReg[misc_reg].info;
            if (miscreg_info[MISCREG_WARN_NOT_FAIL]) {
                std::string full_mnem = csprintf("%s %s",
                    is_read ? "mrc" : "mcr", miscRegName[misc_reg]);
                warn("\tinstruction '%s' unimplemented\n", full_mnem);
                // Remove the warn flag and set the implemented flag. This
                // prevents the instruction warning a second time, it also
                // means the instruction is actually generated. Actually
                // creating the instruction to access an register that isn't
                // implemented sounds a bit silly, but its required to get
                // the correct behaviour for hyp traps and undef exceptions.
                miscreg_info[MISCREG_IMPLEMENTED]   = true;
                miscreg_info[MISCREG_WARN_NOT_FAIL] = false;
            }
            if (miscreg_info[MISCREG_IMPLEMENTED]) {
                if (is_read)
                    return new Mrc15(machInst, rt, misc_reg, iss);
                return new Mcr15(machInst, misc_reg, rt, iss);
            } else {
                return new FailUnimplemented(is_read ? "mrc" : "mcr", machInst,
                    csprintf("%s %s", is_read ? "mrc" : "mcr",
                        miscRegName[misc_reg]));
            }
        }
    }
    
    StaticInstPtr
    decodeMcrrMrrc15(ExtMachInst machInst)
    {
        const uint32_t crm = bits(machInst, 3, 0);
        const uint32_t opc1 = bits(machInst, 7, 4);
        const MiscRegIndex misc_reg = decodeCP15Reg64(crm, opc1);
        const RegIndex rt = (RegIndex) (uint32_t) bits(machInst, 15, 12);
        const RegIndex rt2 = (RegIndex) (uint32_t) bits(machInst, 19, 16);
        const bool is_read = bits(machInst, 20);
        switch (misc_reg) {
          case MISCREG_UNKNOWN:
            return new FailUnimplemented(is_read ? "mrc" : "mcr", machInst,
                    csprintf("miscreg crm:%d opc1:%d 64-bit %s unknown",
                    crm, opc1, is_read ? "read" : "write"));
          default:
            auto& miscreg_info = lookUpMiscReg[misc_reg].info;
            if (miscreg_info[MISCREG_WARN_NOT_FAIL]) {
                std::string full_mnem = csprintf("%s %s",
                    is_read ? "mrrc" : "mcrr", miscRegName[misc_reg]);
                warn("\tinstruction '%s' unimplemented\n", full_mnem);
                // Remove the warn flag and set the implemented flag. This
                // prevents the instruction warning a second time, it also
                // means the instruction is actually generated. Actually
                // creating the instruction to access an register that isn't
                // implemented sounds a bit silly, but its required to get
                // the correct behaviour for hyp traps and undef exceptions.
                miscreg_info[MISCREG_IMPLEMENTED]   = true;
                miscreg_info[MISCREG_WARN_NOT_FAIL] = false;
            }
            if (miscreg_info[MISCREG_IMPLEMENTED]) {
                uint32_t iss = mcrrMrrcIssBuild(is_read, crm, rt, rt2, opc1);
                if (is_read) {
                    StaticInstPtr si =  new Mrrc15(machInst, misc_reg, rt2, rt, iss);
                    if (miscreg_info[MISCREG_UNVERIFIABLE])
                        si->setFlag(StaticInst::IsUnverifiable);
                    return si;
                }
                return new Mcrr15(machInst, rt2, rt, misc_reg, iss);
            } else {
                return new FailUnimplemented(is_read ? "mrrc" : "mcrr", machInst,
                    csprintf("%s %s",
                    is_read ? "mrrc" : "mcrr", miscRegName[misc_reg]));
            }
        }
    }
    
    StaticInstPtr
    decodeCryptoAES(ExtMachInst machInst)
    {
        const auto opcode = bits(machInst, 16, 12);
        const auto size = bits(machInst, 23, 22);
        RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        if (size) {
            // UNALLOCATED
            return new Unknown64(machInst);
        } else {
            switch (opcode) {
              case 0x4: return new AESE64(machInst, rd, rd, rn);
              case 0x5: return new AESD64(machInst, rd, rd, rn);
              case 0x6: return new AESMC64(machInst, rd, rn);
              case 0x7: return new AESIMC64(machInst, rd, rn);
              default: return new Unknown64(machInst);
            }
        }
    }
    StaticInstPtr
    decodeCryptoTwoRegSHA(ExtMachInst machInst)
    {
        const auto opcode = bits(machInst, 16, 12);
        const auto size = bits(machInst, 23, 22);
        RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        if (size) {
            // UNALLOCATED
            return new Unknown64(machInst);
        } else {
            switch (opcode) {
              case 0x0: return new SHA1H64(machInst, rd, rn);
              case 0x1: return new SHA1SU164(machInst, rd, rn);
              case 0x2: return new SHA256SU064(machInst, rd, rn);
              default: return new Unknown64(machInst);
            }
        }
    }
    StaticInstPtr
    decodeCryptoThreeRegSHA(ExtMachInst machInst)
    {
        const auto opcode = bits(machInst, 14, 12);
        const auto size = bits(machInst, 23, 22);
        RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        if (size) {
            // UNALLOCATED
            return new Unknown64(machInst);
        } else {
            switch (opcode) {
              case 0x0: return new SHA1C64(machInst, rd, rn, rm);
              case 0x1: return new SHA1P64(machInst, rd, rn, rm);
              case 0x2: return new SHA1M64(machInst, rd, rn, rm);
              case 0x3: return new SHA1SU064(machInst, rd, rn, rm);
              case 0x4: return new SHA256H64(machInst, rd, rn, rm);
              case 0x5: return new SHA256H264(machInst, rd, rn, rm);
              case 0x6: return new SHA256SU164(machInst, rd, rn, rm);
              default: return new Unknown64(machInst);
            }
        }
    }
   
// ArmUnconditional::armUnconditional(([], {}))

// ArmMultAndMultAcc::armMultAndMultAcc(([], {}))

// ArmSyncMem::armSyncMem(([], {}))

// Unknown::unknown(([], {}))

// AddrMode3::addrMode3(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcReg::armDataProcReg(([], {}))

// ArmMsrMrs::armMsrMrs(([], {}))

// ArmBxClz::armBxClz(([], {}))

// ArmBlxReg::armBlxReg(([], {}))

// Unknown::unknown(([], {}))

// Crc32::crc32(([], {}))

// ArmSatAddSub::armSatAddSub(([], {}))

// ArmERet::armERet(([], {}))

// ArmBkptHlt::armBkptHlt(([], {}))

// ArmSmcHyp::armSmcHyp(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmHalfWordMultAndMultAcc::armHalfWordMultAndMultAcc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcImm::armDataProcImm(([], {}))

// ArmMisc::armMisc(([], {}))

// Unknown::unknown(([], {}))

// AddrMode2::addrMode2((['True'], {}))

// AddrMode2::addrMode2((['False'], {}))

// ArmParallelAddSubtract::armParallelAddSubtract(([], {}))

// ArmPackUnpackSatReverse::armPackUnpackSatReverse(([], {}))

// ArmSignedMultiplies::armSignedMultiplies(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// ArmBBlxImm::armBBlxImm(([], {}))

// ArmBlBlxImm::armBlBlxImm(([], {}))

// Unknown::unknown(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStore(([], {}))

// Mcrr15::Mcrr15(([], {}))

// Mrrc15::Mrrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VfpData::vfpData(([], {}))

// Unknown::unknown(([], {}))

// Gem5Op::gem5op(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Svc::svc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Aarch64::aarch64(([], {}))

// Unknown::unknown(([], {}))

// Thumb16ShiftAddSubMoveCmp::thumb16ShiftAddMoveCmp(([], {}))

// Thumb16DataProcessing::thumb16DataProcessing(([], {}))

// Thumb16SpecDataAndBx::thumb16SpecDataAndBx(([], {}))

// Thumb16MemLit::thumb16MemLit(([], {}))

// Thumb16MemReg::thumb16MemReg(([], {}))

// Thumb16MemImm::thumb16MemImm(([], {}))

// Thumb16Adr::thumb16Adr(([], {}))

// Thumb16AddSp::thumb16AddSp(([], {}))

// Thumb16Misc::thumb16Misc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16MacroMem::thumb16MacroMem(([], {}))

// Thumb16CondBranchAndSvc::thumb16CondBranchAndSvc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16UncondBranch::thumb16UncondBranch(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32SrsRfe::thumb32SrsRfe(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// Thumb32LdrStrDExTbh::thumb32LdrStrDExTbh(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcShiftReg::thumb32DataProcShiftReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// Gem5Op::gem5op(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::ThumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// Mcrr15::Mcrr15(([], {}))

// WarnUnimpl::mcrr(([], {}))

// Mrrc15::Mrrc15(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcModImm::thumb32DataProcModImm(([], {}))

// Thumb32DataProcPlainBin::thumb32DataProcPlainBin(([], {}))

// Unknown::unknown(([], {}))

// Thumb32BranchesAndMiscCtrl::thumb32BranchesAndMiscCtrl(([], {}))

// Unknown::unknown(([], {}))

// Thumb32StoreSingle::thumb32StoreSingle(([], {}))

// ThumbNeonMem::thumbNeonMem(([], {}))

// Unknown::unknown(([], {}))

// LoadByteMemoryHints::loadByteMemoryHints(([], {}))

// LoadHalfwordMemoryHints::loadHalfwordMemoryHints(([], {}))

// Thumb32LoadWord::thumb32LoadWord(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32MulMulAccAndAbsDiff::thumb32MulMulAccAndAbsDiff(([], {}))

// Thumb32LongMulMulAccAndDiv::thumb32LongMulMulAccAndDiv(([], {}))

// Thumb32DataProcReg::thumb32DataProcReg(([], {}))

// Thumb32NeonSIMD::thumb32NeonSIMD(([], {}))

// Thumb32NeonSIMD::thumb32NeonSIMD(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// Gem5Op::gem5op(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::thumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// DecoderFault::decoderFault(([], {}))

// IllegalExec::illegalExec(([], {}))

// DebugStep::debugStep(([], {}))

#endif
