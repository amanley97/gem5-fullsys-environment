/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /home/a599m019/gem5-fullsys-enviroment/gem5/src/mem/slicc/symbols/StateMachine.py:1348
 */

// Created by slicc definition of Module "CHI Misc Node for handling and distrbuting DVM operations"

#include <sys/types.h>
#include <unistd.h>

#include <cassert>
#include <sstream>
#include <string>
#include <typeinfo>

#include "mem/ruby/common/BoolVec.hh"

#include "base/compiler.hh"
#include "base/cprintf.hh"

#include "debug/RubyGenerated.hh"
#include "debug/RubyProtocol.hh"
#include "debug/RubySlicc.hh"
#include "mem/ruby/network/Network.hh"
#include "mem/ruby/protocol/MiscNode_Controller.hh"
#include "mem/ruby/protocol/MiscNode_Event.hh"
#include "mem/ruby/protocol/MiscNode_State.hh"
#include "mem/ruby/protocol/Types.hh"
#include "mem/ruby/system/RubySystem.hh"

#include "mem/ruby/slicc_interface/RubySlicc_includes.hh"
#include "mem/ruby/protocol/MN_TBETable.hh"
#include "mem/ruby/protocol/TBEStorage.hh"
#include "mem/ruby/protocol/MN_TBEStorage.hh"
namespace gem5
{

namespace ruby
{

int MiscNode_Controller::m_num_controllers = 0;
std::vector<statistics::Vector *>  MiscNode_Controller::eventVec;
std::vector<std::vector<statistics::Vector *> >  MiscNode_Controller::transVec;

// for adding information to the protocol debug trace
std::stringstream MiscNode_transitionComment;

#ifndef NDEBUG
#define APPEND_TRANSITION_COMMENT(str) (MiscNode_transitionComment << str)
#else
#define APPEND_TRANSITION_COMMENT(str) do {} while (0)
#endif

/** \brief constructor */
MiscNode_Controller::MiscNode_Controller(const Params &p)
    : AbstractController(p)
{
    m_machineID.type = MachineType_MiscNode;
    m_machineID.num = m_version;
    m_num_controllers++;
    p.ruby_system->registerAbstractController(this);

    m_in_ports = 9;
    m_snp_latency = p.snp_latency;
    m_snp_inv_latency = p.snp_inv_latency;
    m_allocation_latency = p.allocation_latency;
    m_request_latency = p.request_latency;
    m_response_latency = p.response_latency;
    m_sched_response_latency = p.sched_response_latency;
    m_snoop_latency = p.snoop_latency;
    m_data_latency = p.data_latency;
    m_stall_recycle_lat = p.stall_recycle_lat;
    m_number_of_DVM_TBEs = p.number_of_DVM_TBEs;
    m_number_of_non_sync_TBEs = p.number_of_non_sync_TBEs;
    m_dealloc_wait_for_tag = p.dealloc_wait_for_tag;
    m_data_channel_size = p.data_channel_size;
    m_early_nonsync_comp = p.early_nonsync_comp;
    m_comp_wu_latency = p.comp_wu_latency;
    m_retry_ack_latency = p.retry_ack_latency;
    m_crd_grant_latency = p.crd_grant_latency;
    m_retry_req_latency = p.retry_req_latency;
    m_throttle_req_on_retry = p.throttle_req_on_retry;
    m_reqOut_ptr = p.reqOut;
    m_snpOut_ptr = p.snpOut;
    m_rspOut_ptr = p.rspOut;
    m_datOut_ptr = p.datOut;
    m_reqIn_ptr = p.reqIn;
    m_snpIn_ptr = p.snpIn;
    m_rspIn_ptr = p.rspIn;
    m_datIn_ptr = p.datIn;
    m_mandatoryQueue_ptr = p.mandatoryQueue;
    m_triggerQueue_ptr = p.triggerQueue;
    m_retryTriggerQueue_ptr = p.retryTriggerQueue;
    m_schedRspTriggerQueue_ptr = p.schedRspTriggerQueue;
    m_reqRdy_ptr = p.reqRdy;
    m_snpRdy_ptr = p.snpRdy;

    for (int state = 0; state < MiscNode_State_NUM; state++) {
        for (int event = 0; event < MiscNode_Event_NUM; event++) {
            m_possible[state][event] = false;
            m_counters[state][event] = 0;
        }
    }
    for (int event = 0; event < MiscNode_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }
}

void
MiscNode_Controller::initNetQueues()
{
    MachineType machine_type = string_to_MachineType("MiscNode");
    [[maybe_unused]] int base = MachineType_base_number(machine_type);

    assert(m_reqOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_reqOut_ptr->getOrdered(), 0,
                                     "none", m_reqOut_ptr);
    assert(m_snpOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_snpOut_ptr->getOrdered(), 1,
                                     "none", m_snpOut_ptr);
    assert(m_rspOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_rspOut_ptr->getOrdered(), 2,
                                     "none", m_rspOut_ptr);
    assert(m_datOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_datOut_ptr->getOrdered(), 3,
                                     "response", m_datOut_ptr);
    assert(m_reqIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_reqIn_ptr->getOrdered(), 0,
                                     "none", m_reqIn_ptr);
    assert(m_snpIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_snpIn_ptr->getOrdered(), 1,
                                     "none", m_snpIn_ptr);
    assert(m_rspIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_rspIn_ptr->getOrdered(), 2,
                                     "none", m_rspIn_ptr);
    assert(m_datIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_datIn_ptr->getOrdered(), 3,
                                     "response", m_datIn_ptr);
}

void
MiscNode_Controller::init()
{
    // initialize objects
    m_blockSize_ptr = new int;
    (*m_blockSize_ptr) = RubySystem::getBlockSizeBytes();
    m_dvmTBEs_ptr  = new MN_TBETable(m_number_of_DVM_TBEs);
    assert(m_dvmTBEs_ptr != NULL);
    m_nonSyncTBEs_ptr  = new TBEStorage(this, m_number_of_non_sync_TBEs);
    assert(m_nonSyncTBEs_ptr != NULL);
    m_genericTBEs_ptr  = new TBEStorage(this, (m_number_of_DVM_TBEs - m_number_of_non_sync_TBEs));
    assert(m_genericTBEs_ptr != NULL);
    m_storDvmTBEs_ptr  = new MN_TBEStorage<MiscNode_RetryQueueEntry>(this, {m_genericTBEs_ptr, m_nonSyncTBEs_ptr});
    assert(m_storDvmTBEs_ptr != NULL);
    m_currentDistributor_ptr = new Addr;
    (*m_currentDistributor_ptr) = 0;
    m_hasCurrentDistributor_ptr = new bool;
    (*m_hasCurrentDistributor_ptr) = false;
    m_needsToCheckPendingOps_ptr = new bool;
    (*m_needsToCheckPendingOps_ptr) = false;


    (*m_rspIn_ptr).setConsumer(this);
    (*m_datIn_ptr).setConsumer(this);
    (*m_snpIn_ptr).setConsumer(this);
    (*m_reqIn_ptr).setConsumer(this);
    (*m_mandatoryQueue_ptr).setConsumer(this);
    (*m_triggerQueue_ptr).setConsumer(this);
    (*m_reqRdy_ptr).setConsumer(this);
    (*m_retryTriggerQueue_ptr).setConsumer(this);
    (*m_schedRspTriggerQueue_ptr).setConsumer(this);

    possibleTransition(MiscNode_State_Unallocated, MiscNode_Event_AllocRequest);
    possibleTransition(MiscNode_State_Unallocated, MiscNode_Event_AllocRequestWithCredit);
    possibleTransition(MiscNode_State_Unallocated, MiscNode_Event_SendRetryAck);
    possibleTransition(MiscNode_State_Unallocated, MiscNode_Event_SendPCrdGrant);
    possibleTransition(MiscNode_State_Unallocated, MiscNode_Event_DvmTlbi_Initiate);
    possibleTransition(MiscNode_State_Unallocated, MiscNode_Event_DvmSync_Initiate);
    possibleTransition(MiscNode_State_DvmSync_Partial, MiscNode_Event_NCBWrData);
    possibleTransition(MiscNode_State_DvmNonSync_Partial, MiscNode_Event_NCBWrData);
    possibleTransition(MiscNode_State_DvmSync_ReadyToDist, MiscNode_Event_DvmSendNextMessage_P1);
    possibleTransition(MiscNode_State_DvmSync_Distributing, MiscNode_Event_DvmSendNextMessage_P1);
    possibleTransition(MiscNode_State_DvmSync_Distributing, MiscNode_Event_DvmSendNextMessage_P2);
    possibleTransition(MiscNode_State_DvmNonSync_ReadyToDist, MiscNode_Event_DvmSendNextMessage_P1);
    possibleTransition(MiscNode_State_DvmNonSync_Distributing, MiscNode_Event_DvmSendNextMessage_P1);
    possibleTransition(MiscNode_State_DvmNonSync_Distributing, MiscNode_Event_DvmSendNextMessage_P2);
    possibleTransition(MiscNode_State_DvmSync_Distributing, MiscNode_Event_DvmFinishDistributing);
    possibleTransition(MiscNode_State_DvmNonSync_Distributing, MiscNode_Event_DvmFinishDistributing);
    possibleTransition(MiscNode_State_DvmSync_Waiting, MiscNode_Event_DvmFinishWaiting);
    possibleTransition(MiscNode_State_DvmNonSync_Waiting, MiscNode_Event_DvmFinishWaiting);
    possibleTransition(MiscNode_State_DvmSync_Distributing, MiscNode_Event_SnpResp_I);
    possibleTransition(MiscNode_State_DvmNonSync_Distributing, MiscNode_Event_SnpResp_I);
    possibleTransition(MiscNode_State_DvmSync_Waiting, MiscNode_Event_SnpResp_I);
    possibleTransition(MiscNode_State_DvmNonSync_Waiting, MiscNode_Event_SnpResp_I);
    possibleTransition(MiscNode_State_DvmOp_Complete, MiscNode_Event_Final);
    AbstractController::init();
    resetStats();
}

Sequencer*
MiscNode_Controller::getCPUSequencer() const
{
    return NULL;
}

DMASequencer*
MiscNode_Controller::getDMASequencer() const
{
    return NULL;
}

GPUCoalescer*
MiscNode_Controller::getGPUCoalescer() const
{
    return NULL;
}

void
MiscNode_Controller::regStats()
{
    AbstractController::regStats();

    // For each type of controllers, one controller of that type is picked
    // to aggregate stats of all controllers of that type.
    if (m_version == 0) {

        Profiler *profiler = params().ruby_system->getProfiler();
        statistics::Group *profilerStatsPtr = &profiler->rubyProfilerStats;

        for (MiscNode_Event event = MiscNode_Event_FIRST;
             event < MiscNode_Event_NUM; ++event) {
            std::string stat_name =
                "MiscNode_Controller." + MiscNode_Event_to_string(event);
            statistics::Vector *t =
                new statistics::Vector(profilerStatsPtr, stat_name.c_str());
            t->init(m_num_controllers);
            t->flags(statistics::pdf | statistics::total |
                statistics::oneline | statistics::nozero);

            eventVec.push_back(t);
        }

        for (MiscNode_State state = MiscNode_State_FIRST;
             state < MiscNode_State_NUM; ++state) {

            transVec.push_back(std::vector<statistics::Vector *>());

            for (MiscNode_Event event = MiscNode_Event_FIRST;
                 event < MiscNode_Event_NUM; ++event) {
                std::string stat_name = "MiscNode_Controller." +
                    MiscNode_State_to_string(state) +
                    "." + MiscNode_Event_to_string(event);
                statistics::Vector *t = new statistics::Vector(
                    profilerStatsPtr, stat_name.c_str());
                t->init(m_num_controllers);
                t->flags(statistics::pdf | statistics::total |
                    statistics::oneline | statistics::nozero);
                transVec[state].push_back(t);
            }
        }
    }

    for (MiscNode_Event event = MiscNode_Event_FIRST;
                 event < MiscNode_Event_NUM; ++event) {
        std::string stat_name =
            "outTransLatHist." + MiscNode_Event_to_string(event);
        statistics::Histogram* t =
            new statistics::Histogram(&stats, stat_name.c_str());
        stats.outTransLatHist.push_back(t);
        t->init(5);
        t->flags(statistics::pdf | statistics::total |
                 statistics::oneline | statistics::nozero);

        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".retries").c_str());
        stats.outTransLatHistRetries.push_back(r);
        r->flags(statistics::nozero);
    }

    for (MiscNode_Event event = MiscNode_Event_FIRST;
                 event < MiscNode_Event_NUM; ++event) {
        std::string stat_name = "inTransLatHist." +
                                MiscNode_Event_to_string(event);
        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".total").c_str());
        stats.inTransLatTotal.push_back(r);
        r->flags(statistics::nozero);

        r = new statistics::Scalar(&stats,
                              (stat_name + ".retries").c_str());
        stats.inTransLatRetries.push_back(r);
        r->flags(statistics::nozero);

        stats.inTransLatHist.emplace_back();
        for (MiscNode_State initial_state = MiscNode_State_FIRST;
             initial_state < MiscNode_State_NUM; ++initial_state) {
            stats.inTransLatHist.back().emplace_back();
            for (MiscNode_State final_state = MiscNode_State_FIRST;
                 final_state < MiscNode_State_NUM; ++final_state) {
                std::string stat_name = "inTransLatHist." +
                    MiscNode_Event_to_string(event) + "." +
                    MiscNode_State_to_string(initial_state) + "." +
                    MiscNode_State_to_string(final_state);
                statistics::Histogram* t =
                    new statistics::Histogram(&stats, stat_name.c_str());
                stats.inTransLatHist.back().back().push_back(t);
                t->init(5);
                t->flags(statistics::pdf | statistics::total |
                         statistics::oneline | statistics::nozero);
            }
        }
    }
}

void
MiscNode_Controller::collateStats()
{
    for (MiscNode_Event event = MiscNode_Event_FIRST;
         event < MiscNode_Event_NUM; ++event) {
        for (unsigned int i = 0; i < m_num_controllers; ++i) {
            RubySystem *rs = params().ruby_system;
            std::map<uint32_t, AbstractController *>::iterator it =
                     rs->m_abstract_controls[MachineType_MiscNode].find(i);
            assert(it != rs->m_abstract_controls[MachineType_MiscNode].end());
            (*eventVec[event])[i] =
                ((MiscNode_Controller *)(*it).second)->getEventCount(event);
        }
    }

    for (MiscNode_State state = MiscNode_State_FIRST;
         state < MiscNode_State_NUM; ++state) {

        for (MiscNode_Event event = MiscNode_Event_FIRST;
             event < MiscNode_Event_NUM; ++event) {

            for (unsigned int i = 0; i < m_num_controllers; ++i) {
                RubySystem *rs = params().ruby_system;
                std::map<uint32_t, AbstractController *>::iterator it =
                         rs->m_abstract_controls[MachineType_MiscNode].find(i);
                assert(it != rs->m_abstract_controls[MachineType_MiscNode].end());
                (*transVec[state][event])[i] =
                    ((MiscNode_Controller *)(*it).second)->getTransitionCount(state, event);
            }
        }
    }
}

void
MiscNode_Controller::countTransition(MiscNode_State state, MiscNode_Event event)
{
    assert(m_possible[state][event]);
    m_counters[state][event]++;
    m_event_counters[event]++;
}
void
MiscNode_Controller::possibleTransition(MiscNode_State state,
                             MiscNode_Event event)
{
    m_possible[state][event] = true;
}

uint64_t
MiscNode_Controller::getEventCount(MiscNode_Event event)
{
    return m_event_counters[event];
}

bool
MiscNode_Controller::isPossible(MiscNode_State state, MiscNode_Event event)
{
    return m_possible[state][event];
}

uint64_t
MiscNode_Controller::getTransitionCount(MiscNode_State state,
                             MiscNode_Event event)
{
    return m_counters[state][event];
}

int
MiscNode_Controller::getNumControllers()
{
    return m_num_controllers;
}

MessageBuffer*
MiscNode_Controller::getMandatoryQueue() const
{
    return m_mandatoryQueue_ptr;
}

MessageBuffer*
MiscNode_Controller::getMemReqQueue() const
{
    return NULL;
}

MessageBuffer*
MiscNode_Controller::getMemRespQueue() const
{
    return NULL;
}

void
MiscNode_Controller::print(std::ostream& out) const
{
    out << "[MiscNode_Controller " << m_version << "]";
}

void MiscNode_Controller::resetStats()
{
    for (int state = 0; state < MiscNode_State_NUM; state++) {
        for (int event = 0; event < MiscNode_Event_NUM; event++) {
            m_counters[state][event] = 0;
        }
    }

    for (int event = 0; event < MiscNode_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }

    AbstractController::resetStats();
}

// Set and Reset for tbe variable
void
MiscNode_Controller::set_tbe(MiscNode_TBE*& m_tbe_ptr, MiscNode_TBE* m_new_tbe)
{
  m_tbe_ptr = m_new_tbe;
}

void
MiscNode_Controller::unset_tbe(MiscNode_TBE*& m_tbe_ptr)
{
  m_tbe_ptr = NULL;
}

void
MiscNode_Controller::recordCacheTrace(int cntrl, CacheRecorder* tr)
{
}

// Actions
/** \brief  */
void
MiscNode_Controller::AllocateTBE_Request(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Request\n");
    {
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!(((*in_msg_ptr)).m_usesTxnId)) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:45: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_txnId == addr))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:46: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_is_local_pf == (false)))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:47: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*in_msg_ptr)).m_allowRetry)) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:48: %s.\n", "assert failure");

}
#endif
;
bool isNonSync
 = (((*in_msg_ptr)).m_type == CHIRequestType_DvmOpNonSync);
    if ((((*m_storDvmTBEs_ptr)).areNSlotsAvailable((1), (tbePartition(isNonSync))))) {
        (((*m_storDvmTBEs_ptr)).incrementReserved((tbePartition(isNonSync))));
        {
            // Declare message
            [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            *out_msg = (*in_msg_ptr);
            ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
        }
        }
    } else {
        {
            std::shared_ptr<MiscNode_RetryTriggerMsg> out_msg = std::make_shared<MiscNode_RetryTriggerMsg>(clockEdge());
            (*out_msg).m_txnId = ((*in_msg_ptr)).m_txnId;
            (*out_msg).m_event = MiscNode_Event_SendRetryAck;
            (*out_msg).m_retryDest = ((*in_msg_ptr)).m_requestor;
            MiscNode_RetryQueueEntry en;
            (en).m_txnId = ((*in_msg_ptr)).m_txnId;
            (en).m_retryDest = ((*in_msg_ptr)).m_requestor;
            (en).m_isNonSync = isNonSync;
            (((*m_storDvmTBEs_ptr)).emplaceRetryEntry(en));
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_retry_ack_latency)));
        }
    }
    }
    (((*m_reqIn_ptr)).dequeue((clockEdge())));

}

/** \brief  */
void
MiscNode_Controller::AllocateTBE_Request_WithCredit(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Request_WithCredit\n");
    {
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_allowRetry == (false)))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:87: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*in_msg_ptr)).m_usesTxnId)) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:88: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_txnId == addr))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:90: %s.\n", "assert failure");

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
}
}
(((*m_reqIn_ptr)).dequeue((clockEdge())));

}

/** \brief  */
void
MiscNode_Controller::Initiate_Request_DVM(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request_DVM\n");
    bool was_retried
 = (false);
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
MiscNode_TBE* tbe
 = (allocateDvmRequestTBE(addr, (*in_msg_ptr)));
set_tbe(m_tbe_ptr, tbe);;
was_retried = (((*in_msg_ptr)).m_allowRetry == (false));
}
(incomingTransactionStart(addr, (curTransitionEvent()), MiscNode_State_Unallocated, was_retried, (false)));

}

/** \brief  */
void
MiscNode_Controller::Pop_ReqRdyQueue(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_ReqRdyQueue\n");
    (((*m_reqRdy_ptr)).dequeue((clockEdge())));

}

/** \brief  */
void
MiscNode_Controller::Receive_ReqDataResp(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqDataResp\n");
    #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:117: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:118: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveData(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:122: %s.\n", ("Received unexpected message"));
        ;
    }
    #ifndef NDEBUG
    if (!((! (((*m_tbe_ptr).m_expected_req_resp).hasExpected())))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:124: %s.\n", "assert failure");

    }
    #endif
    ;
    DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:126: Misc Node has receieved NCBWrData\n");
    (((*m_tbe_ptr).m_expected_snp_resp).clear((1)));
    #ifndef NDEBUG
    if (!((! (((*m_tbe_ptr).m_expected_snp_resp).hasExpected())))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:129: %s.\n", "assert failure");

    }
    #endif
    ;
    }

}

/** \brief  */
void
MiscNode_Controller::Pop_DataInQueue(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_DataInQueue\n");
    (((*m_datIn_ptr)).dequeue((clockEdge())));

}

/** \brief  */
void
MiscNode_Controller::Receive_SnpResp(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_SnpResp\n");
    #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:140: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_snp_resp).receiveResp(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:144: %s.\n", ("Received unexpected message"));
        ;
    }
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_stale == (false)))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:146: %s.\n", "assert failure");

    }
    #endif
    ;
    DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:149: Misc Node has receieved SnpResp_I\n");
    #ifndef NDEBUG
    if (!((((*m_tbe_ptr).m_pendingTargets).isElement(((*in_msg_ptr)).m_responder)))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:151: %s.\n", "assert failure");

    }
    #endif
    ;
    (((*m_tbe_ptr).m_pendingTargets).remove(((*in_msg_ptr)).m_responder));
    (((*m_tbe_ptr).m_receivedTargets).add(((*in_msg_ptr)).m_responder));
    }

}

/** \brief  */
void
MiscNode_Controller::Pop_RespInQueue(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_RespInQueue\n");
    (((*m_rspIn_ptr)).dequeue((clockEdge())));

}

/** \brief  */
void
MiscNode_Controller::ProcessNextState(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ProcessNextState\n");
    #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:161: %s.\n", "assert failure");

}
#endif
;
(processNextState(m_tbe_ptr));

}

/** \brief  */
void
MiscNode_Controller::ProcessNextState_ClearPending(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ProcessNextState_ClearPending\n");
    #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:170: %s.\n", "assert failure");

}
#endif
;
(clearPendingAction(m_tbe_ptr));
(processNextState(m_tbe_ptr));

}

/** \brief  */
void
MiscNode_Controller::Send_Comp(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Comp\n");
    #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:176: %s.\n", "assert failure");

}
#endif
;
Cycles latency
 = m_response_latency;
CHIResponseType type
 = CHIResponseType_Comp;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = type;
    (*out_msg).m_responder = m_machineID;
    (*out_msg).m_txnId = addr;
    (*out_msg).m_usesTxnId = (true);
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(latency)));
}
DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:188: Misc Node Sending Comp (for either)\n");

}

/** \brief  */
void
MiscNode_Controller::Send_Comp_NonSync(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Comp_NonSync\n");
    #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:192: %s.\n", "assert failure");

}
#endif
;
    if ((! m_early_nonsync_comp)) {
        Cycles latency
         = m_response_latency;
        CHIResponseType type
         = CHIResponseType_Comp;
        {
            std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
            (*out_msg).m_addr = addr;
            (*out_msg).m_type = type;
            (*out_msg).m_responder = m_machineID;
            (*out_msg).m_txnId = addr;
            (*out_msg).m_usesTxnId = (true);
            (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
            ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(latency)));
        }
        DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:209: Misc Node Sending TLBI Comp\n");
    }

}

/** \brief  */
void
MiscNode_Controller::Pop_TriggerQueue(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_TriggerQueue\n");
    (((*m_triggerQueue_ptr)).dequeue((clockEdge())));

}

/** \brief  */
void
MiscNode_Controller::Pop_RetryTriggerQueue(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_RetryTriggerQueue\n");
    (((*m_retryTriggerQueue_ptr)).dequeue((clockEdge())));

}

/** \brief  */
void
MiscNode_Controller::Finalize_DeallocateRequest(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_DeallocateRequest\n");
    #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:225: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:226: %s.\n", "assert failure");

}
#endif
;
(wakeupPendingReqs(m_tbe_ptr));
(wakeupPendingTgrs(m_tbe_ptr));
DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:230: Deallocating DVM request\n");
(deallocateDvmTBE(m_tbe_ptr));
(processRetryQueue());
unset_tbe(m_tbe_ptr);;
(incomingTransactionEnd(addr, (curTransitionNextState()), (false)));

}

/** \brief  */
void
MiscNode_Controller::Send_DvmNonSyncDBIDResp(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmNonSyncDBIDResp\n");
    Cycles latency
 = m_response_latency;
CHIResponseType type
 = CHIResponseType_DBIDResp;
    if (m_early_nonsync_comp) {
        type = CHIResponseType_CompDBIDResp;
    }
    {
        std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
        (*out_msg).m_addr = addr;
        (*out_msg).m_type = type;
        (*out_msg).m_responder = m_machineID;
        (*out_msg).m_txnId = addr;
        (*out_msg).m_usesTxnId = (true);
        (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
        ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(latency)));
    }
    (((*m_tbe_ptr).m_expected_req_resp).clear((1)));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_NCBWrData));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
    DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:256: Misc Node Sending TLBI DBIDResp\n");

}

/** \brief  */
void
MiscNode_Controller::Send_DvmSyncDBIDResp(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmSyncDBIDResp\n");
    Cycles latency
 = m_response_latency;
CHIResponseType type
 = CHIResponseType_DBIDResp;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = type;
    (*out_msg).m_responder = m_machineID;
    (*out_msg).m_txnId = addr;
    (*out_msg).m_usesTxnId = (true);
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(latency)));
}
(((*m_tbe_ptr).m_expected_req_resp).clear((1)));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_NCBWrData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:273: Misc Node Sending Sync DBIDResp\n");

}

/** \brief  */
void
MiscNode_Controller::Send_RetryAck(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_RetryAck\n");
    {
    // Declare message
    [[maybe_unused]] const MiscNode_RetryTriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const MiscNode_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_txnId = ((*in_msg_ptr)).m_txnId;
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_type = CHIResponseType_RetryAck;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_retryDest));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}
DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:285: Misc Node Sending RetryAck (for either)\n");
}

}

/** \brief  */
void
MiscNode_Controller::Send_PCrdGrant(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_PCrdGrant\n");
    {
    // Declare message
    [[maybe_unused]] const MiscNode_RetryTriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const MiscNode_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_txnId = ((*in_msg_ptr)).m_txnId;
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_type = CHIResponseType_PCrdGrant;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_retryDest));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}
DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:298: Misc Node Sending PCrdGrant (for either)\n");
}

}

/** \brief  */
void
MiscNode_Controller::Send_DvmSnoop_P1(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmSnoop_P1\n");
    Cycles latency
 = m_response_latency;
CHIRequestType type
 = CHIRequestType_SnpDvmOpSync_P1;
    if ((*m_tbe_ptr).m_isNonSync) {
        type = CHIRequestType_SnpDvmOpNonSync_P1;
    }
    #ifndef NDEBUG
    if (!(((((*m_tbe_ptr).m_notSentTargets).count()) > (0)))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:310: %s.\n", "assert failure");

    }
    #endif
    ;
    MachineID target
     = (((*m_tbe_ptr).m_notSentTargets).smallestElement());
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        (prepareRequest(m_tbe_ptr, type, *out_msg));
        DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:315: Misc Node Sending %d to %d\n", type, target);
        (*out_msg).m_usesTxnId = (true);
        (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
        (*out_msg).m_allowRetry = (false);
        (((*out_msg).m_Destination).clear());
        (((*out_msg).m_Destination).add(target));
        (*out_msg).m_dataToFwdRequestor = (false);
        ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(latency)));
    }
    (((*m_tbe_ptr).m_actions).pushNB(MiscNode_Event_DvmSendNextMessage_P2));
    (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((intToCycles((1))))));
    (*m_tbe_ptr).m_waiting_on_other_txns = (false);

}

/** \brief  */
void
MiscNode_Controller::Send_DvmSnoop_P2(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmSnoop_P2\n");
    Cycles latency
 = m_response_latency;
CHIRequestType type
 = CHIRequestType_SnpDvmOpSync_P2;
    if ((*m_tbe_ptr).m_isNonSync) {
        type = CHIRequestType_SnpDvmOpNonSync_P2;
    }
    #ifndef NDEBUG
    if (!(((((*m_tbe_ptr).m_notSentTargets).count()) > (0)))) {
        panic("Runtime Error at CHI-dvm-misc-node-actions.sm:341: %s.\n", "assert failure");

    }
    #endif
    ;
    MachineID target
     = (((*m_tbe_ptr).m_notSentTargets).smallestElement());
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        (prepareRequest(m_tbe_ptr, type, *out_msg));
        DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:346: Misc Node Sending %d to %d\n", type, target);
        (*out_msg).m_usesTxnId = (true);
        (*out_msg).m_txnId = (*m_tbe_ptr).m_txnId;
        (*out_msg).m_allowRetry = (false);
        (((*out_msg).m_Destination).clear());
        (((*out_msg).m_Destination).add(target));
        (*out_msg).m_dataToFwdRequestor = (false);
        ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(latency)));
    }
    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I));
    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
    (((*m_tbe_ptr).m_notSentTargets).remove(target));
    (((*m_tbe_ptr).m_pendingTargets).add(target));
        if (((((*m_tbe_ptr).m_notSentTargets).count()) > (0))) {
            (((*m_tbe_ptr).m_actions).pushNB(MiscNode_Event_DvmSendNextMessage_P1));
        } else {
            (((*m_tbe_ptr).m_actions).pushNB(MiscNode_Event_DvmFinishDistributing));
            (((*m_tbe_ptr).m_actions).push(MiscNode_Event_DvmFinishWaiting));
        }
        (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((intToCycles((1))))));

}

/** \brief  */
void
MiscNode_Controller::Enqueue_UpdatePendingOps(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Enqueue_UpdatePendingOps\n");
    DPRINTF(RubyProtocol, "CHI-dvm-misc-node-actions.sm:381: Enqueue_UpdatePendingOps from %016x\n", addr);
(*m_needsToCheckPendingOps_ptr) = (true);
(scheduleEvent((intToCycles((1)))));

}

/** \brief  */
void
MiscNode_Controller::Profile_OutgoingEnd_DVM(MiscNode_TBE*& m_tbe_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DVM\n");
    #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-actions.sm:389: %s.\n", "assert failure");

}
#endif
;
bool rcvdRetryAck
 = (false);
(outgoingTransactionEnd(addr, rcvdRetryAck, (false)));

}

void
MiscNode_Controller::notifyPfHit(const RequestPtr& param_req, const bool& param_is_read, const DataBlock& param_blk)
{

}
void
MiscNode_Controller::notifyPfMiss(const RequestPtr& param_req, const bool& param_is_read, const DataBlock& param_blk)
{

}
void
MiscNode_Controller::notifyPfFill(const RequestPtr& param_req, const DataBlock& param_blk, const bool& param_from_pf)
{

}
void
MiscNode_Controller::notifyPfEvict(const Addr& param_blkAddr, const bool& param_hwPrefetched)
{

}
void
MiscNode_Controller::notifyPfComplete(const Addr& param_addr)
{

}
int
MiscNode_Controller::tbePartition(const bool& param_is_non_sync)
{
    if (param_is_non_sync) {
        return (1);
    } else {
        return (0);
    }

}
MiscNode_State
MiscNode_Controller::getState(MiscNode_TBE* param_tbe, const Addr& param_txnId)
{
    if ((param_tbe != NULL)) {
        return (*param_tbe).m_state;
    } else {
        return MiscNode_State_Unallocated;
    }

}
void
MiscNode_Controller::setState(MiscNode_TBE* param_tbe, const Addr& param_txnId, const MiscNode_State& param_state)
{
    if ((param_tbe != NULL)) {
        (*param_tbe).m_state = param_state;
    }

}
MiscNode_TBE*
MiscNode_Controller::nullTBE()
{
return NULL;

}
MiscNode_TBE*
MiscNode_Controller::getCurrentActiveTBE(const Addr& param_txnId)
{
return (((*m_dvmTBEs_ptr)).lookup(param_txnId));

}
AccessPermission
MiscNode_Controller::getAccessPermission(const Addr& param_txnId)
{
return AccessPermission_NotPresent;

}
void
MiscNode_Controller::setAccessPermission(const Addr& param_txnId, const MiscNode_State& param_state)
{

}
void
MiscNode_Controller::functionalRead(const Addr& param_txnId, Packet* param_pkt, WriteMask& param_mask)
{

}
int
MiscNode_Controller::functionalWrite(const Addr& param_txnId, Packet* param_pkt)
{
return (0);

}
Cycles
MiscNode_Controller::mandatoryQueueLatency(const RubyRequestType& param_type)
{
return (intToCycles((1)));

}
Cycles
MiscNode_Controller::tagLatency(const bool& param_from_sequencer)
{
return (intToCycles((0)));

}
Cycles
MiscNode_Controller::dataLatency()
{
return (intToCycles((0)));

}
bool
MiscNode_Controller::inCache(const Addr& param_txnId)
{
return (false);

}
bool
MiscNode_Controller::hasBeenPrefetched(const Addr& param_txnId)
{
return (false);

}
bool
MiscNode_Controller::inMissQueue(const Addr& param_txnId)
{
return (false);

}
void
MiscNode_Controller::notifyCoalesced(const Addr& param_txnId, const RubyRequestType& param_type, const RequestPtr& param_req, const DataBlock& param_data_blk, const bool& param_was_miss)
{
DPRINTF(RubySlicc, "CHI-dvm-misc-node-funcs.sm:154: Unused notifyCoalesced(txnId=%#x, type=%s, was_miss=%d)\n", param_txnId, param_type, param_was_miss);

}
MiscNode_Event
MiscNode_Controller::reqToEvent(const CHIRequestType& param_type)
{
    if ((param_type == CHIRequestType_DvmOpNonSync)) {
        return MiscNode_Event_DvmTlbi_Initiate;
    } else {
            if ((param_type == CHIRequestType_DvmOpSync)) {
                return MiscNode_Event_DvmSync_Initiate;
            } else {
                panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:167: %s.\n", ("Invalid/unexpected CHIRequestType"));
                ;
            }
        }

}
MiscNode_Event
MiscNode_Controller::respToEvent(const CHIResponseType& param_type)
{
    if ((param_type == CHIResponseType_SnpResp_I)) {
        return MiscNode_Event_SnpResp_I;
    } else {
        panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:175: %s.\n", ("Invalid/unexpected CHIResponseType"));
        ;
    }

}
MiscNode_Event
MiscNode_Controller::dataToEvent(const CHIDataType& param_type)
{
    if ((param_type == CHIDataType_NCBWrData)) {
        return MiscNode_Event_NCBWrData;
    } else {
        panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:183: %s.\n", ("Invalid/unexpected CHIDataType"));
        ;
    }

}
void
MiscNode_Controller::clearExpectedReqResp(MiscNode_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:191: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:192: %s.\n", "assert failure");

}
#endif
;
(((*param_tbe).m_expected_req_resp).clear(((*m_blockSize_ptr) / m_data_channel_size)));

}
void
MiscNode_Controller::clearExpectedSnpResp(MiscNode_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:197: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:198: %s.\n", "assert failure");

}
#endif
;
(((*param_tbe).m_expected_snp_resp).clear(((*m_blockSize_ptr) / m_data_channel_size)));

}
void
MiscNode_Controller::initializeTBE(MiscNode_TBE* param_tbe, const Addr& param_txnId, const int& param_storSlot)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:203: %s.\n", "assert failure");

}
#endif
;
(*param_tbe).m_timestamp = (curTick());
(*param_tbe).m_wakeup_pending_req = (false);
(*param_tbe).m_wakeup_pending_snp = (false);
(*param_tbe).m_wakeup_pending_tgr = (false);
(*param_tbe).m_txnId = param_txnId;
(*param_tbe).m_storSlot = param_storSlot;
(clearExpectedReqResp(param_tbe));
(clearExpectedSnpResp(param_tbe));
(*param_tbe).m_waiting_on_other_txns = (true);
(*param_tbe).m_sched_responses = (0);
(*param_tbe).m_block_on_sched_responses = (false);
(*param_tbe).m_pendAction = MiscNode_Event_null;
(*param_tbe).m_finalState = MiscNode_State_null;
(*param_tbe).m_delayNextAction = (intToTick((0)));
(*param_tbe).m_notSentTargets = (allUpstreamDest());
(((*param_tbe).m_pendingTargets).clear());
(((*param_tbe).m_receivedTargets).clear());

}
MiscNode_TBE*
MiscNode_Controller::allocateDvmRequestTBE(const Addr& param_txnId, const CHIRequestMsg& param_in_msg)
{
DPRINTF(RubySlicc, "CHI-dvm-misc-node-funcs.sm:237: allocateDvmRequestTBE %x %016llx\n", (param_in_msg).m_type, param_txnId);
bool isNonSync
 = ((param_in_msg).m_type == CHIRequestType_DvmOpNonSync);
int partition
 = (tbePartition(isNonSync));
(((*m_storDvmTBEs_ptr)).decrementReserved(partition));
#ifndef NDEBUG
if (!((((*m_storDvmTBEs_ptr)).areNSlotsAvailable((1), partition)))) {
    panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:244: %s.\n", "assert failure");

}
#endif
;
(((*m_dvmTBEs_ptr)).allocate(param_txnId));
MiscNode_TBE* tbe
 = (((*m_dvmTBEs_ptr)).lookup(param_txnId));
(initializeTBE(tbe, param_txnId, (((*m_storDvmTBEs_ptr)).addEntryToNewSlot(partition))));
(*tbe).m_isNonSync = isNonSync;
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(((*tbe).m_notSentTargets).remove((param_in_msg).m_requestor));
return tbe;

}
void
MiscNode_Controller::deallocateDvmTBE(MiscNode_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-funcs.sm:265: %s.\n", "assert failure");

}
#endif
;
(((*m_storDvmTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot, (tbePartition((*param_tbe).m_isNonSync))));
(((*m_dvmTBEs_ptr)).deallocate((*param_tbe).m_txnId));

}
void
MiscNode_Controller::clearPendingAction(MiscNode_TBE* param_tbe)
{
(*param_tbe).m_pendAction = MiscNode_Event_null;

}
void
MiscNode_Controller::processRetryQueue()
{
    if ((((*m_storDvmTBEs_ptr)).hasPossibleRetry())) {
        MiscNode_RetryQueueEntry toRetry
         = (((*m_storDvmTBEs_ptr)).popNextRetryEntry());
        (((*m_storDvmTBEs_ptr)).incrementReserved((tbePartition((toRetry).m_isNonSync))));
        {
            std::shared_ptr<MiscNode_RetryTriggerMsg> out_msg = std::make_shared<MiscNode_RetryTriggerMsg>(clockEdge());
            (*out_msg).m_txnId = (toRetry).m_txnId;
            (*out_msg).m_retryDest = (toRetry).m_retryDest;
            (*out_msg).m_event = MiscNode_Event_SendPCrdGrant;
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_crd_grant_latency)));
        }
    }

}
void
MiscNode_Controller::printResources()
{
DPRINTF(RubySlicc, "CHI-dvm-misc-node-funcs.sm:296: Resources(used/rsvd/max): dvmTBEs=%d/%d/%d\n", (((*m_storDvmTBEs_ptr)).size()), (((*m_storDvmTBEs_ptr)).reserved()), (((*m_storDvmTBEs_ptr)).capacity()));
DPRINTF(RubySlicc, "CHI-dvm-misc-node-funcs.sm:298: Resources(in/out size): req=%d/%d rsp=%d/%d dat=%d/%d snp=%d/%d trigger=%d\n", (((*m_reqIn_ptr)).getSize((curTick()))), (((*m_reqOut_ptr)).getSize((curTick()))), (((*m_rspIn_ptr)).getSize((curTick()))), (((*m_rspOut_ptr)).getSize((curTick()))), (((*m_datIn_ptr)).getSize((curTick()))), (((*m_datOut_ptr)).getSize((curTick()))), (((*m_snpIn_ptr)).getSize((curTick()))), (((*m_snpOut_ptr)).getSize((curTick()))), (((*m_triggerQueue_ptr)).getSize((curTick()))));

}
void
MiscNode_Controller::printTBEState(MiscNode_TBE* param_tbe)
{
DPRINTF(RubySlicc, "CHI-dvm-misc-node-funcs.sm:307: STATE: txnId=%#x reqType=%d state=%d pendAction=%s\n", (*param_tbe).m_txnId, (*param_tbe).m_reqType, (*param_tbe).m_state, (*param_tbe).m_pendAction);

}
void
MiscNode_Controller::prepareRequest(MiscNode_TBE* param_tbe, const CHIRequestType& param_type, CHIRequestMsg& param_out_msg)
{
(param_out_msg).m_addr = (*param_tbe).m_txnId;
(param_out_msg).m_accAddr = (*param_tbe).m_txnId;
(param_out_msg).m_accSize = (*m_blockSize_ptr);
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_type = param_type;
(param_out_msg).m_allowRetry = (false);
(param_out_msg).m_isSeqReqValid = (false);
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = (false);

}
bool
MiscNode_Controller::rspInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-dvm-misc-node-ports.sm:79: %s.\n", ("rspInPort must never stall\n"));
;
return (false);

}
bool
MiscNode_Controller::datInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-dvm-misc-node-ports.sm:97: %s.\n", ("datInPort must never stall\n"));
;
return (false);

}
bool
MiscNode_Controller::snpInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-dvm-misc-node-ports.sm:111: %s.\n", ("snpInPort must never stall\n"));
;
return (false);

}
bool
MiscNode_Controller::reqInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-dvm-misc-node-ports.sm:133: %s.\n", ("reqInPort must never stall\n"));
;
return (false);

}
bool
MiscNode_Controller::triggerInPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-dvm-misc-node-ports.sm:163: Trigger queue resource stall\n");
(((*m_triggerQueue_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
void
MiscNode_Controller::wakeupPendingTgrs(MiscNode_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_tgr) {
        Addr txnId
         = (*param_tbe).m_txnId;
                wakeUpBuffer(&((*m_triggerQueue_ptr)), txnId);
                
        (*param_tbe).m_wakeup_pending_tgr = (false);
    }

}
bool
MiscNode_Controller::reqRdyPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-dvm-misc-node-ports.sm:190: ReqRdy queue resource stall\n");
(((*m_reqRdy_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
void
MiscNode_Controller::wakeupPendingReqs(MiscNode_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_req) {
        Addr txnId
         = (*param_tbe).m_txnId;
                wakeUpBuffer(&((*m_reqRdy_ptr)), txnId);
                
        (*param_tbe).m_wakeup_pending_req = (false);
    }

}
void
MiscNode_Controller::processNextState(MiscNode_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-dvm-misc-node-ports.sm:231: %s.\n", "assert failure");

}
#endif
;
DPRINTF(RubyProtocol, "CHI-dvm-misc-node-ports.sm:232: GoToNextState state=%d expected_req_resp=%d expected_snp_resp=%d sched_rsp=%d(block=%d) pendAction: %d\n", (*param_tbe).m_state, (((*param_tbe).m_expected_req_resp).expected()), (((*param_tbe).m_expected_snp_resp).expected()), (*param_tbe).m_sched_responses, (*param_tbe).m_block_on_sched_responses, (*param_tbe).m_pendAction);
bool has_nb_trigger
 = (((((*param_tbe).m_actions).empty()) == (false)) && (((*param_tbe).m_actions).frontNB()));
int expected_msgs
 = ((((*param_tbe).m_expected_req_resp).expected()) + (((*param_tbe).m_expected_snp_resp).expected()));
    if ((*param_tbe).m_block_on_sched_responses) {
        expected_msgs = (expected_msgs + (*param_tbe).m_sched_responses);
        (*param_tbe).m_block_on_sched_responses = ((*param_tbe).m_sched_responses > (0));
    }
    bool would_enqueue_final
     = (((*param_tbe).m_actions).empty());
    bool allowed_to_enqueue_final
     = (! (*param_tbe).m_waiting_on_other_txns);
    bool allowed_to_enqueue_action
     = ((! would_enqueue_final) || allowed_to_enqueue_final);
        if (((((*param_tbe).m_pendAction == MiscNode_Event_null) && ((expected_msgs == (0)) || has_nb_trigger)) && allowed_to_enqueue_action)) {
            Cycles trigger_latency
             = (intToCycles((0)));
                if (((*param_tbe).m_delayNextAction > (curTick()))) {
                    trigger_latency = ((ticksToCycles((*param_tbe).m_delayNextAction)) - (ticksToCycles((curTick()))));
                    (*param_tbe).m_delayNextAction = (intToTick((0)));
                }
                (*param_tbe).m_pendAction = MiscNode_Event_null;
                    if ((((*param_tbe).m_actions).empty())) {
                        (*param_tbe).m_pendAction = MiscNode_Event_Final;
                    } else {
                        (*param_tbe).m_pendAction = (((*param_tbe).m_actions).front());
                        (((*param_tbe).m_actions).pop());
                    }
                    #ifndef NDEBUG
                    if (!(((*param_tbe).m_pendAction != MiscNode_Event_null))) {
                        panic("Runtime Error at CHI-dvm-misc-node-ports.sm:275: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                    {
                        std::shared_ptr<MiscNode_TriggerMsg> out_msg = std::make_shared<MiscNode_TriggerMsg>(clockEdge());
                        (*out_msg).m_txnId = (*param_tbe).m_txnId;
                        (*out_msg).m_from_hazard = (false);
                        ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(trigger_latency)));
                    }
                }
                (printTBEState(param_tbe));

}
void
MiscNode_Controller::updatePendingOps()
{
    if ((*m_needsToCheckPendingOps_ptr)) {
        (*m_needsToCheckPendingOps_ptr) = (false);
        DPRINTF(RubyProtocol, "CHI-dvm-misc-node-ports.sm:292: Misc Node updating pending ops\n");
        MiscNode_TBE* newDistributor
         = (((*m_dvmTBEs_ptr)).chooseNewDistributor());
        DPRINTF(RubyProtocol, "CHI-dvm-misc-node-ports.sm:294: Misc Node selected %p\n", newDistributor);
            if ((newDistributor != NULL)) {
                    if (((! (*m_hasCurrentDistributor_ptr)) || ((*newDistributor).m_txnId != (*m_currentDistributor_ptr)))) {
                        (*m_currentDistributor_ptr) = (*newDistributor).m_txnId;
                        (*m_hasCurrentDistributor_ptr) = (true);
                        (((*newDistributor).m_actions).pushNB(MiscNode_Event_DvmSendNextMessage_P1));
                        (processNextState(newDistributor));
                        MiscNode_Event usefulEvent
                         = MiscNode_Event_DvmSync_Initiate;
                            if ((*newDistributor).m_isNonSync) {
                                usefulEvent = MiscNode_Event_DvmTlbi_Initiate;
                            }
                            (outgoingTransactionStart((*newDistributor).m_txnId, usefulEvent, (false)));
                        }
                    }
                }

}
int
MiscNode_Controller::functionalWriteBuffers(PacketPtr& pkt)
{
    int num_functional_writes = 0;
num_functional_writes += m_reqOut_ptr->functionalWrite(pkt);
num_functional_writes += m_snpOut_ptr->functionalWrite(pkt);
num_functional_writes += m_rspOut_ptr->functionalWrite(pkt);
num_functional_writes += m_datOut_ptr->functionalWrite(pkt);
num_functional_writes += m_reqIn_ptr->functionalWrite(pkt);
num_functional_writes += m_snpIn_ptr->functionalWrite(pkt);
num_functional_writes += m_rspIn_ptr->functionalWrite(pkt);
num_functional_writes += m_datIn_ptr->functionalWrite(pkt);
num_functional_writes += m_mandatoryQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_triggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_retryTriggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_schedRspTriggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_reqRdy_ptr->functionalWrite(pkt);
num_functional_writes += m_snpRdy_ptr->functionalWrite(pkt);
    return num_functional_writes;
}
bool
MiscNode_Controller::functionalReadBuffers(PacketPtr& pkt)
{
if (m_reqOut_ptr->functionalRead(pkt)) return true;
if (m_snpOut_ptr->functionalRead(pkt)) return true;
if (m_rspOut_ptr->functionalRead(pkt)) return true;
if (m_datOut_ptr->functionalRead(pkt)) return true;
if (m_reqIn_ptr->functionalRead(pkt)) return true;
if (m_snpIn_ptr->functionalRead(pkt)) return true;
if (m_rspIn_ptr->functionalRead(pkt)) return true;
if (m_datIn_ptr->functionalRead(pkt)) return true;
if (m_mandatoryQueue_ptr->functionalRead(pkt)) return true;
if (m_triggerQueue_ptr->functionalRead(pkt)) return true;
if (m_retryTriggerQueue_ptr->functionalRead(pkt)) return true;
if (m_schedRspTriggerQueue_ptr->functionalRead(pkt)) return true;
if (m_reqRdy_ptr->functionalRead(pkt)) return true;
if (m_snpRdy_ptr->functionalRead(pkt)) return true;
    return false;
}

bool
MiscNode_Controller::functionalReadBuffers(PacketPtr& pkt, WriteMask &mask)
{
    bool read = false;
if (m_reqOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_rspOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_datOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_reqIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_rspIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_datIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_mandatoryQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_triggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_retryTriggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_schedRspTriggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_reqRdy_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpRdy_ptr->functionalRead(pkt, mask)) read = true;
    return read;
}

} // namespace ruby
} // namespace gem5
