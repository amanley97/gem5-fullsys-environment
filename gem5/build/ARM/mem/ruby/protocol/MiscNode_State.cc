/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /home/a599m019/gem5-fullsys-enviroment/gem5/src/mem/slicc/symbols/Type.py:935
 */

#include <cassert>
#include <iostream>
#include <string>

#include "base/logging.hh"
#include "mem/ruby/protocol/MiscNode_State.hh"

namespace gem5
{

namespace ruby
{

// Code to convert the current state to an access permission
AccessPermission MiscNode_State_to_permission(const MiscNode_State& obj)
{
    switch(obj) {
      case MiscNode_State_Unallocated:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmSync_Partial:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmSync_ReadyToDist:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmSync_Distributing:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmSync_Waiting:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmNonSync_Partial:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmNonSync_ReadyToDist:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmNonSync_Distributing:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmNonSync_Waiting:
        return AccessPermission_Invalid;
      case MiscNode_State_DvmOp_Complete:
        return AccessPermission_Invalid;
      case MiscNode_State_null:
        return AccessPermission_Invalid;
      default:
        panic("Unknown state access permission converstion for MiscNode_State");
    }
    // Appease the compiler since this function has a return value
    return AccessPermission_Invalid;
}

} // namespace ruby
} // namespace gem5

namespace gem5
{

namespace ruby
{

// Code for output operator
::std::ostream&
operator<<(::std::ostream& out, const MiscNode_State& obj)
{
    out << MiscNode_State_to_string(obj);
    out << ::std::flush;
    return out;
}

// Code to convert state to a string
std::string
MiscNode_State_to_string(const MiscNode_State& obj)
{
    switch(obj) {
      case MiscNode_State_Unallocated:
        return "Unallocated";
      case MiscNode_State_DvmSync_Partial:
        return "DvmSync_Partial";
      case MiscNode_State_DvmSync_ReadyToDist:
        return "DvmSync_ReadyToDist";
      case MiscNode_State_DvmSync_Distributing:
        return "DvmSync_Distributing";
      case MiscNode_State_DvmSync_Waiting:
        return "DvmSync_Waiting";
      case MiscNode_State_DvmNonSync_Partial:
        return "DvmNonSync_Partial";
      case MiscNode_State_DvmNonSync_ReadyToDist:
        return "DvmNonSync_ReadyToDist";
      case MiscNode_State_DvmNonSync_Distributing:
        return "DvmNonSync_Distributing";
      case MiscNode_State_DvmNonSync_Waiting:
        return "DvmNonSync_Waiting";
      case MiscNode_State_DvmOp_Complete:
        return "DvmOp_Complete";
      case MiscNode_State_null:
        return "null";
      default:
        panic("Invalid range for type MiscNode_State");
    }
    // Appease the compiler since this function has a return value
    return "";
}

// Code to convert from a string to the enumeration
MiscNode_State
string_to_MiscNode_State(const std::string& str)
{
    if (str == "Unallocated") {
        return MiscNode_State_Unallocated;
    } else if (str == "DvmSync_Partial") {
        return MiscNode_State_DvmSync_Partial;
    } else if (str == "DvmSync_ReadyToDist") {
        return MiscNode_State_DvmSync_ReadyToDist;
    } else if (str == "DvmSync_Distributing") {
        return MiscNode_State_DvmSync_Distributing;
    } else if (str == "DvmSync_Waiting") {
        return MiscNode_State_DvmSync_Waiting;
    } else if (str == "DvmNonSync_Partial") {
        return MiscNode_State_DvmNonSync_Partial;
    } else if (str == "DvmNonSync_ReadyToDist") {
        return MiscNode_State_DvmNonSync_ReadyToDist;
    } else if (str == "DvmNonSync_Distributing") {
        return MiscNode_State_DvmNonSync_Distributing;
    } else if (str == "DvmNonSync_Waiting") {
        return MiscNode_State_DvmNonSync_Waiting;
    } else if (str == "DvmOp_Complete") {
        return MiscNode_State_DvmOp_Complete;
    } else if (str == "null") {
        return MiscNode_State_null;
    } else {
        panic("Invalid string conversion for %s, type MiscNode_State", str);
    }
}

// Code to increment an enumeration type
MiscNode_State&
operator++(MiscNode_State& e)
{
    assert(e < MiscNode_State_NUM);
    return e = MiscNode_State(e+1);
}
} // namespace ruby
} // namespace gem5
