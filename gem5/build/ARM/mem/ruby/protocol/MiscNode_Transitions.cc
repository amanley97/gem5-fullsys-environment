/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /home/a599m019/gem5-fullsys-enviroment/gem5/src/mem/slicc/symbols/StateMachine.py:1814
 */

// MiscNode: CHI Misc Node for handling and distrbuting DVM operations

#include <cassert>

#include "base/logging.hh"
#include "base/trace.hh"
#include "debug/ProtocolTrace.hh"
#include "debug/RubyGenerated.hh"
#include "mem/ruby/protocol/MiscNode_Controller.hh"
#include "mem/ruby/protocol/MiscNode_Event.hh"
#include "mem/ruby/protocol/MiscNode_State.hh"
#include "mem/ruby/protocol/Types.hh"
#include "mem/ruby/system/RubySystem.hh"

#define HASH_FUN(state, event)  ((int(state)*MiscNode_Event_NUM)+int(event))

#define GET_TRANSITION_COMMENT() (MiscNode_transitionComment.str())
#define CLEAR_TRANSITION_COMMENT() (MiscNode_transitionComment.str(""))

namespace gem5
{

namespace ruby
{

TransitionResult
MiscNode_Controller::doTransition(MiscNode_Event event,
                                  MiscNode_TBE* m_tbe_ptr,
                                  Addr addr)
{
    MiscNode_State state = getState(m_tbe_ptr, addr);
    MiscNode_State next_state = state;

    DPRINTF(RubyGenerated, "%s, Time: %lld, state: %s, event: %s, addr: %#x\n",
            *this, curCycle(), MiscNode_State_to_string(state),
            MiscNode_Event_to_string(event), addr);

    TransitionResult result =
    doTransitionWorker(event, state, next_state, m_tbe_ptr, addr);

    if (result == TransitionResult_Valid) {
        DPRINTF(RubyGenerated, "next_state: %s\n",
                MiscNode_State_to_string(next_state));
        countTransition(state, event);

        DPRINTFR(ProtocolTrace, "%15d %3s %10s%20s %6s>%-6s %#x %s\n",
                 curTick(), m_version, "MiscNode",
                 MiscNode_Event_to_string(event),
                 MiscNode_State_to_string(state),
                 MiscNode_State_to_string(next_state),
                 printAddress(addr), GET_TRANSITION_COMMENT());

        CLEAR_TRANSITION_COMMENT();
    setState(m_tbe_ptr, addr, next_state);
    setAccessPermission(addr, next_state);
    } else if (result == TransitionResult_ResourceStall) {
        DPRINTFR(ProtocolTrace, "%15s %3s %10s%20s %6s>%-6s %#x %s\n",
                 curTick(), m_version, "MiscNode",
                 MiscNode_Event_to_string(event),
                 MiscNode_State_to_string(state),
                 MiscNode_State_to_string(next_state),
                 printAddress(addr), "Resource Stall");
    } else if (result == TransitionResult_ProtocolStall) {
        DPRINTF(RubyGenerated, "stalling\n");
        DPRINTFR(ProtocolTrace, "%15s %3s %10s%20s %6s>%-6s %#x %s\n",
                 curTick(), m_version, "MiscNode",
                 MiscNode_Event_to_string(event),
                 MiscNode_State_to_string(state),
                 MiscNode_State_to_string(next_state),
                 printAddress(addr), "Protocol Stall");
    }

    return result;
}

TransitionResult
MiscNode_Controller::doTransitionWorker(MiscNode_Event event,
                                        MiscNode_State state,
                                        MiscNode_State& next_state,
                                        MiscNode_TBE*& m_tbe_ptr,
                                        Addr addr)
{
    m_curTransitionEvent = event;
    m_curTransitionNextState = next_state;
    switch(HASH_FUN(state, event)) {
  case HASH_FUN(MiscNode_State_Unallocated, MiscNode_Event_AllocRequest):
    if (!(*m_reqRdy_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_retryTriggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    AllocateTBE_Request(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_Unallocated, MiscNode_Event_AllocRequestWithCredit):
    if (!(*m_reqRdy_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    AllocateTBE_Request_WithCredit(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_Unallocated, MiscNode_Event_SendRetryAck):
    if (!(*m_rspOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Send_RetryAck(m_tbe_ptr, addr);
    Pop_RetryTriggerQueue(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_Unallocated, MiscNode_Event_SendPCrdGrant):
    if (!(*m_rspOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Send_PCrdGrant(m_tbe_ptr, addr);
    Pop_RetryTriggerQueue(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_Unallocated, MiscNode_Event_DvmTlbi_Initiate):
    next_state = MiscNode_State_DvmNonSync_Partial; m_curTransitionNextState = next_state;
    if (!(*m_rspOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Initiate_Request_DVM(m_tbe_ptr, addr);
    Pop_ReqRdyQueue(m_tbe_ptr, addr);
    Send_DvmNonSyncDBIDResp(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_Unallocated, MiscNode_Event_DvmSync_Initiate):
    next_state = MiscNode_State_DvmSync_Partial; m_curTransitionNextState = next_state;
    if (!(*m_rspOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Initiate_Request_DVM(m_tbe_ptr, addr);
    Pop_ReqRdyQueue(m_tbe_ptr, addr);
    Send_DvmSyncDBIDResp(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmSync_Partial, MiscNode_Event_NCBWrData):
    next_state = MiscNode_State_DvmSync_ReadyToDist; m_curTransitionNextState = next_state;
    Receive_ReqDataResp(m_tbe_ptr, addr);
    Pop_DataInQueue(m_tbe_ptr, addr);
    Enqueue_UpdatePendingOps(m_tbe_ptr, addr);
    ProcessNextState(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmNonSync_Partial, MiscNode_Event_NCBWrData):
    next_state = MiscNode_State_DvmNonSync_ReadyToDist; m_curTransitionNextState = next_state;
    Receive_ReqDataResp(m_tbe_ptr, addr);
    Pop_DataInQueue(m_tbe_ptr, addr);
    Enqueue_UpdatePendingOps(m_tbe_ptr, addr);
    ProcessNextState(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmSync_ReadyToDist, MiscNode_Event_DvmSendNextMessage_P1):
    next_state = MiscNode_State_DvmSync_Distributing; m_curTransitionNextState = next_state;
    if (!(*m_snpOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Send_DvmSnoop_P1(m_tbe_ptr, addr);
    ProcessNextState_ClearPending(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmSync_Distributing, MiscNode_Event_DvmSendNextMessage_P1):
  case HASH_FUN(MiscNode_State_DvmNonSync_Distributing, MiscNode_Event_DvmSendNextMessage_P1):
    if (!(*m_snpOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Send_DvmSnoop_P1(m_tbe_ptr, addr);
    ProcessNextState_ClearPending(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmSync_Distributing, MiscNode_Event_DvmSendNextMessage_P2):
  case HASH_FUN(MiscNode_State_DvmNonSync_Distributing, MiscNode_Event_DvmSendNextMessage_P2):
    if (!(*m_snpOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Send_DvmSnoop_P2(m_tbe_ptr, addr);
    ProcessNextState_ClearPending(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmNonSync_ReadyToDist, MiscNode_Event_DvmSendNextMessage_P1):
    next_state = MiscNode_State_DvmNonSync_Distributing; m_curTransitionNextState = next_state;
    if (!(*m_snpOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Send_DvmSnoop_P1(m_tbe_ptr, addr);
    ProcessNextState_ClearPending(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmSync_Distributing, MiscNode_Event_DvmFinishDistributing):
    next_state = MiscNode_State_DvmSync_Waiting; m_curTransitionNextState = next_state;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Enqueue_UpdatePendingOps(m_tbe_ptr, addr);
    ProcessNextState_ClearPending(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmNonSync_Distributing, MiscNode_Event_DvmFinishDistributing):
    next_state = MiscNode_State_DvmNonSync_Waiting; m_curTransitionNextState = next_state;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Enqueue_UpdatePendingOps(m_tbe_ptr, addr);
    ProcessNextState_ClearPending(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmSync_Waiting, MiscNode_Event_DvmFinishWaiting):
    next_state = MiscNode_State_DvmOp_Complete; m_curTransitionNextState = next_state;
    if (!(*m_rspOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Send_Comp(m_tbe_ptr, addr);
    Profile_OutgoingEnd_DVM(m_tbe_ptr, addr);
    Enqueue_UpdatePendingOps(m_tbe_ptr, addr);
    ProcessNextState_ClearPending(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmNonSync_Waiting, MiscNode_Event_DvmFinishWaiting):
    next_state = MiscNode_State_DvmOp_Complete; m_curTransitionNextState = next_state;
    if (!(*m_rspOut_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Send_Comp_NonSync(m_tbe_ptr, addr);
    Profile_OutgoingEnd_DVM(m_tbe_ptr, addr);
    Enqueue_UpdatePendingOps(m_tbe_ptr, addr);
    ProcessNextState_ClearPending(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmSync_Distributing, MiscNode_Event_SnpResp_I):
  case HASH_FUN(MiscNode_State_DvmNonSync_Distributing, MiscNode_Event_SnpResp_I):
  case HASH_FUN(MiscNode_State_DvmSync_Waiting, MiscNode_Event_SnpResp_I):
  case HASH_FUN(MiscNode_State_DvmNonSync_Waiting, MiscNode_Event_SnpResp_I):
    Receive_SnpResp(m_tbe_ptr, addr);
    Pop_RespInQueue(m_tbe_ptr, addr);
    ProcessNextState(m_tbe_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(MiscNode_State_DvmOp_Complete, MiscNode_Event_Final):
    next_state = MiscNode_State_Unallocated; m_curTransitionNextState = next_state;
    Pop_TriggerQueue(m_tbe_ptr, addr);
    Finalize_DeallocateRequest(m_tbe_ptr, addr);
    return TransitionResult_Valid;

      default:
        panic("Invalid transition\n"
              "%s time: %d addr: %#x event: %s state: %s\n",
              name(), curCycle(), addr, event, state);
    }

    return TransitionResult_Valid;
}

} // namespace ruby
} // namespace gem5
