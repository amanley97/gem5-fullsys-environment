/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /home/a599m019/gem5-fullsys-enviroment/gem5/src/mem/slicc/symbols/StateMachine.py:1348
 */

// Created by slicc definition of Module "Cache coherency protocol"

#include <sys/types.h>
#include <unistd.h>

#include <cassert>
#include <sstream>
#include <string>
#include <typeinfo>

#include "mem/ruby/common/BoolVec.hh"

#include "base/compiler.hh"
#include "base/cprintf.hh"

#include "debug/LLSC.hh"
#include "debug/RubyGenerated.hh"
#include "debug/RubyProtocol.hh"
#include "debug/RubySlicc.hh"
#include "mem/ruby/network/Network.hh"
#include "mem/ruby/protocol/Cache_Controller.hh"
#include "mem/ruby/protocol/Cache_Event.hh"
#include "mem/ruby/protocol/Cache_State.hh"
#include "mem/ruby/protocol/Types.hh"
#include "mem/ruby/system/RubySystem.hh"

#include "mem/ruby/slicc_interface/RubySlicc_includes.hh"
#include "mem/ruby/protocol/PerfectCacheMemory.hh"
#include "mem/ruby/protocol/TimerTable.hh"
#include "mem/ruby/protocol/TBETable.hh"
#include "mem/ruby/protocol/TBEStorage.hh"
#include "mem/ruby/protocol/TriggerQueue.hh"
#include "mem/ruby/protocol/NetDest.hh"
namespace gem5
{

namespace ruby
{

int Cache_Controller::m_num_controllers = 0;
std::vector<statistics::Vector *>  Cache_Controller::eventVec;
std::vector<std::vector<statistics::Vector *> >  Cache_Controller::transVec;

// for adding information to the protocol debug trace
std::stringstream Cache_transitionComment;

#ifndef NDEBUG
#define APPEND_TRANSITION_COMMENT(str) (Cache_transitionComment << str)
#else
#define APPEND_TRANSITION_COMMENT(str) do {} while (0)
#endif

/** \brief constructor */
Cache_Controller::Cache_Controller(const Params &p)
    : AbstractController(p)
{
    m_machineID.type = MachineType_Cache;
    m_machineID.num = m_version;
    m_num_controllers++;
    p.ruby_system->registerAbstractController(this);

    m_in_ports = 12;
    m_sequencer_ptr = p.sequencer;
    if (m_sequencer_ptr != NULL) {
        m_sequencer_ptr->setController(this);
    }
    m_cache_ptr = p.cache;
    m_read_hit_latency = p.read_hit_latency;
    m_read_miss_latency = p.read_miss_latency;
    m_write_fe_latency = p.write_fe_latency;
    m_write_be_latency = p.write_be_latency;
    m_fill_latency = p.fill_latency;
    m_snp_latency = p.snp_latency;
    m_snp_inv_latency = p.snp_inv_latency;
    m_wait_for_cache_wr = p.wait_for_cache_wr;
    m_allocation_latency = p.allocation_latency;
    m_request_latency = p.request_latency;
    m_response_latency = p.response_latency;
    m_snoop_latency = p.snoop_latency;
    m_data_latency = p.data_latency;
    m_dvm_ext_tlbi_latency = p.dvm_ext_tlbi_latency;
    m_sc_lock_base_latency_cy = p.sc_lock_base_latency_cy;
    m_sc_lock_multiplier_inc = p.sc_lock_multiplier_inc;
    m_sc_lock_multiplier_decay = p.sc_lock_multiplier_decay;
    m_sc_lock_multiplier_max = p.sc_lock_multiplier_max;
    m_sc_lock_enabled = p.sc_lock_enabled;
    m_stall_recycle_lat = p.stall_recycle_lat;
    m_send_evictions = p.send_evictions;
    m_number_of_snoop_TBEs = p.number_of_snoop_TBEs;
    m_number_of_repl_TBEs = p.number_of_repl_TBEs;
    m_number_of_DVM_TBEs = p.number_of_DVM_TBEs;
    m_number_of_DVM_snoop_TBEs = p.number_of_DVM_snoop_TBEs;
    m_unify_repl_TBEs = p.unify_repl_TBEs;
    m_dealloc_wait_for_tag = p.dealloc_wait_for_tag;
    m_data_channel_size = p.data_channel_size;
    m_is_HN = p.is_HN;
    m_enable_DMT = p.enable_DMT;
    m_enable_DMT_early_dealloc = p.enable_DMT_early_dealloc;
    m_enable_DCT = p.enable_DCT;
    m_comp_wu = p.comp_wu;
    m_comp_wu_latency = p.comp_wu_latency;
    m_alloc_on_readshared = p.alloc_on_readshared;
    m_alloc_on_readunique = p.alloc_on_readunique;
    m_alloc_on_readonce = p.alloc_on_readonce;
    m_alloc_on_writeback = p.alloc_on_writeback;
    m_alloc_on_seq_acc = p.alloc_on_seq_acc;
    m_alloc_on_seq_line_write = p.alloc_on_seq_line_write;
    m_dealloc_on_unique = p.dealloc_on_unique;
    m_dealloc_on_shared = p.dealloc_on_shared;
    m_dealloc_backinv_unique = p.dealloc_backinv_unique;
    m_dealloc_backinv_shared = p.dealloc_backinv_shared;
    m_fwd_unique_on_readshared = p.fwd_unique_on_readshared;
    m_allow_SD = p.allow_SD;
    m_throttle_req_on_retry = p.throttle_req_on_retry;
    m_use_prefetcher = p.use_prefetcher;
    m_reqOut_ptr = p.reqOut;
    m_snpOut_ptr = p.snpOut;
    m_rspOut_ptr = p.rspOut;
    m_datOut_ptr = p.datOut;
    m_reqIn_ptr = p.reqIn;
    m_snpIn_ptr = p.snpIn;
    m_rspIn_ptr = p.rspIn;
    m_datIn_ptr = p.datIn;
    m_mandatoryQueue_ptr = p.mandatoryQueue;
    m_triggerQueue_ptr = p.triggerQueue;
    m_retryTriggerQueue_ptr = p.retryTriggerQueue;
    m_reqRdy_ptr = p.reqRdy;
    m_snpRdy_ptr = p.snpRdy;
    m_replTriggerQueue_ptr = p.replTriggerQueue;
    m_prefetchQueue_ptr = p.prefetchQueue;
    m_upstream_prefetch_trains_prefetcher = p.upstream_prefetch_trains_prefetcher;

    for (int state = 0; state < Cache_State_NUM; state++) {
        for (int event = 0; event < Cache_Event_NUM; event++) {
            m_possible[state][event] = false;
            m_counters[state][event] = 0;
        }
    }
    for (int event = 0; event < Cache_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }
}

void
Cache_Controller::initNetQueues()
{
    MachineType machine_type = string_to_MachineType("Cache");
    [[maybe_unused]] int base = MachineType_base_number(machine_type);

    assert(m_reqOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_reqOut_ptr->getOrdered(), 0,
                                     "none", m_reqOut_ptr);
    assert(m_snpOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_snpOut_ptr->getOrdered(), 1,
                                     "none", m_snpOut_ptr);
    assert(m_rspOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_rspOut_ptr->getOrdered(), 2,
                                     "none", m_rspOut_ptr);
    assert(m_datOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_datOut_ptr->getOrdered(), 3,
                                     "response", m_datOut_ptr);
    assert(m_reqIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_reqIn_ptr->getOrdered(), 0,
                                     "none", m_reqIn_ptr);
    assert(m_snpIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_snpIn_ptr->getOrdered(), 1,
                                     "none", m_snpIn_ptr);
    assert(m_rspIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_rspIn_ptr->getOrdered(), 2,
                                     "none", m_rspIn_ptr);
    assert(m_datIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_datIn_ptr->getOrdered(), 3,
                                     "response", m_datIn_ptr);
}

void
Cache_Controller::init()
{
    // initialize objects
    m_blockSize_ptr = new int;
    (*m_blockSize_ptr) = RubySystem::getBlockSizeBytes();
    m_directory_ptr  = new PerfectCacheMemory<Cache_DirEntry>();
    assert(m_directory_ptr != NULL);
    m_useTimerTable_ptr  = new TimerTable();
    assert(m_useTimerTable_ptr != NULL);
    m_sc_lock_multiplier_ptr = new int;
    (*m_sc_lock_multiplier_ptr) = 0;
    m_TBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_TBEs);
    assert(m_TBEs_ptr != NULL);
    m_storTBEs_ptr  = new TBEStorage(this, m_number_of_TBEs);
    assert(m_storTBEs_ptr != NULL);
    m_replTBEs_ptr  = new TBETable<Cache_TBE>(m_unify_repl_TBEs ? m_number_of_TBEs : m_number_of_repl_TBEs);
    assert(m_replTBEs_ptr != NULL);
    m_storReplTBEs_ptr  = new TBEStorage(this, m_number_of_repl_TBEs);
    assert(m_storReplTBEs_ptr != NULL);
    m_snpTBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_snoop_TBEs);
    assert(m_snpTBEs_ptr != NULL);
    m_storSnpTBEs_ptr  = new TBEStorage(this, m_number_of_snoop_TBEs);
    assert(m_storSnpTBEs_ptr != NULL);
    m_dvmTBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_DVM_TBEs);
    assert(m_dvmTBEs_ptr != NULL);
    m_storDvmTBEs_ptr  = new TBEStorage(this, m_number_of_DVM_TBEs);
    assert(m_storDvmTBEs_ptr != NULL);
    m_dvmSnpTBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_DVM_snoop_TBEs);
    assert(m_dvmSnpTBEs_ptr != NULL);
    m_storDvmSnpTBEs_ptr  = new TBEStorage(this, m_number_of_DVM_snoop_TBEs);
    assert(m_storDvmSnpTBEs_ptr != NULL);
    m_dvmPendingNonSyncsBlockingSync_ptr  = new TriggerQueue<Cache_Event>();
    assert(m_dvmPendingNonSyncsBlockingSync_ptr != NULL);
    m_dvmHasPendingSyncOp_ptr = new bool;
    (*m_dvmHasPendingSyncOp_ptr) = false;
    m_dvmPendingSyncOp_ptr = new Addr;
    (*m_dvmPendingSyncOp_ptr) = 0;
    m_retryQueue_ptr  = new TriggerQueue<Cache_RetryQueueEntry>();
    assert(m_retryQueue_ptr != NULL);
    m_destsWaitingRetry_ptr  = new NetDest();
    assert(m_destsWaitingRetry_ptr != NULL);


    (*m_useTimerTable_ptr).setConsumer(this);
    (*m_rspIn_ptr).setConsumer(this);
    (*m_datIn_ptr).setConsumer(this);
    (*m_snpRdy_ptr).setConsumer(this);
    (*m_snpIn_ptr).setConsumer(this);
    (*m_retryTriggerQueue_ptr).setConsumer(this);
    (*m_triggerQueue_ptr).setConsumer(this);
    (*m_replTriggerQueue_ptr).setConsumer(this);
    (*m_reqRdy_ptr).setConsumer(this);
    (*m_reqIn_ptr).setConsumer(this);
    (*m_mandatoryQueue_ptr).setConsumer(this);
    (*m_prefetchQueue_ptr).setConsumer(this);

    possibleTransition(Cache_State_I, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_I, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RUSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RUSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_I, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RUSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RUSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_I, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_I, Cache_Event_AllocDvmSnoop);
    possibleTransition(Cache_State_UD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocSeqDvmRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_TagArrayRead);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TagArrayRead);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_TagArrayWrite);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TagArrayWrite);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayRead);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayRead);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CheckCacheFill);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckCacheFill);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayWrite);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayWrite);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayWriteOnFill);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayWriteOnFill);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadHitPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadHitPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadMissPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadMissPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteFEPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteFEPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBEPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBEPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_FillPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FillPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpSharedPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpSharedPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpInvPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpInvPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOncePipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOncePipe);
    possibleTransition(Cache_State_I, Cache_Event_ReadShared);
    possibleTransition(Cache_State_I, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_I, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_I, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_I, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_I, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_I, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_I, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD, Cache_Event_Load);
    possibleTransition(Cache_State_UD_T, Cache_Event_Load);
    possibleTransition(Cache_State_SD, Cache_Event_Load);
    possibleTransition(Cache_State_UC, Cache_Event_Load);
    possibleTransition(Cache_State_SC, Cache_Event_Load);
    possibleTransition(Cache_State_UD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_T, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RUSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_LoadHit);
    possibleTransition(Cache_State_UD, Cache_Event_Store);
    possibleTransition(Cache_State_UD_T, Cache_Event_Store);
    possibleTransition(Cache_State_UC, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_StoreHit);
    possibleTransition(Cache_State_I, Cache_Event_Load);
    possibleTransition(Cache_State_I, Cache_Event_Prefetch);
    possibleTransition(Cache_State_I, Cache_Event_Store);
    possibleTransition(Cache_State_SD, Cache_Event_Store);
    possibleTransition(Cache_State_SC, Cache_Event_Store);
    possibleTransition(Cache_State_UD_T, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_RUSD, Cache_Event_Evict);
    possibleTransition(Cache_State_RUSC, Cache_Event_Evict);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_UD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_I, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RUSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RUSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RUSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RUSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpShared);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Load);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Evict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadShared);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CleanUnique_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Load);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Evict);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpStalled);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpStalled);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ActionStalledOnHazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ActionStalledOnHazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteBackOrWriteEvict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteClean);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteNoSnp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteNoSnpPartial);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendEvict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWBData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWUData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWUDataCB);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendInvSnpResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpNotSharedDirtyFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnceFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpFwdedData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpFwdedResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpIResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompIResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompUCResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompUCRespStale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendRespSepData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WaitCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WaitCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RestoreFromHazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadNoSnp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadNoSnpDMT);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdToOwner);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdToSharer);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnceFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueRetToSrc);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpCleanInvalidNoReq);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDResp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendDBIDResp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendComp_WU);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendComp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDRespStale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_MaintainCoherence);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FinishCleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FinishCopyBack_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromStore);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromCU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromRU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_UD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_NCBWrData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_NCBWrData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_UD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_PD_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_PD_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RespSepData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RespSepData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataSepResp_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataSepResp_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_UD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_SC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_SD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_UD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadReceipt);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DoRetry);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DoRetry);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DoRetry_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DoRetry_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I_Fwded_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I_Fwded_UD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_UC_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_UD_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SD_Fwded_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompDBIDResp);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Comp_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Comp_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DBIDResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Comp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TX_Data);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Final);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Final);
    possibleTransition(Cache_State_I, Cache_Event_DvmTlbi_Initiate);
    possibleTransition(Cache_State_I, Cache_Event_DvmSync_Initiate);
    possibleTransition(Cache_State_DvmSync_Unsent, Cache_Event_DvmSync_Send);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_RetryAck);
    possibleTransition(Cache_State_DvmSync_Unconfirmed, Cache_Event_RetryAck);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_PCrdGrant);
    possibleTransition(Cache_State_DvmSync_Unconfirmed, Cache_Event_PCrdGrant);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_DoRetry);
    possibleTransition(Cache_State_DvmSync_Unconfirmed, Cache_Event_DoRetry);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_DBIDResp);
    possibleTransition(Cache_State_DvmSync_Unconfirmed, Cache_Event_DBIDResp);
    possibleTransition(Cache_State_DvmTlbi_Unconfirmed, Cache_Event_CompDBIDResp);
    possibleTransition(Cache_State_DvmTlbi_Waiting, Cache_Event_Comp);
    possibleTransition(Cache_State_DvmSync_Waiting, Cache_Event_Comp);
    possibleTransition(Cache_State_DvmOp_Finished, Cache_Event_Final);
    possibleTransition(Cache_State_I, Cache_Event_SnpDvmOpNonSync_P1);
    possibleTransition(Cache_State_I, Cache_Event_SnpDvmOpNonSync_P2);
    possibleTransition(Cache_State_I, Cache_Event_SnpDvmOpSync_P1);
    possibleTransition(Cache_State_I, Cache_Event_SnpDvmOpSync_P2);
    possibleTransition(Cache_State_DvmExtTlbi_Partial, Cache_Event_SnpDvmOpNonSync_P1);
    possibleTransition(Cache_State_DvmExtTlbi_Partial, Cache_Event_SnpDvmOpNonSync_P2);
    possibleTransition(Cache_State_DvmExtSync_Partial, Cache_Event_SnpDvmOpSync_P1);
    possibleTransition(Cache_State_DvmExtSync_Partial, Cache_Event_SnpDvmOpSync_P2);
    possibleTransition(Cache_State_DvmExtTlbi_Executing, Cache_Event_SendSnpIResp);
    possibleTransition(Cache_State_DvmExtSync_Executing, Cache_Event_DvmSync_ExternCompleted);
    possibleTransition(Cache_State_DvmExtOp_Finished, Cache_Event_Final);
    AbstractController::init();
    resetStats();
}
Sequencer*
Cache_Controller::getCPUSequencer() const
{
    if (NULL != m_sequencer_ptr && m_sequencer_ptr->isCPUSequencer()) {
        return m_sequencer_ptr;
    } else {
        return NULL;
    }
}

DMASequencer*
Cache_Controller::getDMASequencer() const
{
    return NULL;
}

GPUCoalescer*
Cache_Controller::getGPUCoalescer() const
{
    return NULL;
}

void
Cache_Controller::regStats()
{
    AbstractController::regStats();

    // For each type of controllers, one controller of that type is picked
    // to aggregate stats of all controllers of that type.
    if (m_version == 0) {

        Profiler *profiler = params().ruby_system->getProfiler();
        statistics::Group *profilerStatsPtr = &profiler->rubyProfilerStats;

        for (Cache_Event event = Cache_Event_FIRST;
             event < Cache_Event_NUM; ++event) {
            std::string stat_name =
                "Cache_Controller." + Cache_Event_to_string(event);
            statistics::Vector *t =
                new statistics::Vector(profilerStatsPtr, stat_name.c_str());
            t->init(m_num_controllers);
            t->flags(statistics::pdf | statistics::total |
                statistics::oneline | statistics::nozero);

            eventVec.push_back(t);
        }

        for (Cache_State state = Cache_State_FIRST;
             state < Cache_State_NUM; ++state) {

            transVec.push_back(std::vector<statistics::Vector *>());

            for (Cache_Event event = Cache_Event_FIRST;
                 event < Cache_Event_NUM; ++event) {
                std::string stat_name = "Cache_Controller." +
                    Cache_State_to_string(state) +
                    "." + Cache_Event_to_string(event);
                statistics::Vector *t = new statistics::Vector(
                    profilerStatsPtr, stat_name.c_str());
                t->init(m_num_controllers);
                t->flags(statistics::pdf | statistics::total |
                    statistics::oneline | statistics::nozero);
                transVec[state].push_back(t);
            }
        }
    }

    for (Cache_Event event = Cache_Event_FIRST;
                 event < Cache_Event_NUM; ++event) {
        std::string stat_name =
            "outTransLatHist." + Cache_Event_to_string(event);
        statistics::Histogram* t =
            new statistics::Histogram(&stats, stat_name.c_str());
        stats.outTransLatHist.push_back(t);
        t->init(5);
        t->flags(statistics::pdf | statistics::total |
                 statistics::oneline | statistics::nozero);

        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".retries").c_str());
        stats.outTransLatHistRetries.push_back(r);
        r->flags(statistics::nozero);
    }

    for (Cache_Event event = Cache_Event_FIRST;
                 event < Cache_Event_NUM; ++event) {
        std::string stat_name = "inTransLatHist." +
                                Cache_Event_to_string(event);
        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".total").c_str());
        stats.inTransLatTotal.push_back(r);
        r->flags(statistics::nozero);

        r = new statistics::Scalar(&stats,
                              (stat_name + ".retries").c_str());
        stats.inTransLatRetries.push_back(r);
        r->flags(statistics::nozero);

        stats.inTransLatHist.emplace_back();
        for (Cache_State initial_state = Cache_State_FIRST;
             initial_state < Cache_State_NUM; ++initial_state) {
            stats.inTransLatHist.back().emplace_back();
            for (Cache_State final_state = Cache_State_FIRST;
                 final_state < Cache_State_NUM; ++final_state) {
                std::string stat_name = "inTransLatHist." +
                    Cache_Event_to_string(event) + "." +
                    Cache_State_to_string(initial_state) + "." +
                    Cache_State_to_string(final_state);
                statistics::Histogram* t =
                    new statistics::Histogram(&stats, stat_name.c_str());
                stats.inTransLatHist.back().back().push_back(t);
                t->init(5);
                t->flags(statistics::pdf | statistics::total |
                         statistics::oneline | statistics::nozero);
            }
        }
    }
}

void
Cache_Controller::collateStats()
{
    for (Cache_Event event = Cache_Event_FIRST;
         event < Cache_Event_NUM; ++event) {
        for (unsigned int i = 0; i < m_num_controllers; ++i) {
            RubySystem *rs = params().ruby_system;
            std::map<uint32_t, AbstractController *>::iterator it =
                     rs->m_abstract_controls[MachineType_Cache].find(i);
            assert(it != rs->m_abstract_controls[MachineType_Cache].end());
            (*eventVec[event])[i] =
                ((Cache_Controller *)(*it).second)->getEventCount(event);
        }
    }

    for (Cache_State state = Cache_State_FIRST;
         state < Cache_State_NUM; ++state) {

        for (Cache_Event event = Cache_Event_FIRST;
             event < Cache_Event_NUM; ++event) {

            for (unsigned int i = 0; i < m_num_controllers; ++i) {
                RubySystem *rs = params().ruby_system;
                std::map<uint32_t, AbstractController *>::iterator it =
                         rs->m_abstract_controls[MachineType_Cache].find(i);
                assert(it != rs->m_abstract_controls[MachineType_Cache].end());
                (*transVec[state][event])[i] =
                    ((Cache_Controller *)(*it).second)->getTransitionCount(state, event);
            }
        }
    }
}

void
Cache_Controller::countTransition(Cache_State state, Cache_Event event)
{
    assert(m_possible[state][event]);
    m_counters[state][event]++;
    m_event_counters[event]++;
}
void
Cache_Controller::possibleTransition(Cache_State state,
                             Cache_Event event)
{
    m_possible[state][event] = true;
}

uint64_t
Cache_Controller::getEventCount(Cache_Event event)
{
    return m_event_counters[event];
}

bool
Cache_Controller::isPossible(Cache_State state, Cache_Event event)
{
    return m_possible[state][event];
}

uint64_t
Cache_Controller::getTransitionCount(Cache_State state,
                             Cache_Event event)
{
    return m_counters[state][event];
}

int
Cache_Controller::getNumControllers()
{
    return m_num_controllers;
}

MessageBuffer*
Cache_Controller::getMandatoryQueue() const
{
    return m_mandatoryQueue_ptr;
}

MessageBuffer*
Cache_Controller::getMemReqQueue() const
{
    return NULL;
}

MessageBuffer*
Cache_Controller::getMemRespQueue() const
{
    return NULL;
}

void
Cache_Controller::print(std::ostream& out) const
{
    out << "[Cache_Controller " << m_version << "]";
}

void Cache_Controller::resetStats()
{
    for (int state = 0; state < Cache_State_NUM; state++) {
        for (int event = 0; event < Cache_Event_NUM; event++) {
            m_counters[state][event] = 0;
        }
    }

    for (int event = 0; event < Cache_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }

    AbstractController::resetStats();
}

// Set and Reset for cache_entry variable
void
Cache_Controller::set_cache_entry(Cache_CacheEntry*& m_cache_entry_ptr, AbstractCacheEntry* m_new_cache_entry)
{
  m_cache_entry_ptr = (Cache_CacheEntry*)m_new_cache_entry;
}

void
Cache_Controller::unset_cache_entry(Cache_CacheEntry*& m_cache_entry_ptr)
{
  m_cache_entry_ptr = 0;
}

// Set and Reset for tbe variable
void
Cache_Controller::set_tbe(Cache_TBE*& m_tbe_ptr, Cache_TBE* m_new_tbe)
{
  m_tbe_ptr = m_new_tbe;
}

void
Cache_Controller::unset_tbe(Cache_TBE*& m_tbe_ptr)
{
  m_tbe_ptr = NULL;
}

void
Cache_Controller::recordCacheTrace(int cntrl, CacheRecorder* tr)
{
    m_cache_ptr->recordCacheContents(cntrl, tr);
}

// Actions
/** \brief  */
void
Cache_Controller::AllocateTBE_Request(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Request\n");
    try {
           if ((((*m_storTBEs_ptr)).areNSlotsAvailable((1)))) {
        (((*m_storTBEs_ptr)).incrementReserved());
        {
            // Declare message
            [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            #ifndef NDEBUG
            if (!((((*in_msg_ptr)).m_addr == addr))) {
                panic("Runtime Error at CHI-cache-actions.sm:51: %s.\n", "assert failure");

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!((((*in_msg_ptr)).m_is_local_pf == (false)))) {
                panic("Runtime Error at CHI-cache-actions.sm:52: %s.\n", "assert failure");

            }
            #endif
            ;
            *out_msg = (*in_msg_ptr);
            ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
        }
        }
    } else {
        {
            // Declare message
            [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!(((*in_msg_ptr)).m_allowRetry)) {
            panic("Runtime Error at CHI-cache-actions.sm:60: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge());
            (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
            (*out_msg).m_usesTxnId = (false);
            (*out_msg).m_event = Cache_Event_SendRetryAck;
            (*out_msg).m_retryDest = ((*in_msg_ptr)).m_requestor;
            (((*m_retryQueue_ptr)).emplace(((*in_msg_ptr)).m_addr, (false), ((*in_msg_ptr)).m_requestor));
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
        }
        }
    }
    (((*m_reqIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Request: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_Request_WithCredit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Request_WithCredit\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_allowRetry == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:78: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_addr == addr))) {
        panic("Runtime Error at CHI-cache-actions.sm:80: %s.\n", "assert failure");

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
}
}
(((*m_reqIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Request_WithCredit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_Snoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Snoop\n");
    try {
       (((*m_storSnpTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_addr == addr))) {
        panic("Runtime Error at CHI-cache-actions.sm:96: %s.\n", "assert failure");

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_snpRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
}
(((*m_destsWaitingRetry_ptr)).remove(((*in_msg_ptr)).m_requestor));
}
(((*m_snpIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Snoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_DvmSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_DvmSnoop\n");
    try {
       (((*m_storDvmSnpTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    #ifndef NDEBUG
    if (!(((*in_msg_ptr)).m_usesTxnId)) {
        panic("Runtime Error at CHI-cache-actions.sm:119: %s.\n", "assert failure");

    }
    #endif
    ;
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_addr == addr))) {
        panic("Runtime Error at CHI-cache-actions.sm:120: %s.\n", "assert failure");

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_snpRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
}
}
(((*m_snpIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_DvmSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_SeqRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_SeqRequest\n");
    try {
       (((*m_storTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const RubyRequest* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_mandatoryQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (*out_msg).m_addr = ((*in_msg_ptr)).m_LineAddress;
    #ifndef NDEBUG
    if (!(((((*in_msg_ptr)).m_Size > (0)) && (((*in_msg_ptr)).m_Size <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:138: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_accAddr = ((*in_msg_ptr)).m_PhysicalAddress;
    (*out_msg).m_accSize = ((*in_msg_ptr)).m_Size;
    (*out_msg).m_requestor = m_machineID;
    (*out_msg).m_fwdRequestor = m_machineID;
    (*out_msg).m_seqReq = (((*in_msg_ptr)).getRequestPtr());
    (*out_msg).m_isSeqReqValid = (true);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_Prefetch == PrefetchBit_No))) {
        panic("Runtime Error at CHI-cache-actions.sm:145: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_is_local_pf = (false);
    (*out_msg).m_is_remote_pf = (false);
        if (((((*in_msg_ptr)).m_Type == RubyRequestType_LD) || (((*in_msg_ptr)).m_Type == RubyRequestType_IFETCH))) {
            (*out_msg).m_type = CHIRequestType_Load;
        } else {
                if ((((*in_msg_ptr)).m_Type == RubyRequestType_ST)) {
                        if ((((*in_msg_ptr)).m_Size == (*m_blockSize_ptr))) {
                            (*out_msg).m_type = CHIRequestType_StoreLine;
                        } else {
                            (*out_msg).m_type = CHIRequestType_Store;
                        }
                    } else {
                        panic("Runtime Error at CHI-cache-actions.sm:159: %s.\n", ("Invalid RubyRequestType"));
                        ;
                    }
                }
                ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
            }
            }
            (((*m_mandatoryQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_SeqRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_SeqDvmRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_SeqDvmRequest\n");
    try {
       (((*m_storDvmTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const RubyRequest* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_mandatoryQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = ((*in_msg_ptr)).m_tlbiTransactionUid;
    (*out_msg).m_addr = ((*in_msg_ptr)).m_tlbiTransactionUid;
    (*out_msg).m_accAddr = ((*in_msg_ptr)).m_tlbiTransactionUid;
    (*out_msg).m_accSize = (*m_blockSize_ptr);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_Prefetch == PrefetchBit_No))) {
        panic("Runtime Error at CHI-cache-actions.sm:185: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_is_local_pf = (false);
    (*out_msg).m_is_remote_pf = (false);
    (*out_msg).m_requestor = m_machineID;
    (*out_msg).m_fwdRequestor = m_machineID;
    (*out_msg).m_seqReq = (((*in_msg_ptr)).getRequestPtr());
    (*out_msg).m_isSeqReqValid = (true);
        if ((((*in_msg_ptr)).m_Type == RubyRequestType_TLBI)) {
            (*out_msg).m_type = CHIRequestType_DvmTlbi_Initiate;
        } else {
                if ((((*in_msg_ptr)).m_Type == RubyRequestType_TLBI_SYNC)) {
                    (*out_msg).m_type = CHIRequestType_DvmSync_Initiate;
                } else {
                        if ((((*in_msg_ptr)).m_Type == RubyRequestType_TLBI_EXT_SYNC_COMP)) {
                            (*out_msg).m_type = CHIRequestType_DvmSync_ExternCompleted;
                        } else {
                            panic("Runtime Error at CHI-cache-actions.sm:202: %s.\n", ("Invalid RubyRequestType"));
                            ;
                        }
                    }
                }
                ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
            }
            }
            (((*m_mandatoryQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_SeqDvmRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Allocate TBE for prefetch request */
void
Cache_Controller::AllocateTBE_PfRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_PfRequest\n");
    try {
       (((*m_storTBEs_ptr)).incrementReserved());
{
    // Declare message
    [[maybe_unused]] const RubyRequest* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_prefetchQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (*out_msg).m_addr = ((*in_msg_ptr)).m_LineAddress;
    #ifndef NDEBUG
    if (!(((((*in_msg_ptr)).m_Size > (0)) && (((*in_msg_ptr)).m_Size <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:220: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_accAddr = ((*in_msg_ptr)).m_PhysicalAddress;
    (*out_msg).m_accSize = ((*in_msg_ptr)).m_Size;
    (*out_msg).m_requestor = m_machineID;
    (*out_msg).m_fwdRequestor = m_machineID;
    (*out_msg).m_seqReq = (((*in_msg_ptr)).getRequestPtr());
    (*out_msg).m_isSeqReqValid = (true);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_Prefetch != PrefetchBit_No))) {
        panic("Runtime Error at CHI-cache-actions.sm:227: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_is_local_pf = (true);
    (*out_msg).m_is_remote_pf = (false);
        if ((((*in_msg_ptr)).m_Type == RubyRequestType_LD)) {
            (*out_msg).m_type = CHIRequestType_Load;
        } else {
                if ((((*in_msg_ptr)).m_Type == RubyRequestType_ST)) {
                    panic("Runtime Error at CHI-cache-actions.sm:234: %s.\n", ("CHI is not supporting prefetch store requests"));
                    ;
                } else {
                    panic("Runtime Error at CHI-cache-actions.sm:236: %s.\n", ("Invalid RubyRequestType"));
                    ;
                }
            }
            ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
        }
        }
        (((*m_prefetchQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_PfRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Request(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
bool was_retried
 = (false);
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateRequestTBE(addr, (*in_msg_ptr))));;
was_retried = (((*in_msg_ptr)).m_allowRetry == (false));
}
Cache_DirEntry* dir_entry
 = (getDirEntry(addr));
(copyCacheAndDir(m_cache_entry_ptr, dir_entry, m_tbe_ptr, initial));
(*m_tbe_ptr).m_use_DMT = (m_is_HN && m_enable_DMT);
(*m_tbe_ptr).m_use_DCT = m_enable_DCT;
bool alloc_entry
 = (needCacheEntry((*m_tbe_ptr).m_reqType, m_cache_entry_ptr, dir_entry, (*m_tbe_ptr).m_is_local_pf));
bool dealloc_entry
 = (needDeallocCacheEntry((*m_tbe_ptr).m_reqType));
#ifndef NDEBUG
if (!(((alloc_entry && dealloc_entry) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:261: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_dataToBeInvalid = (dealloc_entry || ((m_cache_entry_ptr == NULL) && (alloc_entry == (false))));
(*m_tbe_ptr).m_doCacheFill = (alloc_entry || (m_cache_entry_ptr != NULL));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
(incomingTransactionStart(addr, (curTransitionEvent()), initial, was_retried));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Request: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Request_DVM(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request_DVM\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
Cache_TBE* tbe
 = (allocateDvmRequestTBE(addr, (*in_msg_ptr)));
set_tbe(m_tbe_ptr, tbe);;
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Request_DVM: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Request_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request_Stale\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
bool was_retried
 = (false);
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateRequestTBE(addr, (*in_msg_ptr))));;
was_retried = (((*in_msg_ptr)).m_allowRetry == (false));
}
(copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
    if ((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) && (m_cache_entry_ptr != NULL))) {
        (*m_tbe_ptr).m_dataBlk = (*m_cache_entry_ptr).m_DataBlk;
        (((*m_tbe_ptr).m_dataBlkValid).fillMask());
        (*m_tbe_ptr).m_dataValid = (true);
    }
    (incomingTransactionStart(addr, (curTransitionEvent()), initial, was_retried));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Request_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Snoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Snoop\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateSnoopTBE(addr, (*in_msg_ptr))));;
}
(copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
(*m_tbe_ptr).m_dataToBeInvalid = (m_cache_entry_ptr == NULL);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
(incomingTransactionStart(addr, (curTransitionEvent()), initial, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Snoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Snoop_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Snoop_Hazard\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:322: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_is_req_tbe || (*m_tbe_ptr).m_is_repl_tbe))) {
    panic("Runtime Error at CHI-cache-actions.sm:323: %s.\n", "assert failure");

}
#endif
;
Cache_TBE* prev_tbe
 = m_tbe_ptr;
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateSnoopTBE(addr, (*in_msg_ptr))));;
}
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:330: %s.\n", "assert failure");

}
#endif
;
    if ((*prev_tbe).m_is_req_tbe) {
        #ifndef NDEBUG
        if (!(((*prev_tbe).m_is_repl_tbe == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:332: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_req_hazard = (true);
    } else {
        #ifndef NDEBUG
        if (!((*prev_tbe).m_is_repl_tbe)) {
            panic("Runtime Error at CHI-cache-actions.sm:335: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_repl_hazard = (true);
    }
    (*m_tbe_ptr).m_pendReqType = (*prev_tbe).m_pendReqType;
    (copyCacheAndDirTBEs(prev_tbe, m_tbe_ptr));
    (*m_tbe_ptr).m_wakeup_pending_req = (*prev_tbe).m_wakeup_pending_req;
    (*m_tbe_ptr).m_wakeup_pending_snp = (*prev_tbe).m_wakeup_pending_snp;
    (*m_tbe_ptr).m_wakeup_pending_tgr = (*prev_tbe).m_wakeup_pending_tgr;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Snoop_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::RestoreFromHazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing RestoreFromHazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
(setDataToBeStates(m_tbe_ptr));
(copyCacheAndDirTBEs(m_tbe_ptr, hazard_tbe));
(*hazard_tbe).m_wakeup_pending_req = (*m_tbe_ptr).m_wakeup_pending_req;
(*hazard_tbe).m_wakeup_pending_snp = (*m_tbe_ptr).m_wakeup_pending_snp;
(*hazard_tbe).m_wakeup_pending_tgr = (*m_tbe_ptr).m_wakeup_pending_tgr;
(deallocateSnpTBE(m_tbe_ptr));
set_tbe(m_tbe_ptr, hazard_tbe);;
    if (((*m_tbe_ptr).m_pendReqType == CHIRequestType_WriteBackFull)) {
        (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false));
    } else {
            if (((*m_tbe_ptr).m_pendReqType == CHIRequestType_WriteCleanFull)) {
                (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false));
            } else {
                    if (((*hazard_tbe).m_pendReqType == CHIRequestType_WriteEvictFull)) {
                        (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false));
                    } else {
                            if (((*hazard_tbe).m_pendReqType == CHIRequestType_Evict)) {
                                (*m_tbe_ptr).m_is_stale = ((*m_tbe_ptr).m_dataValid == (false));
                            } else {
                                    if (((*hazard_tbe).m_pendReqType == CHIRequestType_CleanUnique)) {
                                        (*m_tbe_ptr).m_is_stale = ((*m_tbe_ptr).m_dataValid == (false));
                                    }
                                }
                            }
                        }
                    }
                    (wakeupPendingTgrs(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:RestoreFromHazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr == NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:381: %s.\n", "assert failure");

}
#endif
;
Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
    if (m_unify_repl_TBEs) {
        {
            // Declare message
            [[maybe_unused]] const Cache_ReplacementMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const Cache_ReplacementMsg *>(((*m_replTriggerQueue_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        set_tbe(m_tbe_ptr, (allocateReplacementTBEOnSlot(addr, ((*in_msg_ptr)).m_slot)));;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:386: Allocated replacement TBE on slot %d\n", (*m_tbe_ptr).m_storSlot);
        }
    } else {
        set_tbe(m_tbe_ptr, (allocateReplacementTBE(addr)));;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:390: Allocated replacement TBE on new slot %d\n", (*m_tbe_ptr).m_storSlot);
    }
    (copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
    (incomingTransactionStart(addr, (curTransitionEvent()), initial, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallRequest\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:404: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:405: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_req = (true);
        stallBuffer(&((*m_reqRdy_ptr)), addr);
        (*m_reqRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallSnoop\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:413: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:414: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_snp = (true);
        stallBuffer(&((*m_snpRdy_ptr)), addr);
        (*m_snpRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallLocalEviction(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallLocalEviction\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:422: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:423: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_tgr = (true);
(((*m_replTriggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallLocalEviction: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallSnoop_NoTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallSnoop_NoTBE\n");
    try {
               stallBuffer(&((*m_snpRdy_ptr)), addr);
        (*m_snpRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallSnoop_NoTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallActionOnHazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallActionOnHazard\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:436: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard))) {
    panic("Runtime Error at CHI-cache-actions.sm:437: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_tgr = (true);
        stallBuffer(&((*m_triggerQueue_ptr)), addr);
        (*m_triggerQueue_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallActionOnHazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_Miss\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                }
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdToOwner));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpShared));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_HitUpstream_NoOwner(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_HitUpstream_NoOwner\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdToSharer));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_HitUpstream_NoOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_Miss\n");
    try {
       (*m_tbe_ptr).m_dataToBeInvalid = ((*m_tbe_ptr).m_doCacheFill == (false));
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr == NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:508: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                        if ((*m_tbe_ptr).m_dataToBeInvalid) {
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadOnce));
                        } else {
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
                        }
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                    }
                }
                (*m_tbe_ptr).m_updateDirOnCompAck = (false);
                (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(*m_tbe_ptr).m_updateDirOnCompAck = (false);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnceFwd));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (*m_tbe_ptr).m_updateDirOnCompAck = (false);
        if ((m_cache_entry_ptr == NULL)) {
            (*m_tbe_ptr).m_dataToBeInvalid = (true);
        } else {
                if (((*m_tbe_ptr).m_dataValid == (false))) {
                    (*m_tbe_ptr).m_dataValid = (true);
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Miss\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                }
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_AutoUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_AutoUpgrade\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:594: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_dataUnique = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_AutoUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Upgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Upgrade\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:600: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_use_DCT == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:601: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:602: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:603: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_dataMaybeDirtyUpstream) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    } else {
            if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
            } else {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataValid)) {
                    panic("Runtime Error at CHI-cache-actions.sm:612: %s.\n", "assert failure");

                }
                #endif
                ;
            }
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromRU));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Upgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
(*m_tbe_ptr).m_use_DCT = (((*m_tbe_ptr).m_use_DCT && ((((*m_tbe_ptr).m_dir_sharers).count()) == (1))) && ((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false)));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueFwd));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
            if ((*m_tbe_ptr).m_dataMaybeDirtyUpstream) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
            }
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Hit_InvUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Hit_InvUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Hit_InvUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CleanUnique\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (1))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalidNoReq));
    }
    (*m_tbe_ptr).m_dataUnique = ((*m_tbe_ptr).m_dataUnique || m_is_HN);
        if (((*m_tbe_ptr).m_dataUnique == (false))) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromCU));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_FinishCleanUnique));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CleanUnique_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CleanUnique_Stale\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompUCRespStale));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(*m_tbe_ptr).m_updateDirOnCompAck = (false);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CleanUnique_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finish_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finish_CleanUnique\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:695: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false))) {
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:700: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_is_stale)) {
            panic("Runtime Error at CHI-cache-actions.sm:701: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_stale = (false);
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompUCRespStale));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
    } else {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
            panic("Runtime Error at CHI-cache-actions.sm:708: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataUnique)) {
            panic("Runtime Error at CHI-cache-actions.sm:709: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dir_ownerExists = (false);
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompUCResp));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finish_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_LoadHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_LoadHit\n");
    try {
           if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_LoadHit));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_LoadHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_LoadMiss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_LoadMiss\n");
    try {
           if ((*m_tbe_ptr).m_doCacheFill) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadOnce));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_LoadMiss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreHit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_StoreHit));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
(((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreMiss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreMiss\n");
    try {
           if ((*m_tbe_ptr).m_doCacheFill) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUDataCB));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreMiss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreUpgrade\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:768: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:769: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromStore));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
(((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_LocalWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_LocalWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN || (*m_tbe_ptr).m_dataUnique))) {
    panic("Runtime Error at CHI-cache-actions.sm:778: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_dataUnique = (true);
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
    }
        if (m_comp_wu) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_LocalWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_LocalWrite_AfterUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_LocalWrite_AfterUpgrade\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:796: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:797: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
    if (m_comp_wu) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_LocalWrite_AfterUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_Writeback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_Writeback\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:812: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:813: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    if (m_comp_wu) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnp));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnp));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
    (*m_tbe_ptr).m_dataToBeInvalid = (true);
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_Writeback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_PartialWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_PartialWrite\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:832: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
    }
        if (m_comp_wu) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnpPartial));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnpPartial));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_PartialWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_Forward(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_Forward\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteUnique));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_Forward: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CopyBack(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CopyBack\n");
    try {
           if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteBackFull)) {
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UD_PD));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SD_PD));
    } else {
            if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteEvictFull)) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_WriteEvictFull))) {
                    panic("Runtime Error at CHI-cache-actions.sm:871: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UC));
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SC));
            } else {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_WriteCleanFull))) {
                    panic("Runtime Error at CHI-cache-actions.sm:875: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UD_PD));
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SD_PD));
            }
        }
        (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompDBIDResp));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CopyBack: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CopyBack_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CopyBack_Stale\n");
    try {
       (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_I));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompDBIDRespStale));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).count()) == (1))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_FinishCopyBack_Stale));
    }
    #ifndef NDEBUG
    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != (*m_tbe_ptr).m_requestor)))) {
        panic("Runtime Error at CHI-cache-actions.sm:900: %s.\n", "assert failure");

    }
    #endif
    ;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CopyBack_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finish_CopyBack_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finish_CopyBack_Stale\n");
    try {
           if ((((m_is_HN == (false)) && ((((*m_tbe_ptr).m_dir_sharers).count()) == (0))) && ((*m_tbe_ptr).m_dataValid == (false)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finish_CopyBack_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Evict\n");
    try {
           if ((((m_is_HN == (false)) && ((((*m_tbe_ptr).m_dir_sharers).count()) == (1))) && ((*m_tbe_ptr).m_dataValid == (false)))) {
            if ((*m_tbe_ptr).m_dataUnique) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompIResp));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompIResp));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
            }
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompIResp));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_MaintainCoherence(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_MaintainCoherence\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:938: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataToBeInvalid)) {
        bool has_non_ex_owner
         = ((*m_tbe_ptr).m_dir_ownerExists && (! (*m_tbe_ptr).m_dir_ownerIsExcl));
            if (m_is_HN) {
                    if (((*m_tbe_ptr).m_dataDirty && (! has_non_ex_owner))) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                    }
                } else {
                        if (((((*m_tbe_ptr).m_dir_sharers).isEmpty()) && ((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique))) {
                            #ifndef NDEBUG
                            if (!((! has_non_ex_owner))) {
                                panic("Runtime Error at CHI-cache-actions.sm:952: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                        } else {
                                if (((*m_tbe_ptr).m_dataDirty && (! has_non_ex_owner))) {
                                    #ifndef NDEBUG
                                    if (!((! (((*m_tbe_ptr).m_dir_sharers).isEmpty())))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:957: %s.\n", "assert failure");

                                    }
                                    #endif
                                    ;
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteClean));
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                                }
                            }
                        }
                    } else {
                            if ((*m_tbe_ptr).m_dataValid) {
                                (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
                            }
                        }
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_MaintainCoherence: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_InvalidationSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_InvalidationSnoop\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpInvPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
            if ((((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd) || ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique))) {
                    if ((((*m_tbe_ptr).m_snpNeedsData && ((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false))) || ((*m_tbe_ptr).m_dataValid == (false)))) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
                    } else {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
                    }
                } else {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpCleanInvalid))) {
                        panic("Runtime Error at CHI-cache-actions.sm:986: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
                }
            }
                if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd)) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueFwdCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendInvSnpResp));
                }
                    if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
                    } else {
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
                    }
                    (*m_tbe_ptr).m_dataToBeInvalid = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_InvalidationSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_SnpShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_SnpShared\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpSharedPipe));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
            panic("Runtime Error at CHI-cache-actions.sm:1010: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpShared));
    } else {
            if (((*m_tbe_ptr).m_dataValid == (false))) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1014: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1015: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
            }
        }
            if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpSharedFwd)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdCompData));
            } else {
                    if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpNotSharedDirtyFwd)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpNotSharedDirtyFwdCompData));
                    } else {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpShared))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1026: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpData));
                    }
                }
                    if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
                    } else {
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
                    }
                    (*m_tbe_ptr).m_dataToBeSharedClean = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_SnpShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_SnpOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_SnpOnce\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpOncePipe));
    if (((*m_tbe_ptr).m_dataValid == (false))) {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-actions.sm:1040: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
    }
        if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnceFwd)) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnceFwdCompData));
        } else {
            #ifndef NDEBUG
            if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnce))) {
                panic("Runtime Error at CHI-cache-actions.sm:1049: %s.\n", "assert failure");

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!((*m_tbe_ptr).m_snpNeedsData)) {
                panic("Runtime Error at CHI-cache-actions.sm:1050: %s.\n", "assert failure");

            }
            #endif
            ;
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpData));
        }
            if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
            } else {
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_SnpOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_Evict_BackInvalidte(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_Evict_BackInvalidte\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1064: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_Evict_BackInvalidte: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_Evict\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1072: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_sharers).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1073: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_JustDrop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_JustDrop\n");
    try {
       (*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_JustDrop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_WB_BackInvalidate(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_WB_BackInvalidate\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) || (*m_tbe_ptr).m_dataMaybeDirtyUpstream))) {
    panic("Runtime Error at CHI-cache-actions.sm:1085: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
    if (m_is_HN) {
            if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
            }
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_WB_BackInvalidate: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_WB(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_WB\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
    if (m_is_HN) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataDirty)) {
            panic("Runtime Error at CHI-cache-actions.sm:1106: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
    } else {
            if ((((*m_tbe_ptr).m_dir_sharers).isEmpty())) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1109: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
            } else {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataDirty)) {
                    panic("Runtime Error at CHI-cache-actions.sm:1112: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteClean));
            }
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_WB: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadShared\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1125: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1126: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UD_PD));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_SC));
    if (m_allow_SD) {
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_SD_PD));
    }
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
    (((*m_tbe_ptr).m_dataBlkValid).clear());
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            if (m_allow_SD) {
                (prepareRequest(m_tbe_ptr, CHIRequestType_ReadShared, *out_msg));
            } else {
                (prepareRequest(m_tbe_ptr, CHIRequestType_ReadNotSharedDirty, *out_msg));
            }
            (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
            (*out_msg).m_dataToFwdRequestor = (false);
            (allowRequestRetry(m_tbe_ptr, *out_msg));
            ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadNoSnp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadNoSnp\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1154: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_use_DMT == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1155: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
(((*m_tbe_ptr).m_dataBlkValid).clear());
(outgoingTransactionStart(addr, (curTransitionEvent())));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadNoSnp, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadNoSnp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadNoSnpDMT(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadNoSnpDMT\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1174: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_use_DMT)) {
    panic("Runtime Error at CHI-cache-actions.sm:1175: %s.\n", "assert failure");

}
#endif
;
CHIRequestType req
 = CHIRequestType_ReadNoSnp;
    if (m_enable_DMT_early_dealloc) {
        req = CHIRequestType_ReadNoSnpSep;
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_ReadReceipt));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
    }
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        (prepareRequest(m_tbe_ptr, req, *out_msg));
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (*out_msg).m_dataToFwdRequestor = (true);
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadNoSnpDMT: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadOnce\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1193: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1194: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_I));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
(((*m_tbe_ptr).m_dataBlkValid).clear());
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadOnce, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadUnique\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1214: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1216: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UD_PD));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadUnique, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CleanUnique\n");
    try {
       #ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid || ((((*m_tbe_ptr).m_dir_sharers).count()) > (0))))) {
    panic("Runtime Error at CHI-cache-actions.sm:1234: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1235: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1237: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp_UC));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_CleanUnique, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Evict\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1250: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1251: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1252: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_Evict, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp_I));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_InvSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_InvSnpResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1264: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1265: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_snpNeedsData) || ((*m_tbe_ptr).m_dataUnique && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique)))) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpData));
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpIResp));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_InvSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteBackOrWriteEvict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteBackOrWriteEvict\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1275: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1276: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:1277: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1278: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique || (*m_tbe_ptr).m_dataDirty))) {
    panic("Runtime Error at CHI-cache-actions.sm:1280: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_sharers).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1281: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        if ((*m_tbe_ptr).m_dataDirty) {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteBackFull, *out_msg));
        } else {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteEvictFull, *out_msg));
        }
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
    }
    (clearExpectedReqResp(m_tbe_ptr));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteBackOrWriteEvict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteCleanFull(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteCleanFull\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1298: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1299: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:1300: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1301: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataDirty)) {
    panic("Runtime Error at CHI-cache-actions.sm:1302: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteCleanFull, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteCleanFull: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteNoSnp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteNoSnp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1315: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteNoSnp, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteNoSnp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteNoSnp_Partial(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteNoSnp_Partial\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1329: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteNoSnpPtl, *out_msg));
    (*out_msg).m_accAddr = (*m_tbe_ptr).m_accAddr;
    (*out_msg).m_accSize = (*m_tbe_ptr).m_accSize;
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteNoSnp_Partial: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1345: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        if (((*m_tbe_ptr).m_accSize == (*m_blockSize_ptr))) {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteUniqueFull, *out_msg));
        } else {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteUniquePtl, *out_msg));
            (*out_msg).m_accAddr = (*m_tbe_ptr).m_accAddr;
            (*out_msg).m_accSize = (*m_tbe_ptr).m_accSize;
        }
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
    }
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpCleanInvalid(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpCleanInvalid\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1367: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1368: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1370: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpCleanInvalid, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}
(setExpectedForInvSnoop(m_tbe_ptr, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpCleanInvalid: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpCleanInvalid_NoReq(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpCleanInvalid_NoReq\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1380: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1381: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpCleanInvalid, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (((*out_msg).m_Destination).remove((*m_tbe_ptr).m_requestor));
    #ifndef NDEBUG
    if (!(((((*out_msg).m_Destination).count()) > (0)))) {
        panic("Runtime Error at CHI-cache-actions.sm:1387: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_retToSrc = (false);
    (setExpectedForInvSnoop(m_tbe_ptr, (false)));
    (((*m_tbe_ptr).m_expected_snp_resp).setExpectedCount((((*out_msg).m_Destination).count())));
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpCleanInvalid_NoReq: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1395: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1397: %s.\n", "assert failure");

}
#endif
;
(setExpectedForInvSnoop(m_tbe_ptr, (true)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUnique_RetToSrc(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUnique_RetToSrc\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1409: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1411: %s.\n", "assert failure");

}
#endif
;
(setExpectedForInvSnoop(m_tbe_ptr, (true)));
MachineID dest;
    if ((*m_tbe_ptr).m_dir_ownerExists) {
        dest = (*m_tbe_ptr).m_dir_owner;
    } else {
        dest = (((*m_tbe_ptr).m_dir_sharers).smallestElement());
    }
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
        (((*out_msg).m_Destination).add(dest));
        (*out_msg).m_retToSrc = (true);
        ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
    }
        if (((((*m_tbe_ptr).m_dir_sharers).count()) > (1))) {
            {
                std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
                (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
                (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
                (((*out_msg).m_Destination).remove(dest));
                (*out_msg).m_retToSrc = (false);
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUnique_RetToSrc: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUniqueFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUniqueFwd\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1439: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1441: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1443: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I_Fwded_UC));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I_Fwded_UD_PD));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUniqueFwd, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUniqueFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpShared\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1457: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
    panic("Runtime Error at CHI-cache-actions.sm:1460: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dir_ownerExists)) {
    panic("Runtime Error at CHI-cache-actions.sm:1461: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1462: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1464: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_PD));
(((*m_tbe_ptr).m_expected_snp_resp).setExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpShared, *out_msg));
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
    (*out_msg).m_retToSrc = (false);
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpSharedFwd_ToOwner(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpSharedFwd_ToOwner\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1478: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
    panic("Runtime Error at CHI-cache-actions.sm:1481: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dir_ownerExists)) {
    panic("Runtime Error at CHI-cache-actions.sm:1482: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1483: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1485: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
bool allowFwdSD
 = ((*m_tbe_ptr).m_reqType != CHIRequestType_ReadNotSharedDirty);
bool retToSrc
 = ((*m_tbe_ptr).m_doCacheFill && ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
    if (allowFwdSD) {
            if (retToSrc) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SD_PD));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SD_PD));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SD_PD));
            }
        } else {
                if (retToSrc) {
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SC));
                } else {
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
                }
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_PD_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_PD_Fwded_SC));
            }
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
            {
                std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
                    if (allowFwdSD) {
                        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpSharedFwd, *out_msg));
                    } else {
                        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpNotSharedDirtyFwd, *out_msg));
                    }
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                    (*out_msg).m_retToSrc = retToSrc;
                    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
                }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpSharedFwd_ToOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpSharedFwd_ToSharer(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpSharedFwd_ToSharer\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1527: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1529: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1530: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1531: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1533: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
bool retToSrc
 = (*m_tbe_ptr).m_doCacheFill;
    if (retToSrc) {
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
    } else {
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
    }
    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpSharedFwd, *out_msg));
        (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
        (*out_msg).m_retToSrc = retToSrc;
        ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpSharedFwd_ToSharer: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpOnce\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1554: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1557: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1559: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
            if ((*m_tbe_ptr).m_dir_ownerIsExcl) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_UC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_UD));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SD));
            }
        } else {
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC));
        }
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            (prepareRequest(m_tbe_ptr, CHIRequestType_SnpOnce, *out_msg));
                if ((*m_tbe_ptr).m_dir_ownerExists) {
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                } else {
                    (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
                }
                (*out_msg).m_retToSrc = (true);
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpOnceFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpOnceFwd\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1587: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1590: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1592: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
            if ((*m_tbe_ptr).m_dir_ownerIsExcl) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_UC_Fwded_I));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_UD_Fwded_I));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SD_Fwded_I));
            }
        } else {
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_I));
        }
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            (prepareRequest(m_tbe_ptr, CHIRequestType_SnpOnceFwd, *out_msg));
                if ((*m_tbe_ptr).m_dir_ownerExists) {
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                } else {
                    (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
                }
                (*out_msg).m_retToSrc = (false);
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpOnceFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectNCBWrData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectNCBWrData\n");
    try {
       int num_msgs
 = ((*m_tbe_ptr).m_accSize / m_data_channel_size);
    if ((((*m_tbe_ptr).m_accSize % m_data_channel_size) != (0))) {
        num_msgs = (num_msgs + (1));
    }
    (((*m_tbe_ptr).m_expected_req_resp).clear(num_msgs));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_NCBWrData));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
    (((*m_tbe_ptr).m_dataBlkValid).setMask((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)), (*m_tbe_ptr).m_accSize, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectNCBWrData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectCompAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectCompAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1635: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompAck));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectCompAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectComp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1641: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1647: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1648: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveData(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:1652: %s.\n", ("Received unexpected message"));
        ;
    }
        if ((((((((((*m_tbe_ptr).m_dataBlkValid).isFull()) == (false)) || (((*in_msg_ptr)).m_type == CHIDataType_CompData_UD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CompData_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_NCBWrData))) {
                if ((((*m_tbe_ptr).m_dataBlkValid).isFull())) {
                    (((*m_tbe_ptr).m_dataBlkValid).clear());
                }
                (((*m_tbe_ptr).m_dataBlk).copyPartial(((*in_msg_ptr)).m_dataBlk, ((*in_msg_ptr)).m_bitMask));
                #ifndef NDEBUG
                if (!(((((*m_tbe_ptr).m_dataBlkValid).isOverlap(((*in_msg_ptr)).m_bitMask)) == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1667: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_dataBlkValid).orMask(((*in_msg_ptr)).m_bitMask));
            }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RespSepDataFromCompData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RespSepDataFromCompData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1674: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1675: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receivedRespType(CHIResponseType_RespSepData)) == (false))) {
            if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_RespSepData)) == (false))) {
                panic("Runtime Error at CHI-cache-actions.sm:1679: %s.\n", ("Received unexpected message"));
                ;
            }
                if ((m_is_HN == (false))) {
                    (((*m_tbe_ptr).m_actions).pushFrontNB(Cache_Event_SendCompAck));
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RespSepDataFromCompData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RespSepData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RespSepData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1689: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1690: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_RespSepData)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:1692: %s.\n", ("Received unexpected message"));
        ;
    }
        if ((m_is_HN == (false))) {
            (((*m_tbe_ptr).m_actions).pushFrontNB(Cache_Event_SendCompAck));
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RespSepData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReadReceipt(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReadReceipt\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1701: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1702: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_ReadReceipt)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:1704: %s.\n", ("Received unexpected message"));
        ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReadReceipt: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_SnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_SnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1709: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1710: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_snp_resp).receiveData(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:1714: %s.\n", ("Received unexpected message"));
        ;
    }
        if (((((((((((*m_tbe_ptr).m_dataBlkValid).isFull()) == (false)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC))) {
                if ((((*m_tbe_ptr).m_dataBlkValid).isFull())) {
                    (((*m_tbe_ptr).m_dataBlkValid).clear());
                }
                (((*m_tbe_ptr).m_dataBlk).copyPartial(((*in_msg_ptr)).m_dataBlk, ((*in_msg_ptr)).m_bitMask));
                #ifndef NDEBUG
                if (!(((((*m_tbe_ptr).m_dataBlkValid).isOverlap(((*in_msg_ptr)).m_bitMask)) == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1730: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_dataBlkValid).orMask(((*in_msg_ptr)).m_bitMask));
            }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_SnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1737: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:1740: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UC)) {
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1744: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1745: %s.\n", "assert failure");

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_ownerExists = (false);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) {
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1751: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1752: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_reqType != CHIRequestType_WriteCleanFull)) {
                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                            }
                        } else {
                                if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SC)) {
                                    #ifndef NDEBUG
                                    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:1760: %s.\n", "assert failure");

                                    }
                                    #endif
                                    ;
                                        if (((*m_tbe_ptr).m_reqType != CHIRequestType_WriteCleanFull)) {
                                            (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                        }
                                    } else {
                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) {
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_ownerIsExcl == (false))) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1767: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1768: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                                    if (((*m_tbe_ptr).m_reqType != CHIRequestType_WriteCleanFull)) {
                                                        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                                    }
                                                } else {
                                                        if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_I)) {
                                                            #ifndef NDEBUG
                                                            if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                                                panic("Runtime Error at CHI-cache-actions.sm:1777: %s.\n", "assert failure");

                                                            }
                                                            #endif
                                                            ;
                                                            #ifndef NDEBUG
                                                            if (!(((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)) == (false)))) {
                                                                panic("Runtime Error at CHI-cache-actions.sm:1778: %s.\n", "assert failure");

                                                            }
                                                            #endif
                                                            ;
                                                        } else {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1781: %s.\n", ("Unsuported data type"));
                                                            ;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        }
                                    }
                                    (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromSnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromSnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1789: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_snp_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:1792: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I)) {
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1796: %s.\n", "assert failure");

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_ownerExists = (false);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD)) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1802: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1803: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dir_ownerExists = (false);
                        (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                    } else {
                            if ((((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC))) {
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1815: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1816: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                    if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD))) {
                                        (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                    }
                                        if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) {
                                            (*m_tbe_ptr).m_dir_ownerExists = (true);
                                            (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                        }
                                    } else {
                                            if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SC))) {
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1834: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1835: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                                (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) {
                                                        (*m_tbe_ptr).m_dir_ownerExists = (true);
                                                        (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                                    }
                                                } else {
                                                        if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD))) {
                                                            #ifndef NDEBUG
                                                            if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                                panic("Runtime Error at CHI-cache-actions.sm:1850: %s.\n", "assert failure");

                                                            }
                                                            #endif
                                                            ;
                                                            #ifndef NDEBUG
                                                            if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                                panic("Runtime Error at CHI-cache-actions.sm:1851: %s.\n", "assert failure");

                                                            }
                                                            #endif
                                                            ;
                                                        } else {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1854: %s.\n", ("Unsuported data type"));
                                                            ;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        }
                                    }
                                    (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromSnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1862: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:1865: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if (((((*in_msg_ptr)).m_type == CHIDataType_CompData_UC) || (((*in_msg_ptr)).m_type == CHIDataType_DataSepResp_UC))) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1870: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1871: %s.\n", "assert failure");

                }
                #endif
                ;
                (*m_tbe_ptr).m_dataDirty = (false);
                (*m_tbe_ptr).m_dataUnique = (true);
                (*m_tbe_ptr).m_dataValid = (true);
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1875: %s.\n", "assert failure");

                }
                #endif
                ;
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_UD_PD)) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1878: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1879: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dataDirty = (true);
                        (*m_tbe_ptr).m_dataUnique = (true);
                        (*m_tbe_ptr).m_dataValid = (true);
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1883: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                    } else {
                            if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_SC)) {
                                #ifndef NDEBUG
                                if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1886: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1887: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                (*m_tbe_ptr).m_dataDirty = (false);
                                (*m_tbe_ptr).m_dataUnique = (false);
                                (*m_tbe_ptr).m_dataValid = (true);
                                #ifndef NDEBUG
                                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1891: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                            } else {
                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_SD_PD)) {
                                        #ifndef NDEBUG
                                        if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:1894: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:1895: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        (*m_tbe_ptr).m_dataDirty = (true);
                                        (*m_tbe_ptr).m_dataUnique = (false);
                                        (*m_tbe_ptr).m_dataValid = (true);
                                        #ifndef NDEBUG
                                        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:1899: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                    } else {
                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_I)) {
                                                (*m_tbe_ptr).m_dataValid = (true);
                                                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                                                #ifndef NDEBUG
                                                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1904: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                            } else {
                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UC)) {
                                                        #ifndef NDEBUG
                                                        if (!((*m_tbe_ptr).m_dataUnique)) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1907: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                        (*m_tbe_ptr).m_dataValid = (true);
                                                    } else {
                                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SC)) {
                                                            } else {
                                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) {
                                                                        #ifndef NDEBUG
                                                                        if (!((*m_tbe_ptr).m_dataUnique)) {
                                                                            panic("Runtime Error at CHI-cache-actions.sm:1915: %s.\n", "assert failure");

                                                                        }
                                                                        #endif
                                                                        ;
                                                                        (*m_tbe_ptr).m_dataDirty = (true);
                                                                        (*m_tbe_ptr).m_dataValid = (true);
                                                                            if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteCleanFull)) {
                                                                                #ifndef NDEBUG
                                                                                if (!(((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl))) {
                                                                                    panic("Runtime Error at CHI-cache-actions.sm:1920: %s.\n", "assert failure");

                                                                                }
                                                                                #endif
                                                                                ;
                                                                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                                                                            } else {
                                                                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                                            }
                                                                        } else {
                                                                                if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) {
                                                                                    (*m_tbe_ptr).m_dataDirty = (true);
                                                                                    (*m_tbe_ptr).m_dataValid = (true);
                                                                                    (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                                                } else {
                                                                                        if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_I)) {
                                                                                        } else {
                                                                                            panic("Runtime Error at CHI-cache-actions.sm:1935: %s.\n", ("Unsuported data type"));
                                                                                            ;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    }
                                                }
                                                (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromWUDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromWUDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1943: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).test((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)))))) {
            panic("Runtime Error at CHI-cache-actions.sm:1945: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).test((((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)) + (*m_tbe_ptr).m_accSize) - (1)))))) {
            panic("Runtime Error at CHI-cache-actions.sm:1947: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!((((*in_msg_ptr)).m_type == CHIDataType_NCBWrData))) {
            panic("Runtime Error at CHI-cache-actions.sm:1949: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_dataDirty = (true);
            if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteUniquePtl)) {
                (*m_tbe_ptr).m_dataValid = ((*m_tbe_ptr).m_dataValid || ((*m_tbe_ptr).m_accSize == (*m_blockSize_ptr)));
            } else {
                (*m_tbe_ptr).m_dataValid = ((*m_tbe_ptr).m_accSize == (*m_blockSize_ptr));
            }
            }
        }
        (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromWUDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromCUResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromCUResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1963: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_type == CHIResponseType_Comp_UC))) {
    panic("Runtime Error at CHI-cache-actions.sm:1965: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1966: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_dataUnique = ((*m_tbe_ptr).m_dataValid || ((((*m_tbe_ptr).m_dir_sharers).count()) > (0)));
}
(printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromCUResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromSnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromSnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1975: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_snp_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:1978: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if (((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC))) {
                (*m_tbe_ptr).m_dataDirty = (true);
                (*m_tbe_ptr).m_dataValid = (true);
                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
            } else {
                    if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD))) {
                        (*m_tbe_ptr).m_dataDirty = (true);
                        (*m_tbe_ptr).m_dataValid = (true);
                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                    } else {
                            if (((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SC))) {
                                (*m_tbe_ptr).m_dataValid = (true);
                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                            } else {
                                    if (((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UC) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD))) {
                                        (*m_tbe_ptr).m_dataValid = (true);
                                        (*m_tbe_ptr).m_dataUnique = (true);
                                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                                            if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD)) {
                                                (*m_tbe_ptr).m_dataDirty = (true);
                                            }
                                        } else {
                                            panic("Runtime Error at CHI-cache-actions.sm:2013: %s.\n", ("Unsuported data type"));
                                            ;
                                        }
                                    }
                                }
                            }
                            }
                        }
                        (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromSnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromReqResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromReqResp\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*in_msg_ptr)).m_type == CHIResponseType_CompAck) && (*m_tbe_ptr).m_updateDirOnCompAck)) {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_requestor == ((*in_msg_ptr)).m_responder))) {
            panic("Runtime Error at CHI-cache-actions.sm:2023: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_dir_sharers).add(((*in_msg_ptr)).m_responder));
            if ((*m_tbe_ptr).m_requestorToBeOwner) {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                    panic("Runtime Error at CHI-cache-actions.sm:2028: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2029: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_requestorToBeExclusiveOwner == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:2030: %s.\n", "assert failure");

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_owner = ((*in_msg_ptr)).m_responder;
                (*m_tbe_ptr).m_dir_ownerExists = (true);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
            } else {
                    if ((*m_tbe_ptr).m_requestorToBeExclusiveOwner) {
                        #ifndef NDEBUG
                        if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                            panic("Runtime Error at CHI-cache-actions.sm:2036: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2037: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2038: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dir_owner = ((*in_msg_ptr)).m_responder;
                        (*m_tbe_ptr).m_dir_ownerExists = (true);
                        (*m_tbe_ptr).m_dir_ownerIsExcl = (true);
                    }
                }
            }
            }
            (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromReqResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromSnpResp\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I)) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2053: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            if (((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))) {
                (*m_tbe_ptr).m_dir_ownerExists = (false);
            }
        } else {
                if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC)) {
                    #ifndef NDEBUG
                    if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2061: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                    #ifndef NDEBUG
                    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2062: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                } else {
                        if (((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SC) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD))) {
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                panic("Runtime Error at CHI-cache-actions.sm:2068: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                panic("Runtime Error at CHI-cache-actions.sm:2069: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                            (*m_tbe_ptr).m_dir_ownerExists = (false);
                            (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                            (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD)) {
                                    (*m_tbe_ptr).m_dir_ownerExists = (true);
                                    (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                }
                            } else {
                                    if (((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I_Fwded_UC) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I_Fwded_UD_PD))) {
                                        #ifndef NDEBUG
                                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2082: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2083: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                        (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                        (*m_tbe_ptr).m_dir_ownerExists = (true);
                                        (*m_tbe_ptr).m_dir_ownerIsExcl = (true);
                                        (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                    } else {
                                            if ((((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_UC_Fwded_I) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_UD_Fwded_I)) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SD_Fwded_I))) {
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:2095: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:2096: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                            } else {
                                                    if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_I)) {
                                                        #ifndef NDEBUG
                                                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:2100: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                        #ifndef NDEBUG
                                                        if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:2101: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (*m_tbe_ptr).m_dir_ownerExists;
                                }
                                (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2111: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2115: %s.\n", ("Received unexpected message"));
        ;
    }
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_stale == (*m_tbe_ptr).m_is_stale))) {
        panic("Runtime Error at CHI-cache-actions.sm:2117: %s.\n", "assert failure");

    }
    #endif
    ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp_WUNeedComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp_WUNeedComp\n");
    try {
       (*m_tbe_ptr).m_defer_expected_comp = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp_WUNeedComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp_WUComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp_WUComp\n");
    try {
           if ((*m_tbe_ptr).m_defer_expected_comp) {
        (*m_tbe_ptr).m_defer_expected_comp = (false);
    } else {
            if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_Comp)) == (false))) {
                panic("Runtime Error at CHI-cache-actions.sm:2129: %s.\n", ("Received unexpected message"));
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp_WUComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_SnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_SnpResp\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2134: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_snp_resp).receiveResp(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2138: %s.\n", ("Received unexpected message"));
        ;
    }
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_stale == (*m_tbe_ptr).m_is_stale))) {
        panic("Runtime Error at CHI-cache-actions.sm:2140: %s.\n", "assert failure");

    }
    #endif
    ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_SnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RetryAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RetryAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2145: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2146: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_rcvdRetryAck == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2147: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_rcvdRetryAck = (true);
(((*m_destsWaitingRetry_ptr)).addNetDest((*m_tbe_ptr).m_pendReqDest));
(enqueueDoRetry(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RetryAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_PCrdGrant(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_PCrdGrant\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2154: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_rcvdRetryCredit == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2155: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_rcvdRetryCredit = (true);
(enqueueDoRetry(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_PCrdGrant: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Retry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Retry\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2161: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryCredit)) {
    panic("Runtime Error at CHI-cache-actions.sm:2162: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryAck)) {
    panic("Runtime Error at CHI-cache-actions.sm:2163: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Retry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Retry_DVM(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Retry_DVM\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2170: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryCredit)) {
    panic("Runtime Error at CHI-cache-actions.sm:2171: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryAck)) {
    panic("Runtime Error at CHI-cache-actions.sm:2172: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequestRetryDVM(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(((*m_destsWaitingRetry_ptr)).removeNetDest((*m_tbe_ptr).m_pendReqDest));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Retry_DVM: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RetryAck_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RetryAck_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2181: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*hazard_tbe).m_rcvdRetryAck == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2182: %s.\n", "assert failure");

}
#endif
;
(*hazard_tbe).m_rcvdRetryAck = (true);
(((*m_destsWaitingRetry_ptr)).addNetDest((*hazard_tbe).m_pendReqDest));
(enqueueDoRetry(hazard_tbe));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RetryAck_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_PCrdGrant_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_PCrdGrant_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2190: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*hazard_tbe).m_rcvdRetryCredit == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2191: %s.\n", "assert failure");

}
#endif
;
(*hazard_tbe).m_rcvdRetryCredit = (true);
(enqueueDoRetry(hazard_tbe));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_PCrdGrant_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Retry_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Retry_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2198: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*hazard_tbe).m_rcvdRetryCredit)) {
    panic("Runtime Error at CHI-cache-actions.sm:2199: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*hazard_tbe).m_rcvdRetryAck)) {
    panic("Runtime Error at CHI-cache-actions.sm:2200: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequestRetry(hazard_tbe, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Retry_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2207: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2208: %s.\n", "assert failure");

}
#endif
;
bool is_rd_once
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadOnce);
bool is_rd_shared
 = (((*m_tbe_ptr).m_reqType == CHIRequestType_ReadShared) || ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadNotSharedDirty));
bool is_rd_nsd
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadNotSharedDirty);
bool is_rd_unique
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadUnique);
bool snd_unique_on_rs
 = (((m_fwd_unique_on_readshared || (*m_tbe_ptr).m_dataToBeInvalid) && (*m_tbe_ptr).m_dataUnique) && (((*m_tbe_ptr).m_dir_sharers).isEmpty()));
bool snd_dirty_on_rs
 = ((is_rd_shared && (! is_rd_nsd)) && (*m_tbe_ptr).m_dataToBeInvalid);
    if (is_rd_once) {
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_I;
    } else {
            if ((is_rd_unique || (is_rd_shared && snd_unique_on_rs))) {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataUnique)) {
                    panic("Runtime Error at CHI-cache-actions.sm:2225: %s.\n", "assert failure");

                }
                #endif
                ;
                    if ((*m_tbe_ptr).m_dataDirty) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UD_PD;
                    } else {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UC;
                    }
                } else {
                        if (is_rd_shared) {
                                if (((*m_tbe_ptr).m_dataDirty && snd_dirty_on_rs)) {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SD_PD;
                                } else {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
                                }
                            } else {
                                panic("Runtime Error at CHI-cache-actions.sm:2240: %s.\n", ("Invalid request type"));
                                ;
                            }
                        }
                    }
                    (*m_tbe_ptr).m_dataMaybeDirtyUpstream = ((((*m_tbe_ptr).m_dataMaybeDirtyUpstream || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_SD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UC));
                    (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (((*m_tbe_ptr).m_requestorToBeExclusiveOwner || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UC));
                    (*m_tbe_ptr).m_requestorToBeOwner = ((*m_tbe_ptr).m_requestorToBeOwner || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_SD_PD));
                    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                    (setupPendingSend(m_tbe_ptr));
                    (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WBData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WBData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2259: %s.\n", "assert failure");

}
#endif
;
    if (m_is_HN) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2261: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataDirty)) {
            panic("Runtime Error at CHI-cache-actions.sm:2262: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2263: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_NCBWrData;
    } else {
            if (((*m_tbe_ptr).m_dataValid == (false))) {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_is_stale)) {
                    panic("Runtime Error at CHI-cache-actions.sm:2268: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_dataBlkValid).fillMask());
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_I;
            } else {
                    if ((*m_tbe_ptr).m_dataUnique) {
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2272: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if ((*m_tbe_ptr).m_dataDirty) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_UD_PD;
                            } else {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_UC;
                            }
                        } else {
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
                                panic("Runtime Error at CHI-cache-actions.sm:2279: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                                if ((*m_tbe_ptr).m_dataDirty) {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_SD_PD;
                                } else {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_SC;
                                }
                            }
                        }
                    }
                    (*m_tbe_ptr).m_snd_destination = (mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr));
                    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WBData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WUData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WUData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2292: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dataBlkValid).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2293: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_NCBWrData;
(*m_tbe_ptr).m_snd_destination = (mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr));
(setupPendingPartialSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WUData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckWUComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckWUComp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2300: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_defer_expected_comp) {
        (*m_tbe_ptr).m_defer_expected_comp = (false);
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckWUComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespData\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2309: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2310: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2311: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2312: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_snpNeedsData || ((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpCleanInvalid))) || (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpShared))) || (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique))))) {
    panic("Runtime Error at CHI-cache-actions.sm:2317: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataToBeInvalid) {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2320: %s.\n", "assert failure");

        }
        #endif
        ;
            if ((*m_tbe_ptr).m_dataDirty) {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_PD;
            } else {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I;
            }
        } else {
                if ((*m_tbe_ptr).m_dataToBeSharedClean) {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2327: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                        if ((*m_tbe_ptr).m_dataDirty) {
                            (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_PD;
                        } else {
                            (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC;
                        }
                    } else {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnce))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2334: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_dataDirty && (*m_tbe_ptr).m_dataUnique)) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_UD;
                            } else {
                                    if ((*m_tbe_ptr).m_dataDirty) {
                                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SD;
                                    } else {
                                            if ((*m_tbe_ptr).m_dataUnique) {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_UC;
                                            } else {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC;
                                            }
                                        }
                                    }
                                }
                            }
                            (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                            (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpUniqueFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpUniqueFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2351: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeInvalid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2352: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2353: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataDirty) {
        (*m_tbe_ptr).m_fwdedState = Cache_State_UD;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UD_PD;
    } else {
        (*m_tbe_ptr).m_fwdedState = Cache_State_UC;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UC;
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpUniqueFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpSharedFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpSharedFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2369: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:2370: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2371: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataDirty) {
        (*m_tbe_ptr).m_fwdedState = Cache_State_SD;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SD_PD;
    } else {
        (*m_tbe_ptr).m_fwdedState = Cache_State_SC;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
    }
        if ((*m_tbe_ptr).m_snpNeedsData) {
            (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedData));
        } else {
            (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
        }
        (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
        (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpSharedFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpNSDFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpNSDFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2391: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:2392: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2393: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
(*m_tbe_ptr).m_fwdedState = Cache_State_SC;
    if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_snpNeedsData)) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedData));
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
    }
    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpNSDFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpOnceFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpOnceFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2408: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_fwdedState = Cache_State_I;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_I;
(((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
(*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
(setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpOnceFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespDataFwded(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespDataFwded\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2419: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:2422: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2423: %s.\n", "assert failure");

}
#endif
;
bool keepData
 = (((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) || ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
    if (keepData) {
            if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_Fwded_SD_PD;
            } else {
                    if (((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_PD_Fwded_SC;
                    } else {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_Fwded_SC;
                    }
                }
            } else {
                    if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_Fwded_SD_PD;
                    } else {
                            if (((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_PD_Fwded_SC;
                            } else {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_Fwded_SC;
                            }
                        }
                    }
                    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespDataFwded: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_FwdSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_FwdSnpResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2452: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2453: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    bool keepData
     = (((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) || ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
        if ((keepData && (*m_tbe_ptr).m_dataToBeSharedClean)) {
            #ifndef NDEBUG
            if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_SnpSharedFwd) || ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpNotSharedDirtyFwd)))) {
                panic("Runtime Error at CHI-cache-actions.sm:2466: %s.\n", "assert failure");

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                panic("Runtime Error at CHI-cache-actions.sm:2467: %s.\n", "assert failure");

            }
            #endif
            ;
                if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                    (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_SD_PD;
                } else {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2471: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                    (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_SC;
                }
            } else {
                    if (keepData) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnceFwd))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2476: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_I))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2477: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_dataUnique && ((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream))) {
                                (*out_msg).m_type = CHIResponseType_SnpResp_UD_Fwded_I;
                            } else {
                                    if ((*m_tbe_ptr).m_dataUnique) {
                                        (*out_msg).m_type = CHIResponseType_SnpResp_UC_Fwded_I;
                                    } else {
                                            if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                                                (*out_msg).m_type = CHIResponseType_SnpResp_SD_Fwded_I;
                                            } else {
                                                (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_I;
                                            }
                                        }
                                    }
                                } else {
                                    #ifndef NDEBUG
                                    if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:2489: %s.\n", "assert failure");

                                    }
                                    #endif
                                    ;
                                    #ifndef NDEBUG
                                    if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:2490: %s.\n", "assert failure");

                                    }
                                    #endif
                                    ;
                                        if (((*m_tbe_ptr).m_fwdedState == Cache_State_UD)) {
                                            (*out_msg).m_type = CHIResponseType_SnpResp_I_Fwded_UD_PD;
                                        } else {
                                            #ifndef NDEBUG
                                            if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_UC))) {
                                                panic("Runtime Error at CHI-cache-actions.sm:2494: %s.\n", "assert failure");

                                            }
                                            #endif
                                            ;
                                            (*out_msg).m_type = CHIResponseType_SnpResp_I_Fwded_UC;
                                        }
                                    }
                                }
                                ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
                            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_FwdSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Data(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Data\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_snd_pendEv)) {
    panic("Runtime Error at CHI-cache-actions.sm:2502: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_snd_pendBytes).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2503: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_snd_pendEv = (false);
{
    std::shared_ptr<CHIDataMsg> out_msg = std::make_shared<CHIDataMsg>(clockEdge());
    (*out_msg).m_addr = (*m_tbe_ptr).m_addr;
    (*out_msg).m_type = (*m_tbe_ptr).m_snd_msgType;
    int offset
     = (((*m_tbe_ptr).m_snd_pendBytes).firstBitSet((true)));
    #ifndef NDEBUG
    if (!((offset < (*m_blockSize_ptr)))) {
        panic("Runtime Error at CHI-cache-actions.sm:2510: %s.\n", "assert failure");

    }
    #endif
    ;
    int range
     = ((((*m_tbe_ptr).m_snd_pendBytes).firstBitSet((false), offset)) - offset);
    #ifndef NDEBUG
    if (!(((range > (0)) && (range <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:2512: %s.\n", "assert failure");

    }
    #endif
    ;
        if ((range > m_data_channel_size)) {
            range = m_data_channel_size;
        }
        (((*m_tbe_ptr).m_snd_pendBytes).setMask(offset, range, (false)));
        (*out_msg).m_dataBlk = (*m_tbe_ptr).m_dataBlk;
        (((*out_msg).m_bitMask).setMask(offset, range));
        (*out_msg).m_responder = m_machineID;
        (((*out_msg).m_Destination).add((*m_tbe_ptr).m_snd_destination));
        ((*m_datOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_data_latency)));
    }
    (scheduleSendData(m_tbe_ptr, (1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Data: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_RespSepData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_RespSepData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2531: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_RespSepData;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_RespSepData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompI(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompI\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2541: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2544: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != (*m_tbe_ptr).m_requestor)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2545: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_dir_sharers).remove((*m_tbe_ptr).m_requestor));
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_I;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompI: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompUC(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompUC\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2558: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_UC;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompUC: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompUC_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompUC_Stale\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2568: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_UC;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_stale = (true);
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompUC_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2581: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompAck;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompI_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompI_Stale\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2591: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_I;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_stale = (true);
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompI_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompDBIDResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompDBIDResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2604: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompDBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompDBIDResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompDBIDResp_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompDBIDResp_Stale\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2614: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompDBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_stale = (true);
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompDBIDResp_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DBIDResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DBIDResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2627: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_DBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DBIDResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Comp_WU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Comp_WU\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2637: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((m_comp_wu_latency + m_response_latency))));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Comp_WU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespI(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespI\n");
    try {
       {
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
        if (((*m_tbe_ptr).m_is_dvm_tbe || (*m_tbe_ptr).m_is_dvm_snp_tbe)) {
            (*out_msg).m_usesTxnId = (true);
            (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
        }
        (*out_msg).m_type = CHIResponseType_SnpResp_I;
        (*out_msg).m_responder = m_machineID;
        (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
        ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespI: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_RetryAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_RetryAck\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const Cache_RetryTriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const Cache_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
    (*out_msg).m_usesTxnId = ((*in_msg_ptr)).m_usesTxnId;
    (*out_msg).m_type = CHIResponseType_RetryAck;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_retryDest));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_RetryAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_PCrdGrant(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_PCrdGrant\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const Cache_RetryTriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const Cache_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
    (*out_msg).m_usesTxnId = ((*in_msg_ptr)).m_usesTxnId;
    (*out_msg).m_type = CHIResponseType_PCrdGrant;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_retryDest));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_PCrdGrant: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckUpgrade_FromStoreOrRU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckUpgrade_FromStoreOrRU\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2691: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataUnique) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2694: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendReadUnique));
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_is_stale)) {
            panic("Runtime Error at CHI-cache-actions.sm:2700: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_stale = (false);
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendCompAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckUpgrade_FromStoreOrRU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckUpgrade_FromCU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckUpgrade_FromCU\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2707: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_dataUnique == (false))) {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2710: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (false);
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendCompAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckUpgrade_FromCU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_UpdateCacheFromTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_UpdateCacheFromTBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2720: %s.\n", "assert failure");

}
#endif
;
Cache_State final
 = (*m_tbe_ptr).m_finalState;
    if ((((((((((((((final == Cache_State_UD_RSC) || (final == Cache_State_SD_RSC)) || (final == Cache_State_UC_RSC)) || (final == Cache_State_SC_RSC)) || (final == Cache_State_UD)) || (final == Cache_State_UD_T)) || (final == Cache_State_SD)) || (final == Cache_State_UC)) || (final == Cache_State_SC)) || (final == Cache_State_UC_RU)) || (final == Cache_State_UD_RU)) || (final == Cache_State_UD_RSD)) || (final == Cache_State_SD_RSD))) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2727: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2728: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:2729: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_cache_entry_ptr).m_DataBlk = (*m_tbe_ptr).m_dataBlk;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2731: Cached data %s pfb %s\n", (*m_tbe_ptr).m_dataBlk, (*m_cache_entry_ptr).m_HWPrefetched);
    } else {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2734: %s.\n", "assert failure");

        }
        #endif
        ;
            if ((m_cache_entry_ptr != NULL)) {
                (((*m_cache_ptr)).deallocate(addr));
                unset_cache_entry(m_cache_entry_ptr);;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_UpdateCacheFromTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_UpdateDirectoryFromTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_UpdateDirectoryFromTBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2743: %s.\n", "assert failure");

}
#endif
;
Cache_State final
 = (*m_tbe_ptr).m_finalState;
    if ((((((((((((((final == Cache_State_UD_RSC) || (final == Cache_State_SD_RSC)) || (final == Cache_State_UC_RSC)) || (final == Cache_State_SC_RSC)) || (final == Cache_State_UC_RU)) || (final == Cache_State_UD_RU)) || (final == Cache_State_UD_RSD)) || (final == Cache_State_SD_RSD)) || (final == Cache_State_RU)) || (final == Cache_State_RSC)) || (final == Cache_State_RSD)) || (final == Cache_State_RUSD)) || (final == Cache_State_RUSC))) {
        Cache_DirEntry* dir_entry
         = (getDirEntry(addr));
        #ifndef NDEBUG
        if (!((dir_entry != NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:2751: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2752: %s.\n", "assert failure");

        }
        #endif
        ;
        (*dir_entry).m_ownerExists = (*m_tbe_ptr).m_dir_ownerExists;
        (*dir_entry).m_ownerIsExcl = (*m_tbe_ptr).m_dir_ownerIsExcl;
        (*dir_entry).m_owner = (*m_tbe_ptr).m_dir_owner;
        (*dir_entry).m_sharers = (*m_tbe_ptr).m_dir_sharers;
    } else {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) && (((*m_tbe_ptr).m_dir_sharers).isEmpty())))) {
            panic("Runtime Error at CHI-cache-actions.sm:2758: %s.\n", "assert failure");

        }
        #endif
        ;
            if ((((*m_directory_ptr)).isTagPresent(addr))) {
                (((*m_directory_ptr)).deallocate(addr));
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_UpdateDirectoryFromTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Deallocate_CacheBlock(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Deallocate_CacheBlock\n");
    try {
       #ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2766: %s.\n", "assert failure");

}
#endif
;
(((*m_cache_ptr)).deallocate(addr));
unset_cache_entry(m_cache_entry_ptr);;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Deallocate_CacheBlock: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Allocate_DirEntry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Allocate_DirEntry\n");
    try {
       #ifndef NDEBUG
if (!(((((*m_directory_ptr)).isTagPresent(addr)) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2772: %s.\n", "assert failure");

}
#endif
;
(((*m_directory_ptr)).allocate(addr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Allocate_DirEntry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Deallocate_DirEntry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Deallocate_DirEntry\n");
    try {
       #ifndef NDEBUG
if (!((((*m_directory_ptr)).isTagPresent(addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2777: %s.\n", "assert failure");

}
#endif
;
(((*m_directory_ptr)).deallocate(addr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Deallocate_DirEntry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckCacheFill(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckCacheFill\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2782: %s.\n", "assert failure");

}
#endif
;
bool need_fill
 = (((*m_tbe_ptr).m_dataValid && ((*m_tbe_ptr).m_dataToBeInvalid == (false))) && (*m_tbe_ptr).m_doCacheFill);
bool execute_next
 = (true);
    if ((need_fill && (m_cache_entry_ptr != NULL))) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_DataArrayWrite));
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_FillPipe));
    } else {
            if ((need_fill && (((*m_cache_ptr)).cacheAvail(addr)))) {
                set_cache_entry(m_cache_entry_ptr, (((*m_cache_ptr)).allocate(addr, new Cache_CacheEntry)));;
                (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_DataArrayWriteOnFill));
                (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_FillPipe));
            } else {
                    if (need_fill) {
                        execute_next = (false);
                        Addr victim_addr
                         = (((*m_cache_ptr)).cacheProbe(addr));
                        Cache_CacheEntry* victim_entry
                         = (getCacheEntry(victim_addr));
                        #ifndef NDEBUG
                        if (!((victim_entry != NULL))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2807: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        Cache_TBE* victim_tbe
                         = (getCurrentActiveTBE(victim_addr));
                            if (((victim_tbe == NULL) && (victim_entry != NULL))) {
                                DPRINTF(RubySlicc, "CHI-cache-actions.sm:2813: Eviction for %#x victim: %#x state=%s\n", addr, victim_addr, (*victim_entry).m_state);
                                {
                                    std::shared_ptr<Cache_ReplacementMsg> out_msg = std::make_shared<Cache_ReplacementMsg>(clockEdge());
                                    (*out_msg).m_addr = victim_addr;
                                    (*out_msg).m_from_addr = addr;
                                        if (m_unify_repl_TBEs) {
                                            (*out_msg).m_slot = (*m_tbe_ptr).m_storSlot;
                                            DPRINTF(RubySlicc, "CHI-cache-actions.sm:2820: Reusing slot %d\n", (*out_msg).m_slot);
                                        }
                                        ((*m_replTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
                                    }
                                } else {
                                    DPRINTF(RubySlicc, "CHI-cache-actions.sm:2824: Eviction for %#x victim: %#x state=%s\n", addr, victim_addr, (*victim_tbe).m_state);
                                    (*victim_tbe).m_wakeup_pending_tgr = (true);
                                }
                                        stallBuffer(&((*m_triggerQueue_ptr)), victim_addr);
                                        (*m_triggerQueue_ptr).stallMessage(victim_addr, clockEdge());
                                        
                            }
                        }
                    }
                        if (execute_next) {
                            (((*m_triggerQueue_ptr)).dequeue((clockEdge())));
                            (clearPendingAction(m_tbe_ptr));
                            (processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));
                        } else {
                            (wakeupPendingSnps(m_tbe_ptr));
                        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckCacheFill: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_DeallocateRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_DeallocateRequest\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2846: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2847: %s.\n", "assert failure");

}
#endif
;
(wakeupPendingReqs(m_tbe_ptr));
(wakeupPendingSnps(m_tbe_ptr));
(wakeupPendingTgrs(m_tbe_ptr));
    if ((*m_tbe_ptr).m_is_req_tbe) {
        (deallocateReqTBE(m_tbe_ptr));
        (processRetryQueue());
    } else {
            if ((*m_tbe_ptr).m_is_snp_tbe) {
                (deallocateSnpTBE(m_tbe_ptr));
            } else {
                (deallocateReplacementTBE(m_tbe_ptr));
                    if (m_unify_repl_TBEs) {
                        (processRetryQueue());
                    }
                }
            }
            unset_tbe(m_tbe_ptr);;
            (incomingTransactionEnd(addr, (curTransitionNextState())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_DeallocateRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_DeallocateDvmRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_DeallocateDvmRequest\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2871: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2872: %s.\n", "assert failure");

}
#endif
;
(wakeupPendingReqs(m_tbe_ptr));
(wakeupPendingSnps(m_tbe_ptr));
(wakeupPendingTgrs(m_tbe_ptr));
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:2879: %s.\n", "assert failure");

}
#endif
;
(deallocateDvmTBE(m_tbe_ptr));
unset_tbe(m_tbe_ptr);;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_DeallocateDvmRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_DeallocateDvmSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_DeallocateDvmSnoop\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2885: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2886: %s.\n", "assert failure");

}
#endif
;
(wakeupPendingReqs(m_tbe_ptr));
(wakeupPendingSnps(m_tbe_ptr));
(wakeupPendingTgrs(m_tbe_ptr));
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_snp_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:2893: %s.\n", "assert failure");

}
#endif
;
(deallocateDvmSnoopTBE(m_tbe_ptr));
unset_tbe(m_tbe_ptr);;
(incomingTransactionEnd(addr, (curTransitionNextState()), (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_DeallocateDvmSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_ReqRdyQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_ReqRdyQueue\n");
    try {
       (((*m_reqRdy_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_ReqRdyQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_RespInQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_RespInQueue\n");
    try {
       (((*m_rspIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_RespInQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_SnoopRdyQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_SnoopRdyQueue\n");
    try {
       (((*m_snpRdy_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_SnoopRdyQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_DataInQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_DataInQueue\n");
    try {
       (((*m_datIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_DataInQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_TriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_TriggerQueue\n");
    try {
       (((*m_triggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_TriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_ReplTriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_ReplTriggerQueue\n");
    try {
       (((*m_replTriggerQueue_ptr)).dequeue((clockEdge())));
        wakeUpBuffer(&((*m_triggerQueue_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_ReplTriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_RetryTriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_RetryTriggerQueue\n");
    try {
       (((*m_retryTriggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_RetryTriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_SnpInPort(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_SnpInPort\n");
    try {
       (((*m_snpIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_SnpInPort: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_SeqInPort(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_SeqInPort\n");
    try {
       (((*m_mandatoryQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_SeqInPort: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ProcessNextState(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ProcessNextState\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2942: %s.\n", "assert failure");

}
#endif
;
(processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ProcessNextState: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ProcessNextState_ClearPending(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ProcessNextState_ClearPending\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2947: %s.\n", "assert failure");

}
#endif
;
(clearPendingAction(m_tbe_ptr));
(processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ProcessNextState_ClearPending: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_LoadHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_LoadHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2953: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_Load))) {
    panic("Runtime Error at CHI-cache-actions.sm:2954: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2956: %s.\n", "assert failure");

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2957: Read data %s\n", (*m_tbe_ptr).m_dataBlk);
        (((*m_sequencer_ptr)).readCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (false)));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_LoadHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_StoreHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_StoreHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2963: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine) || ((*m_tbe_ptr).m_reqType == CHIRequestType_Store)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2965: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2967: %s.\n", "assert failure");

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2968: Write before %s\n", (*m_tbe_ptr).m_dataBlk);
        (((*m_sequencer_ptr)).writeCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (false)));
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2970: Write after %s\n", (*m_tbe_ptr).m_dataBlk);
        (*m_tbe_ptr).m_dataDirty = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_StoreHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_ExpressPrefetchHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_ExpressPrefetchHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr == NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2977: %s.\n", "assert failure");

}
#endif
;
(((*m_storTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-actions.sm:2979: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(m_use_prefetcher)) {
    panic("Runtime Error at CHI-cache-actions.sm:2980: %s.\n", "assert failure");

}
#endif
;
(((*m_cache_ptr)).profilePrefetchHit());
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!(((*in_msg_ptr)).m_is_local_pf)) {
    panic("Runtime Error at CHI-cache-actions.sm:2984: %s.\n", "assert failure");

}
#endif
;
(notifyPfComplete(((*in_msg_ptr)).m_addr));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_ExpressPrefetchHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_Miss\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2993: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_is_local_pf)) {
        #ifndef NDEBUG
        if (!(m_use_prefetcher)) {
            panic("Runtime Error at CHI-cache-actions.sm:2995: %s.\n", "assert failure");

        }
        #endif
        ;
        (notifyPfComplete((*m_tbe_ptr).m_addr));
    } else {
            if (((*m_tbe_ptr).m_dataValid && ((*m_tbe_ptr).m_reqType == CHIRequestType_Load))) {
                DPRINTF(RubySlicc, "CHI-cache-actions.sm:2999: Read data %s\n", (*m_tbe_ptr).m_dataBlk);
                (((*m_sequencer_ptr)).readCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (true)));
            } else {
                    if (((*m_tbe_ptr).m_dataValid && (((*m_tbe_ptr).m_reqType == CHIRequestType_Store) || ((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine)))) {
                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3004: Write before %s\n", (*m_tbe_ptr).m_dataBlk);
                        (((*m_sequencer_ptr)).writeCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (true)));
                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:3006: Write after %s\n", (*m_tbe_ptr).m_dataBlk);
                        (*m_tbe_ptr).m_dataDirty = (true);
                        int use_timeout_latency
                         = (scLockLatency());
                            if ((use_timeout_latency > (0))) {
                                    if ((*m_tbe_ptr).m_hasUseTimeout) {
                                        #ifndef NDEBUG
                                        if (!((((*m_useTimerTable_ptr)).isSet((*m_tbe_ptr).m_addr)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:3013: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                    } else {
                                        (((*m_useTimerTable_ptr)).set((*m_tbe_ptr).m_addr, ((clockEdge()) + (cyclesToTicks((intToCycles(use_timeout_latency)))))));
                                        (*m_tbe_ptr).m_hasUseTimeout = (true);
                                    }
                                    (scLockDecayLatency());
                                }
                            }
                        }
                    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Unset_Timeout_TBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Unset_Timeout_TBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3027: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_hasUseTimeout)) {
    panic("Runtime Error at CHI-cache-actions.sm:3028: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_useTimerTable_ptr)).isSet((*m_tbe_ptr).m_addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3029: %s.\n", "assert failure");

}
#endif
;
(((*m_useTimerTable_ptr)).unset((*m_tbe_ptr).m_addr));
(*m_tbe_ptr).m_hasUseTimeout = (false);
        wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Unset_Timeout_TBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Unset_Timeout_Cache(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Unset_Timeout_Cache\n");
    try {
       #ifndef NDEBUG
if (!((((*m_useTimerTable_ptr)).isSet(addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3037: %s.\n", "assert failure");

}
#endif
;
(((*m_useTimerTable_ptr)).unset(addr));
        wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Unset_Timeout_Cache: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_WriteUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_WriteUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3043: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3044: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine) || ((*m_tbe_ptr).m_reqType == CHIRequestType_Store)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3046: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:3047: %s.\n", "assert failure");

}
#endif
;
(((*m_sequencer_ptr)).writeUniqueCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk));
DPRINTF(RubySlicc, "CHI-cache-actions.sm:3049: WriteUnique data %s\n", (*m_tbe_ptr).m_dataBlk);
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:3051: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_dataBlkValid).setMask((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)), (*m_tbe_ptr).m_accSize));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_WriteUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Miss\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3056: %s.\n", "assert failure");

}
#endif
;
bool is_demand
 = (((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false));
bool is_remote_can_notify
 = ((*m_tbe_ptr).m_is_remote_pf && m_upstream_prefetch_trains_prefetcher);
    if (is_demand) {
        (((*m_cache_ptr)).profileDemandMiss());
    } else {
        #ifndef NDEBUG
        if (!((m_use_prefetcher || (*m_tbe_ptr).m_is_remote_pf))) {
            panic("Runtime Error at CHI-cache-actions.sm:3062: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_cache_ptr)).profilePrefetchMiss());
    }
        if (((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid) && (is_demand || is_remote_can_notify))) {
            bool is_read
             = (false);
                if ((isReadReqType((*m_tbe_ptr).m_reqType))) {
                    is_read = (true);
                } else {
                    #ifndef NDEBUG
                    if (!((isWriteReqType((*m_tbe_ptr).m_reqType)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:3071: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                }
                (notifyPfMiss((*m_tbe_ptr).m_seqReq, is_read, (*m_tbe_ptr).m_dataBlk));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Hit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3081: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3082: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:3083: %s.\n", "assert failure");

}
#endif
;
bool is_demand
 = (((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false));
bool is_remote_can_notify
 = ((*m_tbe_ptr).m_is_remote_pf && m_upstream_prefetch_trains_prefetcher);
    if (is_demand) {
        (((*m_cache_ptr)).profileDemandHit());
    } else {
        #ifndef NDEBUG
        if (!((m_use_prefetcher || (*m_tbe_ptr).m_is_remote_pf))) {
            panic("Runtime Error at CHI-cache-actions.sm:3089: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_cache_ptr)).profilePrefetchHit());
    }
        if (((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid) && (is_demand || is_remote_can_notify))) {
            bool is_read
             = (false);
                if ((isReadReqType((*m_tbe_ptr).m_reqType))) {
                    is_read = (true);
                } else {
                    #ifndef NDEBUG
                    if (!((isWriteReqType((*m_tbe_ptr).m_reqType)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:3098: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                }
                (notifyPfHit((*m_tbe_ptr).m_seqReq, is_read, (*m_tbe_ptr).m_dataBlk));
                (*m_cache_entry_ptr).m_HWPrefetched = (false);
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Fill(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Fill\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3107: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3108: %s.\n", "assert failure");

}
#endif
;
    if ((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid)) {
        (*m_cache_entry_ptr).m_HWPrefetched = ((*m_tbe_ptr).m_is_local_pf || ((*m_tbe_ptr).m_is_remote_pf && (m_upstream_prefetch_trains_prefetcher == (false))));
        (notifyPfFill((*m_tbe_ptr).m_seqReq, (*m_tbe_ptr).m_dataBlk, (*m_tbe_ptr).m_is_local_pf));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Fill: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Eviction(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Eviction\n");
    try {
           if ((m_sc_lock_enabled && (((*m_sequencer_ptr)).llscCheckMonitor(addr)))) {
        DPRINTF(LLSC, "CHI-cache-actions.sm:3123: Invalidating monitored address %#x\n", addr);
        (scLockIncLatency());
    }
        if (m_send_evictions) {
            DPRINTF(RubySlicc, "CHI-cache-actions.sm:3127: Sending invalidation for %#x to the sequencer\n", addr);
            (((*m_sequencer_ptr)).evictionCallback(addr));
        }
            if ((m_use_prefetcher && (m_cache_entry_ptr != NULL))) {
                (notifyPfEvict(addr, (*m_cache_entry_ptr).m_HWPrefetched));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Eviction: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingStart(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingStart\n");
    try {
       (outgoingTransactionStart(addr, (curTransitionEvent())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingStart: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingEnd_DataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3140: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        (outgoingTransactionEnd(addr, (*m_tbe_ptr).m_rcvdRetryAck));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingEnd_DataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingEnd_DatalessResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DatalessResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3148: %s.\n", "assert failure");

}
#endif
;
(outgoingTransactionEnd(addr, (*m_tbe_ptr).m_rcvdRetryAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingEnd_DatalessResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::TagArrayRead(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing TagArrayRead\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3153: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((tagLatency(((((*m_tbe_ptr).m_reqType == CHIRequestType_Load) || ((*m_tbe_ptr).m_reqType == CHIRequestType_Store)) || ((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine)))))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:TagArrayRead: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::TagArrayWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing TagArrayWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3161: %s.\n", "assert failure");

}
#endif
;
    if ((m_dealloc_wait_for_tag && ((*m_tbe_ptr).m_hasUseTimeout == (false)))) {
        (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((tagLatency((false))))));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:TagArrayWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DataArrayRead(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DataArrayRead\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3171: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((dataLatency()))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DataArrayRead: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DataArrayWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DataArrayWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3176: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3177: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_doCacheFill)) {
    panic("Runtime Error at CHI-cache-actions.sm:3178: %s.\n", "assert failure");

}
#endif
;
    if (m_wait_for_cache_wr) {
        (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((dataLatency()))));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DataArrayWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ReadHitPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ReadHitPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3185: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_read_hit_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ReadHitPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ReadMissPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ReadMissPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3190: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_read_miss_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ReadMissPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::WriteFEPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing WriteFEPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3195: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_write_fe_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:WriteFEPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::WriteBEPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing WriteBEPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3200: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_write_be_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:WriteBEPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::FillPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing FillPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3205: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_fill_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:FillPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpSharedPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpSharedPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3210: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_snp_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpSharedPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpInvPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpInvPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3215: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((m_snp_latency + m_snp_inv_latency))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpInvPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpOncePipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpOncePipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3220: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_snp_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpOncePipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DvmTlbi(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmTlbi\n");
    try {
       {
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_DvmOpNonSync, *out_msg));
    DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3230: Sending DvmOpNonSync to %d\n", (getMiscNodeMachine()));
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
    (((*out_msg).m_Destination).clear());
    (((*out_msg).m_Destination).add((getMiscNodeMachine())));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3260: Pushing pending nonsync to blocklist %16x\n", (*m_tbe_ptr).m_addr);
(((*m_dvmPendingNonSyncsBlockingSync_ptr)).push(Cache_Event_DvmTlbi_Initiate));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DvmTlbi: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Try_Send_DvmSync(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Try_Send_DvmSync\n");
    try {
           if ((((*m_dvmPendingNonSyncsBlockingSync_ptr)).empty())) {
        DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3268: Nonsync queue is empty so %016x can proceed\n", (*m_tbe_ptr).m_addr);
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DvmSync_Send));
    } else {
        #ifndef NDEBUG
        if (!((! (*m_dvmHasPendingSyncOp_ptr)))) {
            panic("Runtime Error at CHI-cache-actions.sm:3271: %s.\n", "assert failure");

        }
        #endif
        ;
        DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3272: Nonsync queue is not empty so %016x is now pending\n", (*m_tbe_ptr).m_addr);
        (*m_dvmHasPendingSyncOp_ptr) = (true);
        (*m_dvmPendingSyncOp_ptr) = addr;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Try_Send_DvmSync: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Try_Send_Pending_DvmSync(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Try_Send_Pending_DvmSync\n");
    try {
       #ifndef NDEBUG
if (!((! (((*m_dvmPendingNonSyncsBlockingSync_ptr)).empty())))) {
    panic("Runtime Error at CHI-cache-actions.sm:3284: %s.\n", "assert failure");

}
#endif
;
DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3285: Popping nonsync from blocklist %16x\n", (*m_tbe_ptr).m_addr);
(((*m_dvmPendingNonSyncsBlockingSync_ptr)).pop());
    if (((((*m_dvmPendingNonSyncsBlockingSync_ptr)).empty()) && (*m_dvmHasPendingSyncOp_ptr))) {
        DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3289: Blocklist now empty, pending op %16x can proceed\n", (*m_dvmPendingSyncOp_ptr));
        Cache_TBE* syncTBE
         = (getDvmTBE((*m_dvmPendingSyncOp_ptr)));
        #ifndef NDEBUG
        if (!((syncTBE != NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:3291: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*syncTBE).m_actions).push(Cache_Event_DvmSync_Send));
        (*m_dvmHasPendingSyncOp_ptr) = (false);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Try_Send_Pending_DvmSync: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DvmSync(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmSync\n");
    try {
       {
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_DvmOpSync, *out_msg));
    DPRINTF(RubyProtocol, "CHI-cache-actions.sm:3301: Sending DvmOpSync to %d\n", (getMiscNodeMachine()));
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
    (((*out_msg).m_Destination).clear());
    (((*out_msg).m_Destination).add((getMiscNodeMachine())));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DvmSync: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DvmTlbi_NCBWrData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmTlbi_NCBWrData\n");
    try {
       {
    std::shared_ptr<CHIDataMsg> out_msg = std::make_shared<CHIDataMsg>(clockEdge());
    (*out_msg).m_addr = (*m_tbe_ptr).m_addr;
    (*out_msg).m_type = CHIDataType_NCBWrData;
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
    (((*out_msg).m_dataBlk).clear());
    (((*out_msg).m_bitMask).setMask((0), (8)));
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).clear());
    (((*out_msg).m_Destination).add((getMiscNodeMachine())));
    ((*m_datOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_data_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DvmTlbi_NCBWrData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DvmSync_NCBWrData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DvmSync_NCBWrData\n");
    try {
       {
    std::shared_ptr<CHIDataMsg> out_msg = std::make_shared<CHIDataMsg>(clockEdge());
    (*out_msg).m_addr = (*m_tbe_ptr).m_addr;
    (*out_msg).m_type = CHIDataType_NCBWrData;
    (*out_msg).m_usesTxnId = (true);
    (*out_msg).m_txnId = (*m_tbe_ptr).m_addr;
    (((*out_msg).m_dataBlk).clear());
    (((*out_msg).m_bitMask).setMask((0), (8)));
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).clear());
    (((*out_msg).m_Destination).add((getMiscNodeMachine())));
    ((*m_datOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_data_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DvmSync_NCBWrData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DvmTlbi_CompCallback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DvmTlbi_CompCallback\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3363: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:3364: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_DvmTlbi_Initiate))) {
    panic("Runtime Error at CHI-cache-actions.sm:3365: %s.\n", "assert failure");

}
#endif
;
(((*m_sequencer_ptr)).unaddressedCallback((*m_tbe_ptr).m_addr, RubyRequestType_TLBI));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DvmTlbi_CompCallback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DvmSync_CompCallback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DvmSync_CompCallback\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3370: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:3371: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_DvmSync_Initiate))) {
    panic("Runtime Error at CHI-cache-actions.sm:3372: %s.\n", "assert failure");

}
#endif
;
(((*m_sequencer_ptr)).unaddressedCallback((*m_tbe_ptr).m_addr, RubyRequestType_TLBI_SYNC));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DvmSync_CompCallback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_DvmSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_DvmSnoop\n");
    try {
       bool was_retried
 = (false);
{
    // Declare message
    [[maybe_unused]] const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateDvmSnoopTBE(addr, (*in_msg_ptr))));;
}
(incomingTransactionStart(addr, (curTransitionEvent()), Cache_State_I, was_retried, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_DvmSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DvmExtTlbi_EnqueueSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DvmExtTlbi_EnqueueSnpResp\n");
    try {
       (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_dvm_ext_tlbi_latency)));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpIResp));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DvmExtTlbi_EnqueueSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DvmExtSync_TriggerCallback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DvmExtSync_TriggerCallback\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3397: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_dvm_snp_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:3398: %s.\n", "assert failure");

}
#endif
;
(((*m_sequencer_ptr)).unaddressedCallback((*m_tbe_ptr).m_addr, RubyRequestType_TLBI_EXT_SYNC));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DvmExtSync_TriggerCallback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingStart_DVM(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingStart_DVM\n");
    try {
       (outgoingTransactionStart(addr, (curTransitionEvent()), (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingStart_DVM: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingEnd_DVM(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DVM\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3407: %s.\n", "assert failure");

}
#endif
;
(outgoingTransactionEnd(addr, (*m_tbe_ptr).m_rcvdRetryAck, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingEnd_DVM: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

void
Cache_Controller::notifyPfHit(const RequestPtr& param_req, const bool& param_is_read, const DataBlock& param_blk)
{

}
void
Cache_Controller::notifyPfMiss(const RequestPtr& param_req, const bool& param_is_read, const DataBlock& param_blk)
{

}
void
Cache_Controller::notifyPfFill(const RequestPtr& param_req, const DataBlock& param_blk, const bool& param_from_pf)
{

}
void
Cache_Controller::notifyPfEvict(const Addr& param_blkAddr, const bool& param_hwPrefetched)
{

}
void
Cache_Controller::notifyPfComplete(const Addr& param_addr)
{

}
Cache_CacheEntry*
Cache_Controller::getCacheEntry(const Addr& param_addr)
{
return static_cast<Cache_CacheEntry *>((((*m_cache_ptr)).lookup(param_addr)));

}
Cache_CacheEntry*
Cache_Controller::nullCacheEntry()
{
return NULL;

}
Cache_DirEntry*
Cache_Controller::getDirEntry(const Addr& param_addr)
{
    if ((((*m_directory_ptr)).isTagPresent(param_addr))) {
        return (((*m_directory_ptr)).lookup(param_addr));
    } else {
        return NULL;
    }

}
Cache_State
Cache_Controller::getState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, const Addr& param_addr)
{
    if ((param_tbe != NULL)) {
        return (*param_tbe).m_state;
    } else {
            if ((param_cache_entry != NULL)) {
                return (*param_cache_entry).m_state;
            } else {
                Cache_DirEntry* dir_entry
                 = (getDirEntry(param_addr));
                    if ((dir_entry != NULL)) {
                        return (*dir_entry).m_state;
                    } else {
                        return Cache_State_I;
                    }
                }
            }

}
void
Cache_Controller::setState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, const Addr& param_addr, const Cache_State& param_state)
{
    if ((param_tbe != NULL)) {
        (*param_tbe).m_state = param_state;
    }
        if ((param_cache_entry != NULL)) {
            (*param_cache_entry).m_state = param_state;
        }
        Cache_DirEntry* dir_entry
         = (getDirEntry(param_addr));
            if ((dir_entry != NULL)) {
                (*dir_entry).m_state = param_state;
            }

}
Cache_TBE*
Cache_Controller::nullTBE()
{
return NULL;

}
Cache_TBE*
Cache_Controller::getDvmTBE(const Addr& param_txnId)
{
Cache_TBE* dvm_tbe
 = (((*m_dvmTBEs_ptr)).lookup(param_txnId));
    if ((dvm_tbe != NULL)) {
        return dvm_tbe;
    }
    Cache_TBE* dvm_snp_tbe
     = (((*m_dvmSnpTBEs_ptr)).lookup(param_txnId));
        if ((dvm_snp_tbe != NULL)) {
            return dvm_snp_tbe;
        }
        return NULL;

}
Cache_TBE*
Cache_Controller::getCurrentActiveTBE(const Addr& param_addr)
{
Cache_TBE* snp_tbe
 = (((*m_snpTBEs_ptr)).lookup(param_addr));
    if ((snp_tbe != NULL)) {
        return snp_tbe;
    }
    Cache_TBE* req_tbe
     = (((*m_TBEs_ptr)).lookup(param_addr));
    Cache_TBE* repl_tbe
     = (((*m_replTBEs_ptr)).lookup(param_addr));
        if ((req_tbe != NULL)) {
            #ifndef NDEBUG
            if (!((repl_tbe == NULL))) {
                panic("Runtime Error at CHI-cache-funcs.sm:152: %s.\n", "assert failure");

            }
            #endif
            ;
            return req_tbe;
        }
            if ((repl_tbe != NULL)) {
                #ifndef NDEBUG
                if (!((req_tbe == NULL))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:156: %s.\n", "assert failure");

                }
                #endif
                ;
                return repl_tbe;
            }
            return NULL;

}
AccessPermission
Cache_Controller::getAccessPermission(const Addr& param_addr)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
    if ((tbe != NULL)) {
        #ifndef NDEBUG
        if (!(((Cache_State_to_permission((*tbe).m_state)) == AccessPermission_Busy))) {
            panic("Runtime Error at CHI-cache-funcs.sm:165: %s.\n", "assert failure");

        }
        #endif
        ;
        bool cu_requester_or_responder
         = (((*tbe).m_reqType == CHIRequestType_CleanUnique) || ((*tbe).m_pendReqType == CHIRequestType_CleanUnique));
            if ((((((*tbe).m_expected_req_resp).hasExpected()) || (((*tbe).m_expected_snp_resp).hasExpected())) && (! cu_requester_or_responder))) {
                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:175: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Busy);
                return AccessPermission_Busy;
            } else {
                    if (((*tbe).m_dataValid && ((*tbe).m_dataMaybeDirtyUpstream == (false)))) {
                            if ((*tbe).m_dataUnique) {
                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:180: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Read_Write);
                                return AccessPermission_Read_Write;
                            } else {
                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:183: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Read_Only);
                                return AccessPermission_Read_Only;
                            }
                        } else {
                            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:187: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Busy);
                            return AccessPermission_Busy;
                        }
                    }
                }
                Cache_CacheEntry* cache_entry
                 = (getCacheEntry(param_addr));
                    if ((cache_entry != NULL)) {
                        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:193: %x %s,%s\n", param_addr, (*cache_entry).m_state, (Cache_State_to_permission((*cache_entry).m_state)));
                        return (Cache_State_to_permission((*cache_entry).m_state));
                    }
                    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:196: %x %s,%s\n", param_addr, Cache_State_I, AccessPermission_NotPresent);
                    return AccessPermission_NotPresent;

}
void
Cache_Controller::setAccessPermission(Cache_CacheEntry* param_cache_entry, const Addr& param_addr, const Cache_State& param_state)
{
    if ((param_cache_entry != NULL)) {
        ((*(param_cache_entry)).changePermission((Cache_State_to_permission(param_state))));
    }

}
void
Cache_Controller::functionalRead(const Addr& param_addr, Packet* param_pkt, WriteMask& param_mask)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
Cache_CacheEntry* cache_entry
 = (getCacheEntry(param_addr));
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:211: functionalRead %x\n", param_addr);
WriteMask read_mask;
bool dirty
 = (false);
bool from_tbe
 = (false);
    if ((tbe != NULL)) {
        from_tbe = (true);
        dirty = (*tbe).m_dataDirty;
            if ((*tbe).m_dataValid) {
                ((read_mask).fillMask());
            } else {
                read_mask = (*tbe).m_dataBlkValid;
                dirty = (((((((((((((dirty || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CompData_UD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CompData_SD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CBWrData_UD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CBWrData_SD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_NCBWrData))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_UD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_Fwded_SD_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_PD_Fwded_SC))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_Fwded_SD_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_PD_Fwded_SC)));
            }
        } else {
                if (((cache_entry != NULL) && (((Cache_State_to_permission((*cache_entry).m_state)) == AccessPermission_Read_Write) || ((Cache_State_to_permission((*cache_entry).m_state)) == AccessPermission_Read_Only)))) {
                    from_tbe = (false);
                    ((read_mask).fillMask());
                    dirty = (((((((((*cache_entry).m_state == Cache_State_UD) || ((*cache_entry).m_state == Cache_State_UD_RSC)) || ((*cache_entry).m_state == Cache_State_SD)) || ((*cache_entry).m_state == Cache_State_SD_RSC)) || ((*cache_entry).m_state == Cache_State_UD_RU)) || ((*cache_entry).m_state == Cache_State_UD_RSD)) || ((*cache_entry).m_state == Cache_State_SD_RSD)) || ((*cache_entry).m_state == Cache_State_UD_T));
                }
            }
            WriteMask test_mask
             = param_mask;
            ((test_mask).orMask(read_mask));
                if (((((param_mask).containsMask(test_mask)) == (false)) || dirty)) {
                        if (from_tbe) {
                                if ((testAndReadMask(param_addr, (*tbe).m_dataBlk, read_mask, param_pkt))) {
                                    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:256: functionalRead tbe %x %s dirty=%d %s %s\n", param_addr, (*tbe).m_dataBlk, (*tbe).m_dataDirty, read_mask, param_mask);
                                    ((param_mask).orMask(read_mask));
                                }
                            } else {
                                    if ((testAndReadMask(param_addr, (*cache_entry).m_DataBlk, read_mask, param_pkt))) {
                                        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:261: functionalRead cache %x %s dirty=%d %s %s\n", param_addr, (*cache_entry).m_DataBlk, dirty, read_mask, param_mask);
                                        ((param_mask).orMask(read_mask));
                                    }
                                }
                            }

}
int
Cache_Controller::functionalWrite(const Addr& param_addr, Packet* param_pkt)
{
int num_functional_writes
 = (0);
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
    if ((tbe != NULL)) {
        num_functional_writes = (num_functional_writes + (testAndWrite(param_addr, (*tbe).m_dataBlk, param_pkt)));
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:274: functionalWrite tbe %x %s\n", param_addr, (*tbe).m_dataBlk);
    }
    Cache_CacheEntry* cache_entry
     = (getCacheEntry(param_addr));
        if ((cache_entry != NULL)) {
            num_functional_writes = (num_functional_writes + (testAndWrite(param_addr, (*cache_entry).m_DataBlk, param_pkt)));
            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:280: functionalWrite cache %x %s\n", param_addr, (*cache_entry).m_DataBlk);
        }
        return num_functional_writes;

}
Cycles
Cache_Controller::mandatoryQueueLatency(const RubyRequestType& param_type)
{
return (intToCycles((1)));

}
Cycles
Cache_Controller::tagLatency(const bool& param_from_sequencer)
{
    if (param_from_sequencer) {
        return ((((*m_cache_ptr)).getTagLatency()) - (intToCycles((1))));
    } else {
        return (((*m_cache_ptr)).getTagLatency());
    }

}
Cycles
Cache_Controller::dataLatency()
{
return (((*m_cache_ptr)).getDataLatency());

}
bool
Cache_Controller::inCache(const Addr& param_addr)
{
Cache_CacheEntry* entry
 = (getCacheEntry((makeLineAddress(param_addr))));
    if ((((entry != NULL) == (false)) || ((*entry).m_state == Cache_State_I))) {
        return (false);
    } else {
        return (true);
    }

}
bool
Cache_Controller::hasBeenPrefetched(const Addr& param_addr)
{
Cache_CacheEntry* entry
 = (getCacheEntry((makeLineAddress(param_addr))));
    if ((entry != NULL)) {
        return (*entry).m_HWPrefetched;
    } else {
        return (false);
    }

}
bool
Cache_Controller::inMissQueue(const Addr& param_addr)
{
Addr line_addr
 = (makeLineAddress(param_addr));
Cache_TBE* tbe
 = (getCurrentActiveTBE(line_addr));
return (tbe != NULL);

}
void
Cache_Controller::notifyCoalesced(const Addr& param_addr, const RubyRequestType& param_type, const RequestPtr& param_req, const DataBlock& param_data_blk, const bool& param_was_miss)
{
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:330: notifyCoalesced(addr=%#x, type=%s, was_miss=%d)\n", param_addr, param_type, param_was_miss);
    if (param_was_miss) {
        (((*m_cache_ptr)).profileDemandMiss());
    } else {
        (((*m_cache_ptr)).profileDemandHit());
    }
        if (m_use_prefetcher) {
            bool is_read
             = (((param_type == RubyRequestType_LD) || (param_type == RubyRequestType_Load_Linked)) || (param_type == RubyRequestType_IFETCH));
                if (param_was_miss) {
                    (notifyPfMiss(param_req, is_read, param_data_blk));
                } else {
                    (notifyPfHit(param_req, is_read, param_data_blk));
                }
            }

}
void
Cache_Controller::clearExpectedReqResp(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:355: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:356: %s.\n", "assert failure");

}
#endif
;
(((*param_tbe).m_expected_req_resp).clear(((*m_blockSize_ptr) / m_data_channel_size)));

}
void
Cache_Controller::clearExpectedSnpResp(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:361: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:362: %s.\n", "assert failure");

}
#endif
;
(((*param_tbe).m_expected_snp_resp).clear(((*m_blockSize_ptr) / m_data_channel_size)));

}
void
Cache_Controller::initializeTBE(Cache_TBE* param_tbe, const Addr& param_addr, const int& param_storSlot)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:367: %s.\n", "assert failure");

}
#endif
;
(*param_tbe).m_wakeup_pending_req = (false);
(*param_tbe).m_wakeup_pending_snp = (false);
(*param_tbe).m_wakeup_pending_tgr = (false);
(*param_tbe).m_addr = param_addr;
(*param_tbe).m_storSlot = param_storSlot;
(clearExpectedReqResp(param_tbe));
(clearExpectedSnpResp(param_tbe));
(*param_tbe).m_defer_expected_comp = (false);
(*param_tbe).m_requestorToBeOwner = (false);
(*param_tbe).m_requestorToBeExclusiveOwner = (false);
(*param_tbe).m_updateDirOnCompAck = (true);
(*param_tbe).m_dataToBeInvalid = (false);
(*param_tbe).m_dataToBeSharedClean = (false);
(*param_tbe).m_doCacheFill = (false);
(*param_tbe).m_pendReqType = CHIRequestType_null;
(*param_tbe).m_pendAction = Cache_Event_null;
(*param_tbe).m_finalState = Cache_State_null;
(*param_tbe).m_delayNextAction = (intToTick((0)));
(*param_tbe).m_is_stale = (false);

}
Cache_TBE*
Cache_Controller::allocateRequestTBE(const Addr& param_addr, const CHIRequestMsg& param_in_msg)
{
(((*m_storTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:402: %s.\n", "assert failure");

}
#endif
;
(((*m_TBEs_ptr)).allocate(param_addr));
Cache_TBE* tbe
 = (((*m_TBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, (((*m_storTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:409: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:410: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:411: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:412: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_is_req_tbe = (true);
(*tbe).m_accAddr = (param_in_msg).m_accAddr;
(*tbe).m_accSize = (param_in_msg).m_accSize;
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_isSeqReqValid = (param_in_msg).m_isSeqReqValid;
(*tbe).m_seqReq = (param_in_msg).m_seqReq;
(*tbe).m_is_local_pf = (param_in_msg).m_is_local_pf;
(*tbe).m_is_remote_pf = (param_in_msg).m_is_remote_pf;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
(*tbe).m_hasUseTimeout = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateDvmRequestTBE(const Addr& param_txnId, const CHIRequestMsg& param_in_msg)
{
(((*m_storDvmTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storDvmTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:436: %s.\n", "assert failure");

}
#endif
;
(((*m_dvmTBEs_ptr)).allocate(param_txnId));
Cache_TBE* tbe
 = (((*m_dvmTBEs_ptr)).lookup(param_txnId));
(initializeTBE(tbe, param_txnId, (((*m_storDvmTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:444: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:445: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:446: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:447: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_is_dvm_tbe = (true);
(*tbe).m_accAddr = param_txnId;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_isSeqReqValid = (param_in_msg).m_isSeqReqValid;
(*tbe).m_seqReq = (param_in_msg).m_seqReq;
(*tbe).m_is_local_pf = (param_in_msg).m_is_local_pf;
(*tbe).m_is_remote_pf = (param_in_msg).m_is_remote_pf;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
(*tbe).m_hasUseTimeout = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateSnoopTBE(const Addr& param_addr, const CHIRequestMsg& param_in_msg)
{
(((*m_storSnpTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storSnpTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:472: %s.\n", "assert failure");

}
#endif
;
(((*m_snpTBEs_ptr)).allocate(param_addr));
Cache_TBE* tbe
 = (((*m_snpTBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, (((*m_storSnpTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:478: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:479: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:480: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:481: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_is_snp_tbe = (true);
(*tbe).m_accAddr = param_addr;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_fwdRequestor = (param_in_msg).m_fwdRequestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_snpNeedsData = (param_in_msg).m_retToSrc;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateDvmSnoopTBE(const Addr& param_txnId, const CHIRequestMsg& param_in_msg)
{
(((*m_storDvmSnpTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storDvmSnpTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:501: %s.\n", "assert failure");

}
#endif
;
(((*m_dvmSnpTBEs_ptr)).allocate(param_txnId));
Cache_TBE* tbe
 = (((*m_dvmSnpTBEs_ptr)).lookup(param_txnId));
(initializeTBE(tbe, param_txnId, (((*m_storDvmSnpTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:507: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:508: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:509: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:510: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_is_dvm_snp_tbe = (true);
(*tbe).m_accAddr = param_txnId;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_fwdRequestor = (param_in_msg).m_fwdRequestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_snpNeedsData = (param_in_msg).m_retToSrc;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::_allocateReplacementTBE(const Addr& param_addr, const int& param_storSlot)
{
Cache_TBE* tbe
 = (((*m_replTBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, param_storSlot));
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:532: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:533: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_dvm_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:534: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_is_repl_tbe = (true);
(*tbe).m_accAddr = param_addr;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = m_machineID;
(*tbe).m_reqType = CHIRequestType_null;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateReplacementTBE(const Addr& param_addr)
{
#ifndef NDEBUG
if (!((((*m_storReplTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:550: %s.\n", "assert failure");

}
#endif
;
(((*m_replTBEs_ptr)).allocate(param_addr));
return (_allocateReplacementTBE(param_addr, (((*m_storReplTBEs_ptr)).addEntryToNewSlot())));

}
Cache_TBE*
Cache_Controller::allocateReplacementTBEOnSlot(const Addr& param_addr, const int& param_slot)
{
#ifndef NDEBUG
if (!(m_unify_repl_TBEs)) {
    panic("Runtime Error at CHI-cache-funcs.sm:558: %s.\n", "assert failure");

}
#endif
;
(((*m_storTBEs_ptr)).addEntryToSlot(param_slot));
(((*m_replTBEs_ptr)).allocate(param_addr));
return (_allocateReplacementTBE(param_addr, param_slot));

}
Cache_TBE*
Cache_Controller::getHazardTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:566: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:567: %s.\n", "assert failure");

}
#endif
;
Cache_TBE* hazard_tbe
 = (((*m_TBEs_ptr)).lookup((*param_tbe).m_addr));
    if ((*param_tbe).m_is_req_hazard) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_is_repl_hazard == (false)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:570: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        #ifndef NDEBUG
        if (!((*param_tbe).m_is_repl_hazard)) {
            panic("Runtime Error at CHI-cache-funcs.sm:572: %s.\n", "assert failure");

        }
        #endif
        ;
        hazard_tbe = (((*m_replTBEs_ptr)).lookup((*param_tbe).m_addr));
    }
    #ifndef NDEBUG
    if (!((hazard_tbe != NULL))) {
        panic("Runtime Error at CHI-cache-funcs.sm:575: %s.\n", "assert failure");

    }
    #endif
    ;
    return hazard_tbe;

}
void
Cache_Controller::scheduleSendData(Cache_TBE* param_tbe, const int& param_when)
{
    if (((((*param_tbe).m_snd_pendBytes).count()) > (0))) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_snd_pendEv == (false)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:581: %s.\n", "assert failure");

        }
        #endif
        ;
        (*param_tbe).m_snd_pendEv = (true);
        (*param_tbe).m_pendAction = Cache_Event_TX_Data;
        {
            std::shared_ptr<Cache_TriggerMsg> out_msg = std::make_shared<Cache_TriggerMsg>(clockEdge());
            (*out_msg).m_addr = (*param_tbe).m_addr;
            (*out_msg).m_from_hazard = ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard);
            ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((intToCycles(param_when)))));
        }
    }

}
void
Cache_Controller::setupPendingSend(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:593: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:594: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*param_tbe).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-funcs.sm:596: %s.\n", "assert failure");

}
#endif
;
(((*param_tbe).m_snd_pendBytes).fillMask());
(scheduleSendData(param_tbe, (0)));

}
void
Cache_Controller::setupPendingPartialSend(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:602: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:603: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*param_tbe).m_dataBlkValid).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:605: %s.\n", "assert failure");

}
#endif
;
(*param_tbe).m_snd_pendBytes = (*param_tbe).m_dataBlkValid;
(scheduleSendData(param_tbe, (0)));

}
void
Cache_Controller::prepareRequest(Cache_TBE* param_tbe, const CHIRequestType& param_type, CHIRequestMsg& param_out_msg)
{
(param_out_msg).m_addr = (*param_tbe).m_addr;
(param_out_msg).m_accAddr = (*param_tbe).m_addr;
(param_out_msg).m_accSize = (*m_blockSize_ptr);
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_type = param_type;
(param_out_msg).m_allowRetry = (false);
(*param_tbe).m_pendReqAllowRetry = (false);
(*param_tbe).m_rcvdRetryAck = (false);
(*param_tbe).m_rcvdRetryCredit = (false);
(*param_tbe).m_pendReqType = param_type;
(param_out_msg).m_isSeqReqValid = (*param_tbe).m_isSeqReqValid;
(param_out_msg).m_seqReq = (*param_tbe).m_seqReq;
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = ((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf);

}
void
Cache_Controller::allowRequestRetry(Cache_TBE* param_tbe, CHIRequestMsg& param_out_msg)
{
(param_out_msg).m_allowRetry = (true);
(*param_tbe).m_pendReqAllowRetry = (true);
(*param_tbe).m_pendReqAccAddr = (param_out_msg).m_accAddr;
(*param_tbe).m_pendReqAccSize = (param_out_msg).m_accSize;
(*param_tbe).m_pendReqDest = (param_out_msg).m_Destination;
(*param_tbe).m_pendReqD2OrigReq = (param_out_msg).m_dataToFwdRequestor;
(*param_tbe).m_pendReqRetToSrc = (param_out_msg).m_retToSrc;

}
void
Cache_Controller::prepareRequestRetry(Cache_TBE* param_tbe, CHIRequestMsg& param_out_msg)
{
#ifndef NDEBUG
if (!((*param_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-funcs.sm:640: %s.\n", "assert failure");

}
#endif
;
(*param_tbe).m_pendReqAllowRetry = (false);
(param_out_msg).m_allowRetry = (false);
(param_out_msg).m_addr = (*param_tbe).m_addr;
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_accAddr = (*param_tbe).m_pendReqAccAddr;
(param_out_msg).m_accSize = (*param_tbe).m_pendReqAccSize;
(param_out_msg).m_type = (*param_tbe).m_pendReqType;
(param_out_msg).m_Destination = (*param_tbe).m_pendReqDest;
(param_out_msg).m_dataToFwdRequestor = (*param_tbe).m_pendReqD2OrigReq;
(param_out_msg).m_retToSrc = (*param_tbe).m_pendReqRetToSrc;
(param_out_msg).m_isSeqReqValid = (*param_tbe).m_isSeqReqValid;
(param_out_msg).m_seqReq = (*param_tbe).m_seqReq;
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = ((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf);

}
void
Cache_Controller::prepareRequestRetryDVM(Cache_TBE* param_tbe, CHIRequestMsg& param_out_msg)
{
#ifndef NDEBUG
if (!((*param_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-funcs.sm:660: %s.\n", "assert failure");

}
#endif
;
(*param_tbe).m_pendReqAllowRetry = (false);
(param_out_msg).m_allowRetry = (false);
(param_out_msg).m_addr = (*param_tbe).m_addr;
(param_out_msg).m_usesTxnId = (true);
(param_out_msg).m_txnId = (*param_tbe).m_addr;
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_accAddr = (*param_tbe).m_pendReqAccAddr;
(param_out_msg).m_accSize = (*param_tbe).m_pendReqAccSize;
(param_out_msg).m_type = (*param_tbe).m_pendReqType;
(param_out_msg).m_Destination = (*param_tbe).m_pendReqDest;
(param_out_msg).m_dataToFwdRequestor = (*param_tbe).m_pendReqD2OrigReq;
(param_out_msg).m_retToSrc = (*param_tbe).m_pendReqRetToSrc;
(param_out_msg).m_isSeqReqValid = (*param_tbe).m_isSeqReqValid;
(param_out_msg).m_seqReq = (*param_tbe).m_seqReq;
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = ((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf);

}
void
Cache_Controller::enqueueDoRetry(Cache_TBE* param_tbe)
{
    if (((*param_tbe).m_rcvdRetryAck && (*param_tbe).m_rcvdRetryCredit)) {
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge());
            (*out_msg).m_addr = (*param_tbe).m_addr;
            (*out_msg).m_usesTxnId = ((*param_tbe).m_is_dvm_tbe || (*param_tbe).m_is_dvm_snp_tbe);
            (*out_msg).m_event = Cache_Event_DoRetry;
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
        }
        (((*m_destsWaitingRetry_ptr)).removeNetDest((*param_tbe).m_pendReqDest));
    }

}
void
Cache_Controller::processRetryQueue()
{
bool has_avail
 = (((*m_storTBEs_ptr)).areNSlotsAvailable((1)));
#ifndef NDEBUG
if (!((m_unify_repl_TBEs || has_avail))) {
    panic("Runtime Error at CHI-cache-funcs.sm:695: %s.\n", "assert failure");

}
#endif
;
    if ((((((*m_retryQueue_ptr)).empty()) == (false)) && has_avail)) {
        (((*m_storTBEs_ptr)).incrementReserved());
        Cache_RetryQueueEntry e
         = (((*m_retryQueue_ptr)).next());
        (((*m_retryQueue_ptr)).pop());
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge());
            (*out_msg).m_addr = (e).m_addr;
            (*out_msg).m_usesTxnId = (e).m_usesTxnId;
            (*out_msg).m_retryDest = (e).m_retryDest;
            (*out_msg).m_event = Cache_Event_SendPCrdGrant;
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
        }
    }

}
void
Cache_Controller::printResources()
{
    if (m_unify_repl_TBEs) {
        #ifndef NDEBUG
        if (!(((((*m_storReplTBEs_ptr)).size()) == (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:712: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!(((((*m_storReplTBEs_ptr)).reserved()) == (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:713: %s.\n", "assert failure");

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:714: Resources(used/rsvd/max): TBEs=%d/%d/%d snpTBEs=%d/%d/%d replTBEs=%d/%d/%d dvmTBEs=%d/%d/%d\n", (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()), (((*m_storSnpTBEs_ptr)).size()), (((*m_storSnpTBEs_ptr)).reserved()), (((*m_storSnpTBEs_ptr)).capacity()), (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()), (((*m_storDvmTBEs_ptr)).size()), (((*m_storDvmTBEs_ptr)).reserved()), (((*m_storDvmTBEs_ptr)).capacity()));
    } else {
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:720: Resources(used/rsvd/max): TBEs=%d/%d/%d snpTBEs=%d/%d/%d replTBEs=%d/%d/%d dvmTBEs=%d/%d/%d\n", (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()), (((*m_storSnpTBEs_ptr)).size()), (((*m_storSnpTBEs_ptr)).reserved()), (((*m_storSnpTBEs_ptr)).capacity()), (((*m_storReplTBEs_ptr)).size()), (((*m_storReplTBEs_ptr)).reserved()), (((*m_storReplTBEs_ptr)).capacity()), (((*m_storDvmTBEs_ptr)).size()), (((*m_storDvmTBEs_ptr)).reserved()), (((*m_storDvmTBEs_ptr)).capacity()));
    }
    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:726: Resources(in/out size): req=%d/%d rsp=%d/%d dat=%d/%d snp=%d/%d trigger=%d\n", (((*m_reqIn_ptr)).getSize((curTick()))), (((*m_reqOut_ptr)).getSize((curTick()))), (((*m_rspIn_ptr)).getSize((curTick()))), (((*m_rspOut_ptr)).getSize((curTick()))), (((*m_datIn_ptr)).getSize((curTick()))), (((*m_datOut_ptr)).getSize((curTick()))), (((*m_snpIn_ptr)).getSize((curTick()))), (((*m_snpOut_ptr)).getSize((curTick()))), (((*m_triggerQueue_ptr)).getSize((curTick()))));

}
bool
Cache_Controller::needCacheEntry(const CHIRequestType& param_req_type, Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry, const bool& param_is_prefetch)
{
    if (((param_cache_entry != NULL) || ((m_enable_DMT && (param_dir_entry == NULL)) && (((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadUnique)) || (param_req_type == CHIRequestType_ReadOnce))))) {
        return (false);
    } else {
        return ((((((param_is_prefetch || (m_alloc_on_readshared && ((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadNotSharedDirty)))) || (m_alloc_on_readunique && (param_req_type == CHIRequestType_ReadUnique))) || (m_alloc_on_readonce && (param_req_type == CHIRequestType_ReadOnce))) || (m_alloc_on_writeback && ((((param_req_type == CHIRequestType_WriteBackFull) || (param_req_type == CHIRequestType_WriteCleanFull)) || (param_req_type == CHIRequestType_WriteEvictFull)) || (m_is_HN && (param_req_type == CHIRequestType_WriteUniqueFull))))) || (m_alloc_on_seq_acc && ((param_req_type == CHIRequestType_Load) || (param_req_type == CHIRequestType_Store)))) || (m_alloc_on_seq_line_write && (param_req_type == CHIRequestType_StoreLine)));
    }

}
bool
Cache_Controller::needDeallocCacheEntry(const CHIRequestType& param_req_type)
{
return ((m_dealloc_on_shared && ((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadNotSharedDirty))) || (m_dealloc_on_unique && ((param_req_type == CHIRequestType_ReadUnique) || (param_req_type == CHIRequestType_CleanUnique))));

}
bool
Cache_Controller::upstreamHasUnique(const Cache_State& param_state)
{
return (((param_state == Cache_State_RU) || (param_state == Cache_State_UD_RU)) || (param_state == Cache_State_UC_RU));

}
bool
Cache_Controller::upstreamHasShared(const Cache_State& param_state)
{
return ((((((((((param_state == Cache_State_RSC) || (param_state == Cache_State_RSD)) || (param_state == Cache_State_RUSD)) || (param_state == Cache_State_RUSC)) || (param_state == Cache_State_UD_RSD)) || (param_state == Cache_State_SD_RSD)) || (param_state == Cache_State_UD_RSC)) || (param_state == Cache_State_SD_RSC)) || (param_state == Cache_State_UC_RSC)) || (param_state == Cache_State_SC_RSC));

}
void
Cache_Controller::printTBEState(Cache_TBE* param_tbe)
{
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:783: STATE: addr: %#x data present=%d valid=%d unique=%d dirty=%d mu_dirty=%d dir ownerV=%d ownerE=%d sharers=%d tobe_I=%d tobe_SC=%d doFill=%d pendAction=%s\n", (*param_tbe).m_addr, (((*param_tbe).m_dataBlkValid).isFull()), (*param_tbe).m_dataValid, (*param_tbe).m_dataUnique, (*param_tbe).m_dataDirty, (*param_tbe).m_dataMaybeDirtyUpstream, (*param_tbe).m_dir_ownerExists, (*param_tbe).m_dir_ownerIsExcl, (((*param_tbe).m_dir_sharers).count()), (*param_tbe).m_dataToBeInvalid, (*param_tbe).m_dataToBeSharedClean, (*param_tbe).m_doCacheFill, (*param_tbe).m_pendAction);
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:789: dataBlkValid = %s\n", (*param_tbe).m_dataBlkValid);

}
void
Cache_Controller::printDvmTBEState(Cache_TBE* param_tbe)
{
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:793: STATE: addr=%#x reqType=%d state=%d pendAction=%s isDvmTBE=%d isReplTBE=%d isReqTBE=%d isSnpTBE=%d\n", (*param_tbe).m_addr, (*param_tbe).m_reqType, (*param_tbe).m_state, (*param_tbe).m_pendAction, (*param_tbe).m_is_dvm_tbe, (*param_tbe).m_is_repl_tbe, (*param_tbe).m_is_req_tbe, (*param_tbe).m_is_snp_tbe);

}
MachineID
Cache_Controller::getMiscNodeMachine()
{
return (mapAddressToMachine((intToAddress((0))), MachineType_MiscNode));

}
void
Cache_Controller::copyCacheAndDir(Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry, Cache_TBE* param_tbe, const Cache_State& param_initialState)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:805: %s.\n", "assert failure");

}
#endif
;
    if ((param_dir_entry != NULL)) {
        #ifndef NDEBUG
        if (!((((((((((((((param_initialState == Cache_State_UD_RSC) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_SC_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RSC)) || (param_initialState == Cache_State_RSD)) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_RUSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:815: %s.\n", "assert failure");

        }
        #endif
        ;
        (*param_tbe).m_dir_sharers = (*param_dir_entry).m_sharers;
        (*param_tbe).m_dir_owner = (*param_dir_entry).m_owner;
        (*param_tbe).m_dir_ownerExists = (*param_dir_entry).m_ownerExists;
        (*param_tbe).m_dir_ownerIsExcl = (*param_dir_entry).m_ownerIsExcl;
        #ifndef NDEBUG
        if (!(((((*param_tbe).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:820: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        (((*param_tbe).m_dir_sharers).clear());
        (*param_tbe).m_dir_ownerExists = (false);
    }
    #ifndef NDEBUG
    if (!((((*param_tbe).m_dir_ownerExists && (*param_tbe).m_dir_ownerIsExcl) == (((param_initialState == Cache_State_UD_RU) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU))))) {
        panic("Runtime Error at CHI-cache-funcs.sm:828: %s.\n", "assert failure");

    }
    #endif
    ;
    #ifndef NDEBUG
    if (!((((*param_tbe).m_dir_ownerExists && ((*param_tbe).m_dir_ownerIsExcl == (false))) == ((((param_initialState == Cache_State_RSD) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD))))) {
        panic("Runtime Error at CHI-cache-funcs.sm:831: %s.\n", "assert failure");

    }
    #endif
    ;
        if (((param_cache_entry != NULL) && (((((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_SD)) || (param_initialState == Cache_State_UC)) || (param_initialState == Cache_State_SC)) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_SC_RSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_UD_T)))) {
            (*param_tbe).m_dataBlk = (*param_cache_entry).m_DataBlk;
            (((*param_tbe).m_dataBlkValid).fillMask());
            (*param_tbe).m_dataValid = (true);
            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:844: Cached data %s\n", (*param_tbe).m_dataBlk);
        } else {
            #ifndef NDEBUG
            if (!(((param_cache_entry == NULL) || (((param_cache_entry != NULL) && (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC_RU))))) {
                panic("Runtime Error at CHI-cache-funcs.sm:848: %s.\n", "assert failure");

            }
            #endif
            ;
            (((*param_tbe).m_dataBlkValid).clear());
            (*param_tbe).m_dataValid = (false);
        }
            if (((param_cache_entry != NULL) && (((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf) == (false)))) {
                (((*m_cache_ptr)).setMRU(param_cache_entry));
            }
            (*param_tbe).m_dataDirty = ((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_SD)) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_UD_T));
            (*param_tbe).m_dataMaybeDirtyUpstream = (((((((param_initialState == Cache_State_UD_RU) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RSD)) || (param_initialState == Cache_State_RUSD));
            #ifndef NDEBUG
            if (!(((*param_tbe).m_dir_ownerExists == (*param_tbe).m_dataMaybeDirtyUpstream))) {
                panic("Runtime Error at CHI-cache-funcs.sm:869: %s.\n", "assert failure");

            }
            #endif
            ;
            (*param_tbe).m_dataUnique = (((((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_RUSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_UD_T));
            (*param_tbe).m_hasUseTimeout = (param_initialState == Cache_State_UD_T);
            (*param_tbe).m_dataToBeSharedClean = (false);
            (*param_tbe).m_dataToBeInvalid = (false);
            (printTBEState(param_tbe));

}
void
Cache_Controller::copyCacheAndDirTBEs(Cache_TBE* param_src, Cache_TBE* param_dst)
{
#ifndef NDEBUG
if (!((param_src != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:889: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((param_dst != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:890: %s.\n", "assert failure");

}
#endif
;
(*param_dst).m_dataBlk = (*param_src).m_dataBlk;
(*param_dst).m_dataBlkValid = (*param_src).m_dataBlkValid;
(*param_dst).m_dataValid = (*param_src).m_dataValid;
(*param_dst).m_dataDirty = (*param_src).m_dataDirty;
(*param_dst).m_dataMaybeDirtyUpstream = (*param_src).m_dataMaybeDirtyUpstream;
(*param_dst).m_dataUnique = (*param_src).m_dataUnique;
(*param_dst).m_dir_sharers = (*param_src).m_dir_sharers;
(*param_dst).m_dir_owner = (*param_src).m_dir_owner;
(*param_dst).m_dir_ownerExists = (*param_src).m_dir_ownerExists;
(*param_dst).m_dir_ownerIsExcl = (*param_src).m_dir_ownerIsExcl;
(printTBEState(param_dst));

}
void
Cache_Controller::deallocateReqTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:905: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_req_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:906: %s.\n", "assert failure");

}
#endif
;
(((*m_storTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_TBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateSnpTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:912: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:913: %s.\n", "assert failure");

}
#endif
;
(((*m_storSnpTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_snpTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateReplacementTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:919: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_repl_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:920: %s.\n", "assert failure");

}
#endif
;
    if (m_unify_repl_TBEs) {
        (((*m_storTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
    } else {
        (((*m_storReplTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
    }
    (((*m_replTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateDvmTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:930: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_dvm_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:931: %s.\n", "assert failure");

}
#endif
;
(((*m_storDvmTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_dvmTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateDvmSnoopTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:937: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_dvm_snp_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:938: %s.\n", "assert failure");

}
#endif
;
(((*m_storDvmSnpTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_dvmSnpTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::setDataToBeStates(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:944: %s.\n", "assert failure");

}
#endif
;
    if ((*param_tbe).m_dataToBeInvalid) {
        (*param_tbe).m_dataValid = (false);
        (((*param_tbe).m_dataBlkValid).clear());
    }
        if ((*param_tbe).m_dataToBeSharedClean) {
            (*param_tbe).m_dataUnique = (false);
            (*param_tbe).m_dataDirty = (false);
            #ifndef NDEBUG
            if (!(((*param_tbe).m_dataMaybeDirtyUpstream == (false)))) {
                panic("Runtime Error at CHI-cache-funcs.sm:952: %s.\n", "assert failure");

            }
            #endif
            ;
        }
        (*param_tbe).m_dataToBeInvalid = (false);
        (*param_tbe).m_dataToBeSharedClean = (false);

}
void
Cache_Controller::setExpectedForInvSnoop(Cache_TBE* param_tbe, const bool& param_expectCleanWB)
{
#ifndef NDEBUG
if (!(((((*param_tbe).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:959: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*param_tbe).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:960: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(param_tbe));
    if (param_expectCleanWB) {
        (((*param_tbe).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I));
    }
        if ((*param_tbe).m_dataMaybeDirtyUpstream) {
            #ifndef NDEBUG
            if (!((*param_tbe).m_dir_ownerExists)) {
                panic("Runtime Error at CHI-cache-funcs.sm:966: %s.\n", "assert failure");

            }
            #endif
            ;
            (((*param_tbe).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_PD));
                if (((param_expectCleanWB == (false)) || ((((*param_tbe).m_dir_sharers).count()) > (1)))) {
                    (((*param_tbe).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I));
                }
            } else {
                (((*param_tbe).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I));
            }
            (((*param_tbe).m_expected_snp_resp).setExpectedCount((((*param_tbe).m_dir_sharers).count())));

}
Cache_State
Cache_Controller::makeFinalStateHelper(const Cache_State& param_cs, const Cache_State& param_ds)
{
    if ((param_ds == Cache_State_RSC)) {
            if ((param_cs == Cache_State_UD)) {
                return Cache_State_UD_RSC;
            } else {
                    if ((param_cs == Cache_State_SD)) {
                        return Cache_State_SD_RSC;
                    } else {
                            if ((param_cs == Cache_State_UC)) {
                                return Cache_State_UC_RSC;
                            } else {
                                    if ((param_cs == Cache_State_SC)) {
                                        return Cache_State_SC_RSC;
                                    } else {
                                        return Cache_State_RSC;
                                    }
                                }
                            }
                        }
                    } else {
                            if ((param_ds == Cache_State_RU)) {
                                    if ((param_cs == Cache_State_UD)) {
                                        return Cache_State_UD_RU;
                                    } else {
                                            if ((param_cs == Cache_State_UC)) {
                                                return Cache_State_UC_RU;
                                            } else {
                                                #ifndef NDEBUG
                                                if (!((param_cs != Cache_State_SC))) {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:996: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!((param_cs != Cache_State_SD))) {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:997: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                return Cache_State_RU;
                                            }
                                        }
                                    } else {
                                            if ((param_ds == Cache_State_RSD)) {
                                                    if ((param_cs == Cache_State_UD)) {
                                                        return Cache_State_UD_RSD;
                                                    } else {
                                                            if ((param_cs == Cache_State_SD)) {
                                                                return Cache_State_SD_RSD;
                                                            } else {
                                                                #ifndef NDEBUG
                                                                if (!((param_cs == Cache_State_I))) {
                                                                    panic("Runtime Error at CHI-cache-funcs.sm:1006: %s.\n", "assert failure");

                                                                }
                                                                #endif
                                                                ;
                                                                return Cache_State_RSD;
                                                            }
                                                        }
                                                    } else {
                                                            if ((param_ds == Cache_State_RUSD)) {
                                                                    if ((param_cs == Cache_State_UD)) {
                                                                        return Cache_State_UD_RSD;
                                                                    } else {
                                                                        #ifndef NDEBUG
                                                                        if (!((param_cs == Cache_State_I))) {
                                                                            panic("Runtime Error at CHI-cache-funcs.sm:1013: %s.\n", "assert failure");

                                                                        }
                                                                        #endif
                                                                        ;
                                                                        return Cache_State_RUSD;
                                                                    }
                                                                } else {
                                                                        if ((param_ds == Cache_State_RUSC)) {
                                                                                if ((param_cs == Cache_State_UC)) {
                                                                                    return Cache_State_UC_RSC;
                                                                                } else {
                                                                                        if ((param_cs == Cache_State_UD)) {
                                                                                            return Cache_State_UD_RSC;
                                                                                        } else {
                                                                                            #ifndef NDEBUG
                                                                                            if (!((param_cs == Cache_State_I))) {
                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:1022: %s.\n", "assert failure");

                                                                                            }
                                                                                            #endif
                                                                                            ;
                                                                                            return Cache_State_RUSC;
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    #ifndef NDEBUG
                                                                                    if (!((param_ds == Cache_State_I))) {
                                                                                        panic("Runtime Error at CHI-cache-funcs.sm:1026: %s.\n", "assert failure");

                                                                                    }
                                                                                    #endif
                                                                                    ;
                                                                                    return param_cs;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }

}
Cache_State
Cache_Controller::makeFinalState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry)
{
(setDataToBeStates(param_tbe));
(printTBEState(param_tbe));
Cache_State cache_state
 = Cache_State_I;
Cache_State dir_state
 = Cache_State_I;
    if ((*param_tbe).m_dir_ownerExists) {
        #ifndef NDEBUG
        if (!((param_dir_entry != NULL))) {
            panic("Runtime Error at CHI-cache-funcs.sm:1039: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*param_tbe).m_dataMaybeDirtyUpstream)) {
            panic("Runtime Error at CHI-cache-funcs.sm:1040: %s.\n", "assert failure");

        }
        #endif
        ;
            if ((*param_tbe).m_dir_ownerIsExcl) {
                #ifndef NDEBUG
                if (!(((((*param_tbe).m_dir_sharers).count()) == (1)))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:1042: %s.\n", "assert failure");

                }
                #endif
                ;
                dir_state = Cache_State_RU;
            } else {
                #ifndef NDEBUG
                if (!(((((*param_tbe).m_dir_sharers).count()) >= (1)))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:1045: %s.\n", "assert failure");

                }
                #endif
                ;
                    if ((*param_tbe).m_dataUnique) {
                        dir_state = Cache_State_RUSD;
                    } else {
                        dir_state = Cache_State_RSD;
                    }
                }
            } else {
                    if (((((*param_tbe).m_dir_sharers).count()) > (0))) {
                        #ifndef NDEBUG
                        if (!((param_dir_entry != NULL))) {
                            panic("Runtime Error at CHI-cache-funcs.sm:1053: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*param_tbe).m_dataMaybeDirtyUpstream == (false)))) {
                            panic("Runtime Error at CHI-cache-funcs.sm:1054: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if ((*param_tbe).m_dataUnique) {
                                dir_state = Cache_State_RUSC;
                            } else {
                                dir_state = Cache_State_RSC;
                            }
                        }
                    }
                        if (((*param_tbe).m_dataValid && (param_cache_entry != NULL))) {
                                if (((*param_tbe).m_dataUnique && (*param_tbe).m_dataDirty)) {
                                        if ((*param_tbe).m_hasUseTimeout) {
                                            cache_state = Cache_State_UD_T;
                                        } else {
                                            cache_state = Cache_State_UD;
                                        }
                                    } else {
                                            if (((*param_tbe).m_dataUnique && ((*param_tbe).m_dataDirty == (false)))) {
                                                cache_state = Cache_State_UC;
                                            } else {
                                                    if ((((*param_tbe).m_dataUnique == (false)) && (*param_tbe).m_dataDirty)) {
                                                        #ifndef NDEBUG
                                                        if (!(m_allow_SD)) {
                                                            panic("Runtime Error at CHI-cache-funcs.sm:1072: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                        cache_state = Cache_State_SD;
                                                    } else {
                                                        cache_state = Cache_State_SC;
                                                    }
                                                }
                                            }
                                        }
                                        return (makeFinalStateHelper(cache_state, dir_state));

}
Cache_State
Cache_Controller::getNextState(const Addr& param_address)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_address));
#ifndef NDEBUG
if (!((tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1085: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_pendAction == Cache_Event_Final))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1086: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_finalState = (makeFinalState(tbe, (getCacheEntry(param_address)), (getDirEntry(param_address))));
#ifndef NDEBUG
if (!(((*tbe).m_finalState != Cache_State_null))) {
    panic("Runtime Error at CHI-cache-funcs.sm:1088: %s.\n", "assert failure");

}
#endif
;
return (*tbe).m_finalState;

}
int
Cache_Controller::scLockLatency()
{
return ((*m_sc_lock_multiplier_ptr) * m_sc_lock_base_latency_cy);

}
void
Cache_Controller::scLockIncLatency()
{
(*m_sc_lock_multiplier_ptr) = ((*m_sc_lock_multiplier_ptr) + m_sc_lock_multiplier_inc);
    if (((*m_sc_lock_multiplier_ptr) > m_sc_lock_multiplier_max)) {
        (*m_sc_lock_multiplier_ptr) = m_sc_lock_multiplier_max;
    }
    DPRINTF(LLSC, "CHI-cache-funcs.sm:1103: SC lock latency increased to %d cy\n", (scLockLatency()));

}
void
Cache_Controller::scLockDecayLatency()
{
(*m_sc_lock_multiplier_ptr) = ((*m_sc_lock_multiplier_ptr) - m_sc_lock_multiplier_decay);
    if (((*m_sc_lock_multiplier_ptr) < (0))) {
        (*m_sc_lock_multiplier_ptr) = (0);
    }
    DPRINTF(LLSC, "CHI-cache-funcs.sm:1112: SC lock latency decayed to %d cy\n", (scLockLatency()));

}
void
Cache_Controller::clearPendingAction(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_snd_pendEv) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_pendAction == Cache_Event_TX_Data))) {
            panic("Runtime Error at CHI-cache-funcs.sm:1118: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        (*param_tbe).m_pendAction = Cache_Event_null;
    }

}
bool
Cache_Controller::isReadReqType(const CHIRequestType& param_type)
{
    if (((((param_type == CHIRequestType_Load) || (param_type == CHIRequestType_ReadShared)) || (param_type == CHIRequestType_ReadNotSharedDirty)) || (param_type == CHIRequestType_ReadOnce))) {
        return (true);
    }
    return (false);

}
bool
Cache_Controller::isWriteReqType(const CHIRequestType& param_type)
{
    if ((((((param_type == CHIRequestType_Store) || (param_type == CHIRequestType_StoreLine)) || (param_type == CHIRequestType_WriteUniquePtl)) || (param_type == CHIRequestType_WriteUniqueFull)) || (param_type == CHIRequestType_ReadUnique))) {
        return (true);
    }
    return (false);

}
Cache_Event
Cache_Controller::reqToEvent(const CHIRequestType& param_type, const bool& param_is_prefetch)
{
    if ((param_type == CHIRequestType_Load)) {
            if ((param_is_prefetch == (false))) {
                return Cache_Event_Load;
            } else {
                return Cache_Event_Prefetch;
            }
        } else {
                if ((param_type == CHIRequestType_Store)) {
                    return Cache_Event_Store;
                } else {
                        if ((param_type == CHIRequestType_StoreLine)) {
                            return Cache_Event_Store;
                        } else {
                                if ((param_type == CHIRequestType_ReadShared)) {
                                    return Cache_Event_ReadShared;
                                } else {
                                        if ((param_type == CHIRequestType_ReadNotSharedDirty)) {
                                            return Cache_Event_ReadNotSharedDirty;
                                        } else {
                                                if ((param_type == CHIRequestType_ReadUnique)) {
                                                        if (m_is_HN) {
                                                            return Cache_Event_ReadUnique_PoC;
                                                        } else {
                                                            return Cache_Event_ReadUnique;
                                                        }
                                                    } else {
                                                            if ((param_type == CHIRequestType_CleanUnique)) {
                                                                return Cache_Event_CleanUnique;
                                                            } else {
                                                                    if ((param_type == CHIRequestType_ReadOnce)) {
                                                                        return Cache_Event_ReadOnce;
                                                                    } else {
                                                                            if ((param_type == CHIRequestType_Evict)) {
                                                                                return Cache_Event_Evict;
                                                                            } else {
                                                                                    if ((param_type == CHIRequestType_WriteBackFull)) {
                                                                                        return Cache_Event_WriteBackFull;
                                                                                    } else {
                                                                                            if ((param_type == CHIRequestType_WriteEvictFull)) {
                                                                                                return Cache_Event_WriteEvictFull;
                                                                                            } else {
                                                                                                    if ((param_type == CHIRequestType_WriteCleanFull)) {
                                                                                                        return Cache_Event_WriteCleanFull;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIRequestType_WriteUniquePtl)) {
                                                                                                                    if (m_is_HN) {
                                                                                                                        return Cache_Event_WriteUniquePtl_PoC;
                                                                                                                    } else {
                                                                                                                        return Cache_Event_WriteUnique;
                                                                                                                    }
                                                                                                                } else {
                                                                                                                        if ((param_type == CHIRequestType_WriteUniqueFull)) {
                                                                                                                                if ((m_is_HN && m_alloc_on_writeback)) {
                                                                                                                                    return Cache_Event_WriteUniqueFull_PoC_Alloc;
                                                                                                                                } else {
                                                                                                                                        if (m_is_HN) {
                                                                                                                                            return Cache_Event_WriteUniqueFull_PoC;
                                                                                                                                        } else {
                                                                                                                                            return Cache_Event_WriteUnique;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                        if ((param_type == CHIRequestType_DvmTlbi_Initiate)) {
                                                                                                                                            return Cache_Event_DvmTlbi_Initiate;
                                                                                                                                        } else {
                                                                                                                                                if ((param_type == CHIRequestType_DvmSync_Initiate)) {
                                                                                                                                                    return Cache_Event_DvmSync_Initiate;
                                                                                                                                                } else {
                                                                                                                                                    panic("Runtime Error at CHI-cache-funcs.sm:1200: %s.\n", ("Invalid CHIRequestType"));
                                                                                                                                                    ;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }

}
Cache_Event
Cache_Controller::respToEvent(const CHIResponseType& param_type, Cache_TBE* param_tbe)
{
bool on_hazard
 = ((param_tbe != NULL) && ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard));
    if ((param_type == CHIResponseType_Comp_I)) {
        return Cache_Event_Comp_I;
    } else {
            if ((param_type == CHIResponseType_Comp_UC)) {
                return Cache_Event_Comp_UC;
            } else {
                    if ((param_type == CHIResponseType_Comp_SC)) {
                        return Cache_Event_Comp_SC;
                    } else {
                            if ((param_type == CHIResponseType_CompDBIDResp)) {
                                return Cache_Event_CompDBIDResp;
                            } else {
                                    if ((param_type == CHIResponseType_DBIDResp)) {
                                        return Cache_Event_DBIDResp;
                                    } else {
                                            if ((param_type == CHIResponseType_Comp)) {
                                                return Cache_Event_Comp;
                                            } else {
                                                    if ((param_type == CHIResponseType_CompAck)) {
                                                        return Cache_Event_CompAck;
                                                    } else {
                                                            if ((param_type == CHIResponseType_ReadReceipt)) {
                                                                return Cache_Event_ReadReceipt;
                                                            } else {
                                                                    if ((param_type == CHIResponseType_RespSepData)) {
                                                                        return Cache_Event_RespSepData;
                                                                    } else {
                                                                            if ((param_type == CHIResponseType_SnpResp_I)) {
                                                                                return Cache_Event_SnpResp_I;
                                                                            } else {
                                                                                    if ((param_type == CHIResponseType_SnpResp_I_Fwded_UC)) {
                                                                                        return Cache_Event_SnpResp_I_Fwded_UC;
                                                                                    } else {
                                                                                            if ((param_type == CHIResponseType_SnpResp_I_Fwded_UD_PD)) {
                                                                                                return Cache_Event_SnpResp_I_Fwded_UD_PD;
                                                                                            } else {
                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC)) {
                                                                                                        return Cache_Event_SnpResp_SC;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIResponseType_SnpResp_SC_Fwded_SC)) {
                                                                                                                return Cache_Event_SnpResp_SC_Fwded_SC;
                                                                                                            } else {
                                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD)) {
                                                                                                                        return Cache_Event_SnpResp_SC_Fwded_SD_PD;
                                                                                                                    } else {
                                                                                                                            if ((param_type == CHIResponseType_SnpResp_SD_Fwded_I)) {
                                                                                                                                return Cache_Event_SnpResp_SD_Fwded_I;
                                                                                                                            } else {
                                                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC_Fwded_I)) {
                                                                                                                                        return Cache_Event_SnpResp_SC_Fwded_I;
                                                                                                                                    } else {
                                                                                                                                            if ((param_type == CHIResponseType_SnpResp_UD_Fwded_I)) {
                                                                                                                                                return Cache_Event_SnpResp_UD_Fwded_I;
                                                                                                                                            } else {
                                                                                                                                                    if ((param_type == CHIResponseType_SnpResp_UC_Fwded_I)) {
                                                                                                                                                        return Cache_Event_SnpResp_UC_Fwded_I;
                                                                                                                                                    } else {
                                                                                                                                                            if ((param_type == CHIResponseType_RetryAck)) {
                                                                                                                                                                    if (m_is_HN) {
                                                                                                                                                                            if (on_hazard) {
                                                                                                                                                                                return Cache_Event_RetryAck_PoC_Hazard;
                                                                                                                                                                            } else {
                                                                                                                                                                                return Cache_Event_RetryAck_PoC;
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                                if (on_hazard) {
                                                                                                                                                                                    return Cache_Event_RetryAck_Hazard;
                                                                                                                                                                                } else {
                                                                                                                                                                                    return Cache_Event_RetryAck;
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                                if ((param_type == CHIResponseType_PCrdGrant)) {
                                                                                                                                                                                        if (m_is_HN) {
                                                                                                                                                                                                if (on_hazard) {
                                                                                                                                                                                                    return Cache_Event_PCrdGrant_PoC_Hazard;
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    return Cache_Event_PCrdGrant_PoC;
                                                                                                                                                                                                }
                                                                                                                                                                                            } else {
                                                                                                                                                                                                    if (on_hazard) {
                                                                                                                                                                                                        return Cache_Event_PCrdGrant_Hazard;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        return Cache_Event_PCrdGrant;
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            } else {
                                                                                                                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:1273: %s.\n", ("Invalid CHIResponseType"));
                                                                                                                                                                                                ;
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }

}
Cache_Event
Cache_Controller::dataToEvent(const CHIDataType& param_type)
{
    if ((param_type == CHIDataType_CompData_I)) {
        return Cache_Event_CompData_I;
    } else {
            if ((param_type == CHIDataType_CompData_UC)) {
                return Cache_Event_CompData_UC;
            } else {
                    if ((param_type == CHIDataType_CompData_SC)) {
                        return Cache_Event_CompData_SC;
                    } else {
                            if ((param_type == CHIDataType_CompData_UD_PD)) {
                                return Cache_Event_CompData_UD_PD;
                            } else {
                                    if ((param_type == CHIDataType_CompData_SD_PD)) {
                                        return Cache_Event_CompData_SD_PD;
                                    } else {
                                            if ((param_type == CHIDataType_DataSepResp_UC)) {
                                                return Cache_Event_DataSepResp_UC;
                                            } else {
                                                    if ((param_type == CHIDataType_CBWrData_I)) {
                                                        return Cache_Event_CBWrData_I;
                                                    } else {
                                                            if ((param_type == CHIDataType_CBWrData_UC)) {
                                                                return Cache_Event_CBWrData_UC;
                                                            } else {
                                                                    if ((param_type == CHIDataType_CBWrData_SC)) {
                                                                        return Cache_Event_CBWrData_SC;
                                                                    } else {
                                                                            if ((param_type == CHIDataType_CBWrData_UD_PD)) {
                                                                                return Cache_Event_CBWrData_UD_PD;
                                                                            } else {
                                                                                    if ((param_type == CHIDataType_CBWrData_SD_PD)) {
                                                                                        return Cache_Event_CBWrData_SD_PD;
                                                                                    } else {
                                                                                            if ((param_type == CHIDataType_NCBWrData)) {
                                                                                                return Cache_Event_NCBWrData;
                                                                                            } else {
                                                                                                    if ((param_type == CHIDataType_SnpRespData_I_PD)) {
                                                                                                        return Cache_Event_SnpRespData_I_PD;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIDataType_SnpRespData_I)) {
                                                                                                                return Cache_Event_SnpRespData_I;
                                                                                                            } else {
                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SC_PD)) {
                                                                                                                        return Cache_Event_SnpRespData_SC_PD;
                                                                                                                    } else {
                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SC)) {
                                                                                                                                return Cache_Event_SnpRespData_SC;
                                                                                                                            } else {
                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SD)) {
                                                                                                                                        return Cache_Event_SnpRespData_SD;
                                                                                                                                    } else {
                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_UC)) {
                                                                                                                                                return Cache_Event_SnpRespData_UC;
                                                                                                                                            } else {
                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_UD)) {
                                                                                                                                                        return Cache_Event_SnpRespData_UD;
                                                                                                                                                    } else {
                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SC_Fwded_SC)) {
                                                                                                                                                                return Cache_Event_SnpRespData_SC_Fwded_SC;
                                                                                                                                                            } else {
                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) {
                                                                                                                                                                        return Cache_Event_SnpRespData_SC_Fwded_SD_PD;
                                                                                                                                                                    } else {
                                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) {
                                                                                                                                                                                return Cache_Event_SnpRespData_SC_PD_Fwded_SC;
                                                                                                                                                                            } else {
                                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) {
                                                                                                                                                                                        return Cache_Event_SnpRespData_I_Fwded_SD_PD;
                                                                                                                                                                                    } else {
                                                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_I_PD_Fwded_SC)) {
                                                                                                                                                                                                return Cache_Event_SnpRespData_I_PD_Fwded_SC;
                                                                                                                                                                                            } else {
                                                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_I_Fwded_SC)) {
                                                                                                                                                                                                        return Cache_Event_SnpRespData_I_Fwded_SC;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        panic("Runtime Error at CHI-cache-funcs.sm:1329: %s.\n", ("Invalid CHIDataType"));
                                                                                                                                                                                                        ;
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }

}
Cache_Event
Cache_Controller::snpToEvent(const CHIRequestType& param_type)
{
    if ((param_type == CHIRequestType_SnpCleanInvalid)) {
        return Cache_Event_SnpCleanInvalid;
    } else {
            if ((param_type == CHIRequestType_SnpShared)) {
                return Cache_Event_SnpShared;
            } else {
                    if ((param_type == CHIRequestType_SnpUnique)) {
                        return Cache_Event_SnpUnique;
                    } else {
                            if ((param_type == CHIRequestType_SnpSharedFwd)) {
                                return Cache_Event_SnpSharedFwd;
                            } else {
                                    if ((param_type == CHIRequestType_SnpNotSharedDirtyFwd)) {
                                        return Cache_Event_SnpNotSharedDirtyFwd;
                                    } else {
                                            if ((param_type == CHIRequestType_SnpUniqueFwd)) {
                                                return Cache_Event_SnpUniqueFwd;
                                            } else {
                                                    if ((param_type == CHIRequestType_SnpOnce)) {
                                                        return Cache_Event_SnpOnce;
                                                    } else {
                                                            if ((param_type == CHIRequestType_SnpOnceFwd)) {
                                                                return Cache_Event_SnpOnceFwd;
                                                            } else {
                                                                    if ((param_type == CHIRequestType_SnpDvmOpSync_P1)) {
                                                                        return Cache_Event_SnpDvmOpSync_P1;
                                                                    } else {
                                                                            if ((param_type == CHIRequestType_SnpDvmOpSync_P2)) {
                                                                                return Cache_Event_SnpDvmOpSync_P2;
                                                                            } else {
                                                                                    if ((param_type == CHIRequestType_SnpDvmOpNonSync_P1)) {
                                                                                        return Cache_Event_SnpDvmOpNonSync_P1;
                                                                                    } else {
                                                                                            if ((param_type == CHIRequestType_SnpDvmOpNonSync_P2)) {
                                                                                                return Cache_Event_SnpDvmOpNonSync_P2;
                                                                                            } else {
                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:1359: %s.\n", ("Invalid CHIRequestType"));
                                                                                                ;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

}
void
Cache_Controller::recordRequestType(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
    if ((param_request_type == Cache_RequestType_DataArrayRead)) {
        (((*m_cache_ptr)).recordRequestType(CacheRequestType_DataArrayRead, param_addr));
    } else {
            if ((param_request_type == Cache_RequestType_DataArrayWrite)) {
                (((*m_cache_ptr)).recordRequestType(CacheRequestType_DataArrayWrite, param_addr));
            } else {
                    if ((param_request_type == Cache_RequestType_TagArrayRead)) {
                        (((*m_cache_ptr)).recordRequestType(CacheRequestType_TagArrayRead, param_addr));
                    } else {
                            if ((param_request_type == Cache_RequestType_TagArrayWrite)) {
                                (((*m_cache_ptr)).recordRequestType(CacheRequestType_TagArrayWrite, param_addr));
                            }
                        }
                    }
                }

}
bool
Cache_Controller::_checkResourceAvailable(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
    if ((param_request_type == Cache_RequestType_DataArrayRead)) {
        return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_DataArray, param_addr));
    } else {
            if ((param_request_type == Cache_RequestType_DataArrayWrite)) {
                return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_DataArray, param_addr));
            } else {
                    if ((param_request_type == Cache_RequestType_TagArrayRead)) {
                        return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_TagArray, param_addr));
                    } else {
                            if ((param_request_type == Cache_RequestType_TagArrayWrite)) {
                                return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_TagArray, param_addr));
                            } else {
                                    if ((param_request_type == Cache_RequestType_DestinationAvailable)) {
                                            if (m_throttle_req_on_retry) {
                                                MachineID dest
                                                 = (mapAddressToDownstreamMachine(param_addr));
                                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:1401: Checking %s for addr %#x dest %s\n", param_request_type, param_addr, dest);
                                                return ((((*m_destsWaitingRetry_ptr)).isElement(dest)) == (false));
                                            } else {
                                                return (true);
                                            }
                                        } else {
                                                if ((param_request_type == Cache_RequestType_ReplTBEAvailable)) {
                                                    return (m_unify_repl_TBEs || (((*m_storReplTBEs_ptr)).areNSlotsAvailable((1))));
                                                } else {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:1411: %s.\n", ("Invalid RequestType type in checkResourceAvailable"));
                                                    ;
                                                    return (true);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

}
bool
Cache_Controller::checkResourceAvailable(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
bool avail
 = (_checkResourceAvailable(param_request_type, param_addr));
    if ((avail == (false))) {
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:1419: Resource %s not available for addr: %#x\n", param_request_type, param_addr);
    }
    return avail;

}
bool
Cache_Controller::rspInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:97: %s.\n", ("rspInPort must never stall\n"));
;
return (false);

}
bool
Cache_Controller::datInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:117: %s.\n", ("datInPort must never stall\n"));
;
return (false);

}
bool
Cache_Controller::snpRdyPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:154: %s.\n", ("snpRdyPort must never stall\n"));
;
return (false);

}
void
Cache_Controller::wakeupPendingSnps(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_snp) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_snp = (false);
    }

}
bool
Cache_Controller::retryTriggerInPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:227: Retry trigger queue resource stall\n");
(((*m_retryTriggerQueue_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
bool
Cache_Controller::triggerInPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:262: Trigger queue resource stall\n");
(((*m_triggerQueue_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
void
Cache_Controller::wakeupPendingTgrs(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_tgr) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_triggerQueue_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_tgr = (false);
    }

}
bool
Cache_Controller::reqRdyPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:359: ReqRdy queue resource stall\n");
(((*m_reqRdy_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
void
Cache_Controller::wakeupPendingReqs(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_req) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_reqRdy_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_req = (false);
    }

}
bool
Cache_Controller::reqInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:392: %s.\n", ("reqInPort must never stall\n"));
;
return (false);

}
void
Cache_Controller::processNextState(const Addr& param_address, Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-ports.sm:446: %s.\n", "assert failure");

}
#endif
;
DPRINTF(RubySlicc, "CHI-cache-ports.sm:447: GoToNextState expected_req_resp=%d expected_snp_resp=%d snd_pendEv=%d snd_pendBytes=%d\n", (((*param_tbe).m_expected_req_resp).expected()), (((*param_tbe).m_expected_snp_resp).expected()), (*param_tbe).m_snd_pendEv, (((*param_tbe).m_snd_pendBytes).count()));
bool has_nb_trigger
 = ((((((*param_tbe).m_actions).empty()) == (false)) && (((*param_tbe).m_actions).frontNB())) && ((*param_tbe).m_snd_pendEv == (false)));
int expected_msgs
 = (((((*param_tbe).m_expected_req_resp).expected()) + (((*param_tbe).m_expected_snp_resp).expected())) + (((*param_tbe).m_snd_pendBytes).count()));
    if ((((*param_tbe).m_pendAction == Cache_Event_null) && ((expected_msgs == (0)) || has_nb_trigger))) {
        Cycles trigger_latency
         = (intToCycles((0)));
            if (((*param_tbe).m_delayNextAction > (curTick()))) {
                trigger_latency = ((ticksToCycles((*param_tbe).m_delayNextAction)) - (ticksToCycles((curTick()))));
                (*param_tbe).m_delayNextAction = (intToTick((0)));
            }
            (*param_tbe).m_pendAction = Cache_Event_null;
                if ((((*param_tbe).m_actions).empty())) {
                    (*param_tbe).m_pendAction = Cache_Event_Final;
                } else {
                    (*param_tbe).m_pendAction = (((*param_tbe).m_actions).front());
                    (((*param_tbe).m_actions).pop());
                }
                #ifndef NDEBUG
                if (!(((*param_tbe).m_pendAction != Cache_Event_null))) {
                    panic("Runtime Error at CHI-cache-ports.sm:476: %s.\n", "assert failure");

                }
                #endif
                ;
                {
                    std::shared_ptr<Cache_TriggerMsg> out_msg = std::make_shared<Cache_TriggerMsg>(clockEdge());
                    (*out_msg).m_addr = (*param_tbe).m_addr;
                    (*out_msg).m_usesTxnId = ((*param_tbe).m_is_dvm_tbe || (*param_tbe).m_is_dvm_snp_tbe);
                    (*out_msg).m_from_hazard = ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard);
                    ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(trigger_latency)));
                }
            }
            (printTBEState(param_tbe));
            (wakeupPendingSnps(param_tbe));

}
int
Cache_Controller::functionalWriteBuffers(PacketPtr& pkt)
{
    int num_functional_writes = 0;
num_functional_writes += m_reqOut_ptr->functionalWrite(pkt);
num_functional_writes += m_snpOut_ptr->functionalWrite(pkt);
num_functional_writes += m_rspOut_ptr->functionalWrite(pkt);
num_functional_writes += m_datOut_ptr->functionalWrite(pkt);
num_functional_writes += m_reqIn_ptr->functionalWrite(pkt);
num_functional_writes += m_snpIn_ptr->functionalWrite(pkt);
num_functional_writes += m_rspIn_ptr->functionalWrite(pkt);
num_functional_writes += m_datIn_ptr->functionalWrite(pkt);
num_functional_writes += m_mandatoryQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_triggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_retryTriggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_reqRdy_ptr->functionalWrite(pkt);
num_functional_writes += m_snpRdy_ptr->functionalWrite(pkt);
num_functional_writes += m_replTriggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_prefetchQueue_ptr->functionalWrite(pkt);
    return num_functional_writes;
}
bool
Cache_Controller::functionalReadBuffers(PacketPtr& pkt)
{
if (m_reqOut_ptr->functionalRead(pkt)) return true;
if (m_snpOut_ptr->functionalRead(pkt)) return true;
if (m_rspOut_ptr->functionalRead(pkt)) return true;
if (m_datOut_ptr->functionalRead(pkt)) return true;
if (m_reqIn_ptr->functionalRead(pkt)) return true;
if (m_snpIn_ptr->functionalRead(pkt)) return true;
if (m_rspIn_ptr->functionalRead(pkt)) return true;
if (m_datIn_ptr->functionalRead(pkt)) return true;
if (m_mandatoryQueue_ptr->functionalRead(pkt)) return true;
if (m_triggerQueue_ptr->functionalRead(pkt)) return true;
if (m_retryTriggerQueue_ptr->functionalRead(pkt)) return true;
if (m_reqRdy_ptr->functionalRead(pkt)) return true;
if (m_snpRdy_ptr->functionalRead(pkt)) return true;
if (m_replTriggerQueue_ptr->functionalRead(pkt)) return true;
if (m_prefetchQueue_ptr->functionalRead(pkt)) return true;
    return false;
}

bool
Cache_Controller::functionalReadBuffers(PacketPtr& pkt, WriteMask &mask)
{
    bool read = false;
if (m_reqOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_rspOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_datOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_reqIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_rspIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_datIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_mandatoryQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_triggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_retryTriggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_reqRdy_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpRdy_ptr->functionalRead(pkt, mask)) read = true;
if (m_replTriggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_prefetchQueue_ptr->functionalRead(pkt, mask)) read = true;
    return read;
}

} // namespace ruby
} // namespace gem5
